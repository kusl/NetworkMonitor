===============================================================================
PROJECT EXPORT
Generated: Fri Dec 26 08:45:15 AM CST 2025
Project Path: /home/kushal/src/dotnet/network-monitor
===============================================================================

DIRECTORY STRUCTURE:
===================

/home/kushal/src/dotnet/network-monitor
‚îú‚îÄ‚îÄ export.sh
‚îú‚îÄ‚îÄ .github
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ workflows
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ build-and-test.yml
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ release.yml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ Directory.Build.props
    ‚îú‚îÄ‚îÄ Directory.Packages.props
    ‚îú‚îÄ‚îÄ generate-network-monitor.sh
    ‚îú‚îÄ‚îÄ .gitignore
    ‚îú‚îÄ‚îÄ NetworkMonitor.Console
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ appsettings.json
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitor.Console.csproj
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Program.cs
    ‚îú‚îÄ‚îÄ NetworkMonitor.Core
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Exporters
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FileExporterExtensions.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FileExporterOptions.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ FileMetricExporter.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Models
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HistoricalData.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MonitorOptions.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatus.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatusEventArgs.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PingResult.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ StorageOptions.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitor.Core.csproj
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ServiceCollectionExtensions.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Services
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ConsoleStatusDisplay.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ INetworkMonitorService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IPingService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IStatusDisplay.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MonitorBackgroundService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitorService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ PingService.cs
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Storage
    ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ IStorageService.cs
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ SqliteStorageService.cs
    ‚îú‚îÄ‚îÄ NetworkMonitor.slnx
    ‚îú‚îÄ‚îÄ NetworkMonitor.Tests
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Fakes
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakePingService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakePingServiceTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakeStorageService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ NullLogger.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitor.Tests.csproj
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatusTests.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PingResultTests.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Services
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ NetworkMonitorServiceTests.cs
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Storage
    ‚îî‚îÄ‚îÄ run.sh


FILE CONTENTS:
==============

================================================================================
FILE: .github/workflows/build-and-test.yml
SIZE: 1.34 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

# GitHub Actions Workflow: Build and Test
# Triggers on every push and pull request to any branch
# Builds and tests on all major platforms

name: Build and Test

on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'

permissions:
  contents: read

jobs:
  build-and-test:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'preview'

      - name: Display .NET info
        run: dotnet --info

      - name: Restore dependencies
        run: dotnet restore src/NetworkMonitor.slnx

      - name: Build solution
        run: dotnet build src/NetworkMonitor.slnx --configuration Release --no-restore

      - name: Run tests
        run: dotnet test src/NetworkMonitor.slnx --configuration Release --no-build --verbosity normal --logger "trx;LogFileName=test-results.trx"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: '**/test-results.trx'
          if-no-files-found: warn
          retention-days: 30


================================================================================
FILE: .github/workflows/release.yml
SIZE: 3.01 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

# GitHub Actions Workflow: Build and Release
# Triggers on every push to any branch
# Creates self-contained executables for all platforms
# Uploads as artifacts (not GitHub releases - those require tags)

name: Build and Release

on:
  push:
    branches:
      - '**'

permissions:
  contents: read

env:
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  build-binaries:
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux
          - os: ubuntu-latest
            rid: linux-x64
            artifact-name: network-monitor-linux-x64
          - os: ubuntu-latest
            rid: linux-arm64
            artifact-name: network-monitor-linux-arm64
          - os: ubuntu-latest
            rid: linux-musl-x64
            artifact-name: network-monitor-linux-musl-x64
          # Windows
          - os: windows-latest
            rid: win-arm64
            artifact-name: network-monitor-win-arm64
          # macOS
          - os: macos-latest
            rid: osx-x64
            artifact-name: network-monitor-osx-x64
          - os: macos-latest
            rid: osx-arm64
            artifact-name: network-monitor-osx-arm64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'preview'

      - name: Restore dependencies
        run: dotnet restore src/NetworkMonitor.slnx

      - name: Build and Publish
        run: |
          dotnet publish src/NetworkMonitor.Console/NetworkMonitor.Console.csproj \
            --configuration Release \
            --runtime ${{ matrix.rid }} \
            --self-contained true \
            -p:PublishSingleFile=true \
            -p:PublishTrimmed=false \
            -p:IncludeNativeLibrariesForSelfExtract=true \
            --output ./publish/${{ matrix.rid }}

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ./publish/${{ matrix.rid }}/
          if-no-files-found: error
          retention-days: 90

  # Create a combined release artifact with all binaries
  combine-artifacts:
    needs: build-binaries
    runs-on: ubuntu-latest
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./all-artifacts

      - name: Create combined archive
        run: |
          cd all-artifacts
          for dir in */; do
            name="${dir%/}"
            if [[ "$name" == *"win"* ]]; then
              zip -r "../${name}.zip" "$dir"
            else
              tar -czvf "../${name}.tar.gz" "$dir"
            fi
          done

      - name: Upload combined release
        uses: actions/upload-artifact@v4
        with:
          name: network-monitor-all-platforms-${{ github.sha }}
          path: |
            *.zip
            *.tar.gz
          if-no-files-found: error
          retention-days: 90


================================================================================
FILE: src/Directory.Build.props
SIZE: 1.85 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

<Project>
  <!-- 
    Shared build properties for all projects in the solution.
    
    ANALYSIS LEVEL NOTE:
    We use 'latest-recommended' instead of 'latest-all' because 'latest-all'
    enables rules that are impractical for a console application:
    - CA1303: Requires resource files for ALL literal strings
    - CA1848: Requires LoggerMessage for ALL log calls
    - CA2007: Requires ConfigureAwait everywhere (not needed in console apps)
    
    These rules are valuable for large libraries but overkill here.
  -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <!-- Use 'recommended' level - 'all' is too strict for console apps -->
    <AnalysisLevel>latest-recommended</AnalysisLevel>
    <!-- Enable .NET analyzers -->
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <!-- Enforce code style on build -->
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
  </PropertyGroup>

  <!-- Disable specific rules that don't make sense for this project -->
  <PropertyGroup>
    <!-- CA1303: Do not pass literals as localized parameters - not localizing this app -->
    <NoWarn>$(NoWarn);CA1303</NoWarn>
    <!-- CA2007: Consider calling ConfigureAwait - not needed in console app -->
    <NoWarn>$(NoWarn);CA2007</NoWarn>
    <!-- CA1848: Use LoggerMessage delegates - overkill for simple console app -->
    <NoWarn>$(NoWarn);CA1848</NoWarn>
    <!-- CA1716: Identifiers should not match keywords - 'from/to' are fine param names -->
    <NoWarn>$(NoWarn);CA1716</NoWarn>
  </PropertyGroup>

  <!-- Test projects don't need to be packaged -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
</Project>


================================================================================
FILE: src/Directory.Packages.props
SIZE: 2.11 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

<Project>
  <!--
    Central Package Management (CPM)
    All NuGet package versions are defined here for consistency.
    
    PACKAGE SELECTION CRITERIA:
    1. Must be free/open source (Apache 2.0, MIT, BSD, etc.)
    2. Must be actively maintained
    3. Prefer Microsoft/official packages where available
    4. Minimal footprint - only include what's truly needed
    
    BANNED PACKAGES (DO NOT ADD):
    - FluentAssertions (restrictive license)
    - MassTransit (restrictive license)
    - Moq (controversial maintainer)
    - Any package with "non-commercial only" license
    
    LAST UPDATED: 2025-12-26
  -->
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- Microsoft.Extensions.* - Core DI and hosting (MIT License) -->
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Options" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.0" />
    
    <!-- SQLite - Official Microsoft package (MIT License) -->
    <PackageVersion Include="Microsoft.Data.Sqlite" Version="10.0.0" />
    
    <!-- OpenTelemetry - Official packages (Apache 2.0 License) -->
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    
    <!-- Testing - xUnit 3 (Apache 2.0 License) -->
    <PackageVersion Include="xunit.v3" Version="1.1.0" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="3.1.1" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Console/appsettings.json
SIZE: 0.48 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

{
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "NetworkMonitor": "Information"
    }
  },
  "NetworkMonitor": {
    "RouterAddress": "192.168.1.1",
    "InternetTarget": "8.8.8.8",
    "TimeoutMs": 3000,
    "IntervalMs": 5000,
    "PingsPerCycle": 3,
    "ExcellentLatencyMs": 20,
    "GoodLatencyMs": 100,
    "DegradedPacketLossPercent": 10
  },
  "Storage": {
    "ApplicationName": "NetworkMonitor",
    "MaxFileSizeBytes": 26214400,
    "RetentionDays": 30
  }
}


================================================================================
FILE: src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
SIZE: 0.82 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    Console application entry point.
    Thin layer that wires up hosting and runs the monitor.
    All business logic is in NetworkMonitor.Core.
  -->
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\NetworkMonitor.Core\NetworkMonitor.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Console/Program.cs
SIZE: 2.45 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using NetworkMonitor.Core;
using NetworkMonitor.Core.Exporters;

// =============================================================================
// Network Monitor Console Application
// =============================================================================
// A cross-platform network monitoring tool that provides:
// - At-a-glance network health status (PRIMARY GOAL)
// - Historical trendlines via SQLite storage
// - OpenTelemetry metrics exported to files
//
// Usage:
//   dotnet run                          # Run with defaults
//   dotnet run -- --help                # Show help (future)
//   Ctrl+C                              # Graceful shutdown
//
// Configuration via appsettings.json or environment variables.
// =============================================================================

Console.WriteLine("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
Console.WriteLine("‚ïë           Network Monitor - Cross-Platform Edition           ‚ïë");
Console.WriteLine("‚ïë                  Press Ctrl+C to stop                        ‚ïë");
Console.WriteLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
Console.WriteLine();

var fileExporterOptions = new FileExporterOptions();
Console.WriteLine($"üìÅ Telemetry: {fileExporterOptions.Directory}");
Console.WriteLine($"üÜî Run ID: {fileExporterOptions.RunId}");
Console.WriteLine();

var builder = Host.CreateApplicationBuilder(args);

// Configure logging
builder.Logging.SetMinimumLevel(LogLevel.Warning);
builder.Logging.AddFilter("NetworkMonitor", LogLevel.Information);

// Register Network Monitor services
builder.Services.AddNetworkMonitor(builder.Configuration);
builder.Services.AddNetworkMonitorTelemetry(fileExporterOptions);

var host = builder.Build();

// Handle Ctrl+C gracefully
Console.CancelKeyPress += (_, e) =>
{
    e.Cancel = true;
    Console.WriteLine("\n\n‚èπÔ∏è  Shutting down...");
};

try
{
    await host.RunAsync().ConfigureAwait(false);
}
catch (OperationCanceledException)
{
    // Normal shutdown
}
finally
{
    Console.WriteLine("üëã Network Monitor stopped. Goodbye!");
}


================================================================================
FILE: src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
SIZE: 1.55 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using OpenTelemetry.Metrics;

namespace NetworkMonitor.Core.Exporters;

/// <summary>
/// Extension methods for registering file exporters.
/// </summary>
public static class FileExporterExtensions
{
    /// <summary>
    /// Adds a file exporter for metrics.
    /// </summary>
    /// <param name="builder">The meter provider builder.</param>
    /// <param name="options">Optional exporter options.</param>
    /// <returns>The builder for chaining.</returns>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        FileExporterOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(builder);

        options ??= FileExporterOptions.Default;

        var exporter = new FileMetricExporter(options);
        var reader = new PeriodicExportingMetricReader(exporter, exportIntervalMilliseconds: 10000);

        return builder.AddReader(reader);
    }

    /// <summary>
    /// Adds a file exporter with custom configuration.
    /// </summary>
    /// <param name="builder">The meter provider builder.</param>
    /// <param name="configure">Configuration action.</param>
    /// <returns>The builder for chaining.</returns>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        Action<FileExporterOptions> configure)
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(configure);

        var options = new FileExporterOptions();
        configure(options);
        return builder.AddFileExporter(options);
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
SIZE: 2.07 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using System.Globalization;

namespace NetworkMonitor.Core.Exporters;

/// <summary>
/// Configuration for file-based OpenTelemetry exporters.
/// Follows XDG specification with fallbacks.
/// </summary>
public sealed class FileExporterOptions
{
    /// <summary>
    /// Directory where telemetry files will be written.
    /// Automatically determined based on XDG spec if not set.
    /// </summary>
    public string Directory { get; set; } = GetDefaultDirectory();

    /// <summary>
    /// Maximum file size before rotation (25MB default).
    /// </summary>
    public long MaxFileSizeBytes { get; set; } = 25 * 1024 * 1024;

    /// <summary>
    /// Application name for directory structure.
    /// </summary>
    public string ApplicationName { get; set; } = "NetworkMonitor";

    /// <summary>
    /// Unique run identifier for file naming.
    /// </summary>
    public string RunId { get; set; } = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss", CultureInfo.InvariantCulture);

    private static string GetDefaultDirectory()
    {
        // XDG_DATA_HOME (Linux)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            return Path.Combine(xdgDataHome, "NetworkMonitor", "telemetry");
        }

        // Platform-specific app data
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            return Path.Combine(localAppData, "NetworkMonitor", "telemetry");
        }

        // Fallback to ~/.local/share
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(home))
        {
            return Path.Combine(home, ".local", "share", "NetworkMonitor", "telemetry");
        }

        // Final fallback: current directory
        return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    /// <summary>
    /// Gets default options instance.
    /// </summary>
    public static FileExporterOptions Default => new();
}


================================================================================
FILE: src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
SIZE: 5.32 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using System.Globalization;
using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace NetworkMonitor.Core.Exporters;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// Files are rotated based on size and date.
/// Failures are logged but don't stop the application.
/// </summary>
public sealed class FileMetricExporter : BaseExporter<Metric>
{
    private readonly FileExporterOptions _options;
    private readonly Lock _lock = new();
    private StreamWriter? _writer;
    private string _currentFilePath = string.Empty;
    private DateTime _currentDate;
    private long _currentSize;
    private int _fileNumber;
    private bool _firstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions;

    /// <summary>
    /// Creates a new file metric exporter.
    /// </summary>
    /// <param name="options">Exporter options.</param>
    public FileMetricExporter(FileExporterOptions? options = null)
    {
        _options = options ?? FileExporterOptions.Default;
        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        EnsureDirectory();
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<Metric> batch)
    {
        try
        {
            lock (_lock)
            {
                EnsureWriter();

                foreach (var metric in batch)
                {
                    foreach (var point in metric.GetMetricPoints())
                    {
                        var record = SerializeMetricPoint(metric, point);
                        var json = JsonSerializer.Serialize(record, _jsonOptions);
                        WriteJson(json);
                    }
                }

                _writer?.Flush();
            }

            return ExportResult.Success;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[FileMetricExporter] Export failed: {ex.Message}");
            return ExportResult.Failure;
        }
    }

    private static object SerializeMetricPoint(Metric metric, MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }

        object? value = metric.MetricType switch
        {
            MetricType.LongSum => point.GetSumLong(),
            MetricType.DoubleSum => point.GetSumDouble(),
            MetricType.LongGauge => point.GetGaugeLastValueLong(),
            MetricType.DoubleGauge => point.GetGaugeLastValueDouble(),
            MetricType.Histogram => new
            {
                Count = point.GetHistogramCount(),
                Sum = point.GetHistogramSum()
            },
            _ => null
        };

        return new
        {
            Timestamp = point.EndTime.ToString("O", CultureInfo.InvariantCulture),
            Name = metric.Name,
            Description = metric.Description,
            Unit = metric.Unit,
            Type = metric.MetricType.ToString(),
            Tags = tags,
            Value = value
        };
    }

    private void WriteJson(string json)
    {
        var bytes = Encoding.UTF8.GetByteCount(json) + 2;

        if (ShouldRotate(bytes))
        {
            RotateFile();
        }

        if (!_firstRecord)
        {
            _writer!.WriteLine(",");
        }
        else
        {
            _firstRecord = false;
        }

        _writer!.Write(json);
        _currentSize += bytes;
    }

    private bool ShouldRotate(long bytes) =>
        _currentSize + bytes > _options.MaxFileSizeBytes ||
        _currentDate != DateTime.UtcNow.Date;

    private void EnsureDirectory()
    {
        try
        {
            System.IO.Directory.CreateDirectory(_options.Directory);
        }
        catch
        {
            // Fallback to current directory
            _options.Directory = Environment.CurrentDirectory;
        }
    }

    private void EnsureWriter()
    {
        if (_writer == null)
        {
            OpenNewFile();
        }
        else if (_currentDate != DateTime.UtcNow.Date)
        {
            RotateFile();
        }
    }

    private void OpenNewFile()
    {
        _currentDate = DateTime.UtcNow.Date;
        _fileNumber = 0;
        _currentFilePath = GetFilePath();

        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentSize = 0;
        _firstRecord = true;

        _writer.WriteLine("[");
        _currentSize = 2;
    }

    private void RotateFile()
    {
        CloseWriter();
        _fileNumber++;
        OpenNewFile();
    }

    private string GetFilePath()
    {
        var fileName = _fileNumber == 0
            ? $"metrics_{_options.RunId}.json"
            : $"metrics_{_options.RunId}_{_fileNumber:D3}.json";
        return Path.Combine(_options.Directory, fileName);
    }

    private void CloseWriter()
    {
        if (_writer != null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    /// <inheritdoc />
    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/HistoricalData.cs
SIZE: 0.84 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Aggregated historical data for trendline display.
/// </summary>
/// <param name="Period">Time period this data covers</param>
/// <param name="AverageLatencyMs">Average latency in milliseconds</param>
/// <param name="MinLatencyMs">Minimum latency observed</param>
/// <param name="MaxLatencyMs">Maximum latency observed</param>
/// <param name="PacketLossPercent">Percentage of failed pings</param>
/// <param name="SampleCount">Number of pings in this period</param>
public sealed record HistoricalData(
    DateTimeOffset Period,
    double AverageLatencyMs,
    long MinLatencyMs,
    long MaxLatencyMs,
    double PacketLossPercent,
    int SampleCount);

/// <summary>
/// Time granularity for historical data aggregation.
/// </summary>
public enum TimeGranularity
{
    Minute,
    Hour,
    Day
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/MonitorOptions.cs
SIZE: 1.83 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration options for the network monitor.
/// Bound from appsettings.json or environment variables.
/// </summary>
public sealed class MonitorOptions
{
    /// <summary>
    /// Configuration section name in appsettings.json
    /// </summary>
    public const string SectionName = "NetworkMonitor";

    /// <summary>
    /// Router/gateway IP address to ping for local network health.
    /// Default: 192.168.1.1 (common home router)
    /// </summary>
    public string RouterAddress { get; set; } = "192.168.1.1";

    /// <summary>
    /// Internet target to ping for WAN connectivity.
    /// Default: 8.8.8.8 (Google DNS - highly reliable)
    /// </summary>
    public string InternetTarget { get; set; } = "8.8.8.8";

    /// <summary>
    /// Timeout for each ping in milliseconds.
    /// Default: 3000ms (3 seconds)
    /// </summary>
    public int TimeoutMs { get; set; } = 3000;

    /// <summary>
    /// Interval between monitoring cycles in milliseconds.
    /// Default: 5000ms (5 seconds)
    /// </summary>
    public int IntervalMs { get; set; } = 5000;

    /// <summary>
    /// Number of pings per target per cycle.
    /// Default: 3 (for statistical significance)
    /// </summary>
    public int PingsPerCycle { get; set; } = 3;

    /// <summary>
    /// Latency threshold (ms) below which is considered "excellent".
    /// Default: 20ms
    /// </summary>
    public int ExcellentLatencyMs { get; set; } = 20;

    /// <summary>
    /// Latency threshold (ms) below which is considered "good".
    /// Default: 100ms
    /// </summary>
    public int GoodLatencyMs { get; set; } = 100;

    /// <summary>
    /// Packet loss percentage above which network is "degraded".
    /// Default: 10%
    /// </summary>
    public int DegradedPacketLossPercent { get; set; } = 10;
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/NetworkStatus.cs
SIZE: 1.50 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Represents the overall network health status.
/// This is the "at a glance" view that's our highest priority.
/// </summary>
public enum NetworkHealth
{
    /// <summary>All targets responding with good latency</summary>
    Excellent,

    /// <summary>All targets responding but some latency</summary>
    Good,

    /// <summary>Some packet loss or high latency</summary>
    Degraded,

    /// <summary>Significant connectivity issues</summary>
    Poor,

    /// <summary>No connectivity</summary>
    Offline
}

/// <summary>
/// Comprehensive network status at a point in time.
/// Aggregates multiple ping results into a single status view.
/// </summary>
/// <param name="Health">Overall health assessment</param>
/// <param name="RouterResult">Result of pinging the local router/gateway</param>
/// <param name="InternetResult">Result of pinging an internet target (e.g., 8.8.8.8)</param>
/// <param name="Timestamp">When this status was computed</param>
/// <param name="Message">Human-readable status message</param>
public sealed record NetworkStatus(
    NetworkHealth Health,
    PingResult? RouterResult,
    PingResult? InternetResult,
    DateTimeOffset Timestamp,
    string Message)
{
    /// <summary>
    /// Quick check if network is usable (Excellent, Good, or Degraded).
    /// </summary>
    public bool IsUsable => Health is NetworkHealth.Excellent
                            or NetworkHealth.Good
                            or NetworkHealth.Degraded;
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
SIZE: 0.59 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Event arguments for network status change events.
/// Required for CA1003 compliance (EventHandler should use EventArgs).
/// </summary>
public sealed class NetworkStatusEventArgs : EventArgs
{
    /// <summary>
    /// The new network status.
    /// </summary>
    public NetworkStatus Status { get; }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs.
    /// </summary>
    /// <param name="status">The network status.</param>
    public NetworkStatusEventArgs(NetworkStatus status)
    {
        Status = status;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/PingResult.cs
SIZE: 1.14 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Represents the result of a single ping operation.
/// Immutable record for thread safety and easy comparison.
/// </summary>
/// <param name="Target">The hostname or IP address that was pinged</param>
/// <param name="Success">Whether the ping succeeded</param>
/// <param name="RoundtripTimeMs">Round-trip time in milliseconds (null if failed)</param>
/// <param name="Timestamp">When the ping was performed (UTC)</param>
/// <param name="ErrorMessage">Error message if the ping failed</param>
public sealed record PingResult(
    string Target,
    bool Success,
    long? RoundtripTimeMs,
    DateTimeOffset Timestamp,
    string? ErrorMessage = null)
{
    /// <summary>
    /// Creates a successful ping result.
    /// </summary>
    public static PingResult Succeeded(string target, long roundtripTimeMs) =>
        new(target, true, roundtripTimeMs, DateTimeOffset.UtcNow);

    /// <summary>
    /// Creates a failed ping result.
    /// </summary>
    public static PingResult Failed(string target, string errorMessage) =>
        new(target, false, null, DateTimeOffset.UtcNow, errorMessage);
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/StorageOptions.cs
SIZE: 2.85 KB
MODIFIED: 2025-12-26 07:36:03
================================================================================

using System.Globalization;
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration for telemetry storage.
/// Follows XDG Base Directory Specification with graceful fallbacks.
/// </summary>
public sealed class StorageOptions
{
    public const string SectionName = "Storage";

    /// <summary>
    /// Application name used for directory structure.
    /// </summary>
    public string ApplicationName { get; set; } = "NetworkMonitor";

    /// <summary>
    /// Maximum file size in bytes before rotation (25MB default).
    /// </summary>
    public long MaxFileSizeBytes { get; set; } = 25 * 1024 * 1024;

    /// <summary>
    /// How many days of data to retain in SQLite.
    /// Default: 30 days
    /// </summary>
    public int RetentionDays { get; set; } = 30;

    /// <summary>
    /// Get the data directory following XDG specification with fallbacks.
    /// Priority:
    /// 1. XDG_DATA_HOME (Linux)
    /// 2. LocalApplicationData (Windows/macOS)
    /// 3. Current directory (final fallback)
    /// </summary>
    public string GetDataDirectory()
    {
        // Try XDG_DATA_HOME first (Linux)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome) && CanWriteToDirectory(xdgDataHome))
        {
            return Path.Combine(xdgDataHome, ApplicationName);
        }

        // Try platform-specific app data
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData) && CanWriteToDirectory(localAppData))
        {
            return Path.Combine(localAppData, ApplicationName);
        }

        // Try ~/.local/share (Linux fallback)
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            var localShare = Path.Combine(homeDir, ".local", "share");
            if (CanWriteToDirectory(localShare) || CanWriteToDirectory(homeDir))
            {
                return Path.Combine(localShare, ApplicationName);
            }
        }

        // Final fallback: current directory with timestamp subfolder
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss", CultureInfo.InvariantCulture);
        return Path.Combine(Environment.CurrentDirectory, $"{ApplicationName}_{timestamp}");
    }

    private static bool CanWriteToDirectory(string path)
    {
        try
        {
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }

            // Test write access
            var testFile = Path.Combine(path, $".write_test_{Guid.NewGuid()}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
SIZE: 0.92 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    Core library containing:
    - Domain models (PingResult, NetworkStatus, etc.)
    - Service interfaces and implementations
    - Storage abstractions and implementations (File, SQLite)
    - OpenTelemetry exporters
    
    This project has no UI dependencies and can be tested in isolation.
  -->
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Options" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
    <PackageReference Include="Microsoft.Data.Sqlite" />
    <!-- OpenTelemetry packages -->
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
SIZE: 2.82 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NetworkMonitor.Core.Exporters;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Core.Storage;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NetworkMonitor.Core;

/// <summary>
/// Extension methods for registering Network Monitor services.
/// Encapsulates all the DI wiring in one place.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers all Network Monitor services with the DI container.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configuration">The configuration.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddNetworkMonitor(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        ArgumentNullException.ThrowIfNull(services);
        ArgumentNullException.ThrowIfNull(configuration);

        // Bind options from configuration
        services.Configure<MonitorOptions>(
            configuration.GetSection(MonitorOptions.SectionName));
        services.Configure<StorageOptions>(
            configuration.GetSection(StorageOptions.SectionName));

        // Register services
        services.AddSingleton<IPingService, PingService>();
        services.AddSingleton<INetworkMonitorService, NetworkMonitorService>();
        services.AddSingleton<IStatusDisplay, ConsoleStatusDisplay>();
        services.AddSingleton<IStorageService, SqliteStorageService>();

        // Register background service
        services.AddHostedService<MonitorBackgroundService>();

        return services;
    }

    /// <summary>
    /// Adds OpenTelemetry metrics with file and console export.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="fileOptions">Optional file exporter options.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddNetworkMonitorTelemetry(
        this IServiceCollection services,
        FileExporterOptions? fileOptions = null)
    {
        ArgumentNullException.ThrowIfNull(services);

        fileOptions ??= FileExporterOptions.Default;

        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource
                .AddService(
                    serviceName: "NetworkMonitor",
                    serviceVersion: "1.0.0"))
            .WithMetrics(metrics =>
            {
                metrics
                    .AddMeter("NetworkMonitor.Core")
                    .AddRuntimeInstrumentation()
                    .AddConsoleExporter()
                    .AddFileExporter(fileOptions);
            });

        return services;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
SIZE: 2.28 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Console-based status display with ANSI colors.
/// Provides "at a glance" network status visualization.
/// </summary>
public sealed class ConsoleStatusDisplay : IStatusDisplay
{
    private readonly Lock _lock = new();

    // ANSI color codes
    private const string Reset = "\x1b[0m";
    private const string Bold = "\x1b[1m";
    private const string Green = "\x1b[32m";
    private const string Yellow = "\x1b[33m";
    private const string Red = "\x1b[31m";
    private const string Cyan = "\x1b[36m";
    private const string Magenta = "\x1b[35m";

    /// <inheritdoc />
    public void UpdateStatus(NetworkStatus status)
    {
        ArgumentNullException.ThrowIfNull(status);

        lock (_lock)
        {
            var (color, symbol) = status.Health switch
            {
                NetworkHealth.Excellent => (Green, "‚óè"),
                NetworkHealth.Good => (Green, "‚óã"),
                NetworkHealth.Degraded => (Yellow, "‚óê"),
                NetworkHealth.Poor => (Red, "‚óë"),
                NetworkHealth.Offline => (Red, "‚óã"),
                _ => (Reset, "?")
            };

            Console.Write($"\r{color}{Bold}{symbol} {status.Health,-10}{Reset} ");
            Console.Write($"{Cyan}Router:{Reset} ");

            if (status.RouterResult?.Success == true)
            {
                Console.Write($"{Green}{status.RouterResult.RoundtripTimeMs,4}ms{Reset} ");
            }
            else
            {
                Console.Write($"{Red}FAIL{Reset}   ");
            }

            Console.Write($"{Cyan}Internet:{Reset} ");

            if (status.InternetResult?.Success == true)
            {
                Console.Write($"{Green}{status.InternetResult.RoundtripTimeMs,4}ms{Reset} ");
            }
            else
            {
                Console.Write($"{Red}FAIL{Reset}   ");
            }

            Console.Write($"{Magenta}[{status.Timestamp:HH:mm:ss}]{Reset}");

            // Pad to clear any previous longer text
            Console.Write("          ");
        }
    }

    /// <inheritdoc />
    public void Clear()
    {
        lock (_lock)
        {
            Console.Write("\r" + new string(' ', Console.WindowWidth - 1) + "\r");
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
SIZE: 0.69 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main service for monitoring network health.
/// Orchestrates ping operations and computes overall status.
/// </summary>
public interface INetworkMonitorService
{
    /// <summary>
    /// Performs a single network health check.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Current network status.</returns>
    Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Event raised when network status changes.
    /// </summary>
    event EventHandler<NetworkStatusEventArgs>? StatusChanged;
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/IPingService.cs
SIZE: 1.31 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Abstraction for ping operations.
/// Allows for easy testing with fake implementations.
/// </summary>
public interface IPingService
{
    /// <summary>
    /// Sends a single ICMP ping to the specified target.
    /// </summary>
    /// <param name="target">Hostname or IP address</param>
    /// <param name="timeoutMs">Timeout in milliseconds</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Result of the ping operation</returns>
    Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Sends multiple pings and returns all results.
    /// Useful for calculating statistics like packet loss.
    /// </summary>
    /// <param name="target">Hostname or IP address</param>
    /// <param name="count">Number of pings to send</param>
    /// <param name="timeoutMs">Timeout per ping in milliseconds</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All ping results</returns>
    Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/IStatusDisplay.cs
SIZE: 0.54 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Abstraction for displaying network status.
/// Allows for different display implementations (console, GUI, etc.).
/// </summary>
public interface IStatusDisplay
{
    /// <summary>
    /// Updates the display with the current network status.
    /// </summary>
    /// <param name="status">Current status to display</param>
    void UpdateStatus(NetworkStatus status);

    /// <summary>
    /// Clears the display.
    /// </summary>
    void Clear();
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
SIZE: 3.33 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Storage;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Background service that runs the continuous monitoring loop.
/// Implements IHostedService for proper lifecycle management.
/// </summary>
public sealed class MonitorBackgroundService : BackgroundService
{
    private readonly INetworkMonitorService _monitorService;
    private readonly IStatusDisplay _display;
    private readonly IStorageService _storage;
    private readonly MonitorOptions _options;
    private readonly ILogger<MonitorBackgroundService> _logger;

    /// <summary>
    /// Creates a new monitor background service.
    /// </summary>
    public MonitorBackgroundService(
        INetworkMonitorService monitorService,
        IStatusDisplay display,
        IStorageService storage,
        IOptions<MonitorOptions> options,
        ILogger<MonitorBackgroundService> logger)
    {
        _monitorService = monitorService;
        _display = display;
        _storage = storage;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation(
            "Network Monitor starting. Interval: {IntervalMs}ms, Router: {Router}, Internet: {Internet}",
            _options.IntervalMs,
            _options.RouterAddress,
            _options.InternetTarget);

        // Subscribe to status changes for logging significant events
        _monitorService.StatusChanged += OnStatusChanged;

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var status = await _monitorService.CheckNetworkAsync(stoppingToken);

                    // Update display
                    _display.UpdateStatus(status);

                    // Persist results
                    await _storage.SaveStatusAsync(status, stoppingToken);

                    // Wait for next cycle
                    await Task.Delay(_options.IntervalMs, stoppingToken);
                }
                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
                {
                    // Normal shutdown
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error during monitoring cycle");

                    // Continue monitoring even if one cycle fails
                    await Task.Delay(_options.IntervalMs, stoppingToken);
                }
            }
        }
        finally
        {
            _monitorService.StatusChanged -= OnStatusChanged;
            _display.Clear();
        }

        _logger.LogInformation("Network Monitor stopped");
    }

    private void OnStatusChanged(object? sender, NetworkStatusEventArgs e)
    {
        // Log significant status changes
        if (e.Status.Health == NetworkHealth.Offline)
        {
            _logger.LogWarning("Network is OFFLINE: {Message}", e.Status.Message);
        }
        else if (e.Status.Health == NetworkHealth.Poor)
        {
            _logger.LogWarning("Network is POOR: {Message}", e.Status.Message);
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
SIZE: 7.38 KB
MODIFIED: 2025-12-26 07:53:31
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        // Check cancellation immediately before doing any work
        cancellationToken.ThrowIfCancellationRequested();

        using var activity = ActivitySource.StartActivity("NetworkMonitor.CheckNetwork");

        CheckCounter.Add(1);

        _logger.LogDebug("Starting network health check");

        // Ping router and internet in parallel for efficiency
        var routerTask = PingWithStatsAsync(
            _options.RouterAddress,
            "router",
            cancellationToken);

        var internetTask = PingWithStatsAsync(
            _options.InternetTarget,
            "internet",
            cancellationToken);

        await Task.WhenAll(routerTask, internetTask).ConfigureAwait(false);

        var routerResult = await routerTask.ConfigureAwait(false);
        var internetResult = await internetTask.ConfigureAwait(false);

        // Record metrics
        if (routerResult is { Success: true, RoundtripTimeMs: not null })
        {
            RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
        }

        if (internetResult is { Success: true, RoundtripTimeMs: not null })
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());
        activity?.SetTag("router.success", routerResult?.Success ?? false);
        activity?.SetTag("internet.success", internetResult?.Success ?? false);

        // Fire event if status changed
        if (_lastStatus?.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status));
        }

        _lastStatus = status;

        return status;
    }

    private async Task<PingResult?> PingWithStatsAsync(
        string target,
        string targetType,
        CancellationToken cancellationToken)
    {
        try
        {
            var results = await _pingService.PingMultipleAsync(
                target,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken).ConfigureAwait(false);

            if (results.Count == 0)
            {
                return null;
            }

            // Calculate aggregate result
            var successfulPings = results.Where(r => r.Success).ToList();

            if (successfulPings.Count == 0)
            {
                // All pings failed - return the last failure
                return results[^1];
            }

            // Return a result with median latency for stability
            var sortedLatencies = successfulPings
                .Where(r => r.RoundtripTimeMs.HasValue)
                .Select(r => r.RoundtripTimeMs!.Value)
                .OrderBy(l => l)
                .ToList();

            var medianLatency = sortedLatencies.Count > 0
                ? sortedLatencies[sortedLatencies.Count / 2]
                : 0;

            return PingResult.Succeeded(target, medianLatency);
        }
        catch (OperationCanceledException)
        {
            // Let cancellation propagate up
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error pinging {Target}", target);
            return PingResult.Failed(target, ex.Message);
        }
    }

    private static (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult? internetResult)
    {
        // Router failure = offline (can't reach local network)
        if (routerResult is null || !routerResult.Success)
        {
            return (NetworkHealth.Offline, "Cannot reach local network");
        }

        // Internet failure = poor (local network OK, but no internet)
        if (internetResult is null || !internetResult.Success)
        {
            return (NetworkHealth.Poor, "Local network OK, no internet access");
        }

        // Both succeed - check latency for quality assessment
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult.RoundtripTimeMs ?? 0;

        return internetLatency switch
        {
            <= 50 when routerLatency <= 10 => (NetworkHealth.Excellent, "Network is excellent"),
            <= 100 => (NetworkHealth.Good, "Network is good"),
            <= 200 => (NetworkHealth.Degraded, "Network is degraded (high latency)"),
            _ => (NetworkHealth.Poor, "Network is poor (very high latency)")
        };
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/PingService.cs
SIZE: 3.34 KB
MODIFIED: 2025-12-26 07:53:31
================================================================================

using System.Diagnostics;
using System.Net.NetworkInformation;
using Microsoft.Extensions.Logging;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform ping implementation using System.Net.NetworkInformation.
/// Works on Windows, macOS, and Linux without external dependencies.
/// </summary>
public sealed class PingService : IPingService
{
    private readonly ILogger<PingService> _logger;

    public PingService(ILogger<PingService> logger)
    {
        _logger = logger;
    }

    public async Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        // Check cancellation before doing any work
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            _logger.LogDebug("Pinging {Target} with timeout {TimeoutMs}ms", target, timeoutMs);

            // Create a new Ping instance per call to allow concurrent pings.
            // The Ping class does not support multiple concurrent async operations
            // on the same instance.
            using var ping = new Ping();

            var stopwatch = Stopwatch.StartNew();

            // Note: PingAsync doesn't accept CancellationToken directly,
            // but we can use the timeout parameter
            var reply = await ping.SendPingAsync(target, timeoutMs).ConfigureAwait(false);

            stopwatch.Stop();

            // Check cancellation after the ping completes
            cancellationToken.ThrowIfCancellationRequested();

            if (reply.Status == IPStatus.Success)
            {
                _logger.LogDebug(
                    "Ping to {Target} succeeded: {RoundtripMs}ms",
                    target,
                    reply.RoundtripTime);

                return PingResult.Succeeded(target, reply.RoundtripTime);
            }

            var errorMessage = reply.Status.ToString();
            _logger.LogDebug("Ping to {Target} failed: {Status}", target, errorMessage);

            return PingResult.Failed(target, errorMessage);
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug("Ping to {Target} cancelled", target);
            throw;
        }
        catch (PingException ex)
        {
            _logger.LogWarning(ex, "Ping to {Target} threw exception", target);
            return PingResult.Failed(target, ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error pinging {Target}", target);
            return PingResult.Failed(target, $"Unexpected error: {ex.Message}");
        }
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var result = await PingAsync(target, timeoutMs, cancellationToken).ConfigureAwait(false);
            results.Add(result);

            // Small delay between pings to avoid flooding
            if (i < count - 1)
            {
                await Task.Delay(50, cancellationToken).ConfigureAwait(false);
            }
        }

        return results;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Storage/IStorageService.cs
SIZE: 1.44 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Storage;

/// <summary>
/// Abstraction for persisting network status data.
/// Implementations may write to files, SQLite, or both.
/// </summary>
public interface IStorageService
{
    /// <summary>
    /// Persists a network status snapshot.
    /// </summary>
    /// <param name="status">The status to save.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task SaveStatusAsync(NetworkStatus status, CancellationToken cancellationToken = default);

    /// <summary>
    /// Retrieves historical data for trendline display.
    /// </summary>
    /// <param name="from">Start of time range.</param>
    /// <param name="to">End of time range.</param>
    /// <param name="granularity">Time granularity for aggregation.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<IReadOnlyList<HistoricalData>> GetHistoricalDataAsync(
        DateTimeOffset from,
        DateTimeOffset to,
        TimeGranularity granularity,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets recent raw ping results for detailed analysis.
    /// </summary>
    /// <param name="count">Number of results to retrieve.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<IReadOnlyList<PingResult>> GetRecentPingsAsync(
        int count,
        CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
SIZE: 12.16 KB
MODIFIED: 2025-12-26 07:36:03
================================================================================

using System.Globalization;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Storage;

/// <summary>
/// SQLite-based storage for network monitoring data.
/// Provides durable storage with efficient querying for trendlines.
/// 
/// Schema is automatically created/migrated on startup.
/// Old data is automatically pruned based on retention settings.
/// </summary>
public sealed class SqliteStorageService : IStorageService, IAsyncDisposable
{
    private readonly StorageOptions _options;
    private readonly ILogger<SqliteStorageService> _logger;
    private readonly string _connectionString;
    private bool _initialized;
    private readonly SemaphoreSlim _initLock = new(1, 1);

    /// <summary>
    /// Creates a new SQLite storage service.
    /// </summary>
    public SqliteStorageService(
        IOptions<StorageOptions> options,
        ILogger<SqliteStorageService> logger)
    {
        _options = options.Value;
        _logger = logger;

        var dataDir = _options.GetDataDirectory();
        Directory.CreateDirectory(dataDir);

        var dbPath = Path.Combine(dataDir, "network-monitor.db");
        _connectionString = $"Data Source={dbPath}";

        _logger.LogInformation("SQLite database path: {DbPath}", dbPath);
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (_initialized) return;

        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized) return;

            await using var connection = new SqliteConnection(_connectionString);
            await connection.OpenAsync(cancellationToken);

            // Create tables
            const string createTablesSql = """
                CREATE TABLE IF NOT EXISTS ping_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target TEXT NOT NULL,
                    success INTEGER NOT NULL,
                    roundtrip_ms INTEGER,
                    timestamp TEXT NOT NULL,
                    error_message TEXT,
                    target_type TEXT NOT NULL
                );
                
                CREATE INDEX IF NOT EXISTS idx_ping_results_timestamp 
                ON ping_results(timestamp DESC);
                
                CREATE INDEX IF NOT EXISTS idx_ping_results_target_type 
                ON ping_results(target_type, timestamp DESC);
                
                CREATE TABLE IF NOT EXISTS network_status (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    health TEXT NOT NULL,
                    message TEXT NOT NULL,
                    timestamp TEXT NOT NULL,
                    router_latency_ms INTEGER,
                    internet_latency_ms INTEGER
                );
                
                CREATE INDEX IF NOT EXISTS idx_network_status_timestamp 
                ON network_status(timestamp DESC);
                """;

            await using var command = connection.CreateCommand();
            command.CommandText = createTablesSql;
            await command.ExecuteNonQueryAsync(cancellationToken);

            _logger.LogDebug("Database schema initialized");
            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task SaveStatusAsync(NetworkStatus status, CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(status);

        try
        {
            await EnsureInitializedAsync(cancellationToken);

            await using var connection = new SqliteConnection(_connectionString);
            await connection.OpenAsync(cancellationToken);

            // Save status
            await using var statusCommand = connection.CreateCommand();
            statusCommand.CommandText = """
                INSERT INTO network_status (health, message, timestamp, router_latency_ms, internet_latency_ms)
                VALUES (@health, @message, @timestamp, @routerLatency, @internetLatency)
                """;

            statusCommand.Parameters.AddWithValue("@health", status.Health.ToString());
            statusCommand.Parameters.AddWithValue("@message", status.Message);
            statusCommand.Parameters.AddWithValue("@timestamp", status.Timestamp.ToString("O", CultureInfo.InvariantCulture));
            statusCommand.Parameters.AddWithValue("@routerLatency",
                (object?)status.RouterResult?.RoundtripTimeMs ?? DBNull.Value);
            statusCommand.Parameters.AddWithValue("@internetLatency",
                (object?)status.InternetResult?.RoundtripTimeMs ?? DBNull.Value);

            await statusCommand.ExecuteNonQueryAsync(cancellationToken);

            // Save individual ping results
            if (status.RouterResult != null)
            {
                await SavePingResultAsync(connection, status.RouterResult, "router", cancellationToken);
            }

            if (status.InternetResult != null)
            {
                await SavePingResultAsync(connection, status.InternetResult, "internet", cancellationToken);
            }

            // Periodically prune old data (roughly every 100 saves)
            if (Random.Shared.Next(100) == 0)
            {
                await PruneOldDataAsync(connection, cancellationToken);
            }
        }
        catch (Exception ex)
        {
            // Log but don't throw - storage failures shouldn't stop monitoring
            _logger.LogWarning(ex, "Failed to save status to SQLite");
        }
    }

    private static async Task SavePingResultAsync(
        SqliteConnection connection,
        PingResult result,
        string targetType,
        CancellationToken cancellationToken)
    {
        await using var command = connection.CreateCommand();
        command.CommandText = """
            INSERT INTO ping_results (target, success, roundtrip_ms, timestamp, error_message, target_type)
            VALUES (@target, @success, @roundtripMs, @timestamp, @errorMessage, @targetType)
            """;

        command.Parameters.AddWithValue("@target", result.Target);
        command.Parameters.AddWithValue("@success", result.Success ? 1 : 0);
        command.Parameters.AddWithValue("@roundtripMs", (object?)result.RoundtripTimeMs ?? DBNull.Value);
        command.Parameters.AddWithValue("@timestamp", result.Timestamp.ToString("O", CultureInfo.InvariantCulture));
        command.Parameters.AddWithValue("@errorMessage", (object?)result.ErrorMessage ?? DBNull.Value);
        command.Parameters.AddWithValue("@targetType", targetType);

        await command.ExecuteNonQueryAsync(cancellationToken);
    }

    private async Task PruneOldDataAsync(SqliteConnection connection, CancellationToken cancellationToken)
    {
        var cutoff = DateTimeOffset.UtcNow.AddDays(-_options.RetentionDays).ToString("O", CultureInfo.InvariantCulture);

        await using var command = connection.CreateCommand();
        command.CommandText = """
            DELETE FROM ping_results WHERE timestamp < @cutoff;
            DELETE FROM network_status WHERE timestamp < @cutoff;
            """;
        command.Parameters.AddWithValue("@cutoff", cutoff);

        var deleted = await command.ExecuteNonQueryAsync(cancellationToken);

        if (deleted > 0)
        {
            _logger.LogDebug("Pruned {Count} old records", deleted);
        }
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<HistoricalData>> GetHistoricalDataAsync(
        DateTimeOffset from,
        DateTimeOffset to,
        TimeGranularity granularity,
        CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);

        await using var connection = new SqliteConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = """
            SELECT roundtrip_ms, timestamp, success, target_type
            FROM ping_results
            WHERE timestamp >= @from AND timestamp <= @to
            ORDER BY timestamp
            """;

        command.Parameters.AddWithValue("@from", from.ToString("O", CultureInfo.InvariantCulture));
        command.Parameters.AddWithValue("@to", to.ToString("O", CultureInfo.InvariantCulture));

        var results = new List<(long? LatencyMs, DateTimeOffset Timestamp, bool Success)>();

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        while (await reader.ReadAsync(cancellationToken))
        {
            var latencyMs = reader.IsDBNull(0) ? (long?)null : reader.GetInt64(0);
            var timestamp = DateTimeOffset.Parse(reader.GetString(1), CultureInfo.InvariantCulture);
            var success = reader.GetInt32(2) == 1;

            results.Add((latencyMs, timestamp, success));
        }

        return AggregateByGranularity(results, granularity);
    }

    private static List<HistoricalData> AggregateByGranularity(
        List<(long? LatencyMs, DateTimeOffset Timestamp, bool Success)> results,
        TimeGranularity granularity)
    {
        if (results.Count == 0)
        {
            return [];
        }

        var grouped = results.GroupBy(r => TruncateToPeriod(r.Timestamp, granularity));

        return grouped.Select(g =>
        {
            var successfulPings = g.Where(p => p.Success && p.LatencyMs.HasValue).ToList();
            var latencies = successfulPings.Select(p => p.LatencyMs!.Value).ToList();

            return new HistoricalData(
                Period: g.Key,
                AverageLatencyMs: latencies.Count > 0 ? latencies.Average() : 0,
                MinLatencyMs: latencies.Count > 0 ? latencies.Min() : 0,
                MaxLatencyMs: latencies.Count > 0 ? latencies.Max() : 0,
                PacketLossPercent: g.Any() ?
                    (double)(g.Count() - successfulPings.Count) / g.Count() * 100 : 0,
                SampleCount: g.Count());
        }).OrderBy(h => h.Period).ToList();
    }

    private static DateTimeOffset TruncateToPeriod(DateTimeOffset timestamp, TimeGranularity granularity)
    {
        return granularity switch
        {
            TimeGranularity.Minute => new DateTimeOffset(
                timestamp.Year, timestamp.Month, timestamp.Day,
                timestamp.Hour, timestamp.Minute, 0, timestamp.Offset),
            TimeGranularity.Hour => new DateTimeOffset(
                timestamp.Year, timestamp.Month, timestamp.Day,
                timestamp.Hour, 0, 0, timestamp.Offset),
            TimeGranularity.Day => new DateTimeOffset(
                timestamp.Year, timestamp.Month, timestamp.Day,
                0, 0, 0, timestamp.Offset),
            _ => timestamp
        };
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PingResult>> GetRecentPingsAsync(
        int count,
        CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);

        await using var connection = new SqliteConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = """
            SELECT target, success, roundtrip_ms, timestamp, error_message
            FROM ping_results
            ORDER BY timestamp DESC
            LIMIT @count
            """;
        command.Parameters.AddWithValue("@count", count);

        var results = new List<PingResult>();

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        while (await reader.ReadAsync(cancellationToken))
        {
            results.Add(new PingResult(
                Target: reader.GetString(0),
                Success: reader.GetInt32(1) == 1,
                RoundtripTimeMs: reader.IsDBNull(2) ? null : reader.GetInt64(2),
                Timestamp: DateTimeOffset.Parse(reader.GetString(3), CultureInfo.InvariantCulture),
                ErrorMessage: reader.IsDBNull(4) ? null : reader.GetString(4)));
        }

        return results;
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        _initLock.Dispose();
        await Task.CompletedTask;
    }
}


================================================================================
FILE: src/NetworkMonitor.slnx
SIZE: 0.23 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

<Solution>
  <Project Path="NetworkMonitor.Core/NetworkMonitor.Core.csproj" />
  <Project Path="NetworkMonitor.Console/NetworkMonitor.Console.csproj" />
  <Project Path="NetworkMonitor.Tests/NetworkMonitor.Tests.csproj" />
</Solution>


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakePingService.cs
SIZE: 2.73 KB
MODIFIED: 2025-12-26 07:53:31
================================================================================

using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake ping service for testing.
/// Allows tests to control exactly what ping results are returned.
/// 
/// Using manual fakes instead of Moq because:
/// 1. Moq is banned (controversial maintainer)
/// 2. Manual fakes are more explicit and readable
/// 3. No magic - you can see exactly what happens
/// </summary>
internal sealed class FakePingService : IPingService
{
    private readonly Queue<PingResult> _results = new();
    private PingResult? _defaultResult;

    /// <summary>
    /// Queues a specific result to be returned on next ping.
    /// Results are returned in FIFO order.
    /// </summary>
    public FakePingService QueueResult(PingResult result)
    {
        _results.Enqueue(result);
        return this;
    }

    /// <summary>
    /// Sets a default result to return when queue is empty.
    /// </summary>
    public FakePingService WithDefaultResult(PingResult result)
    {
        _defaultResult = result;
        return this;
    }

    /// <summary>
    /// Configures to return successful pings with specified latency.
    /// </summary>
    public FakePingService AlwaysSucceed(long latencyMs = 10)
    {
        _defaultResult = PingResult.Succeeded("test", latencyMs);
        return this;
    }

    /// <summary>
    /// Configures to always fail.
    /// </summary>
    public FakePingService AlwaysFail(string errorMessage = "Simulated failure")
    {
        _defaultResult = PingResult.Failed("test", errorMessage);
        return this;
    }

    /// <inheritdoc />
    public Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        // Respect cancellation like the real service does
        cancellationToken.ThrowIfCancellationRequested();

        if (_results.TryDequeue(out var queuedResult))
        {
            return Task.FromResult(queuedResult);
        }

        if (_defaultResult is not null)
        {
            return Task.FromResult(_defaultResult);
        }

        return Task.FromResult(PingResult.Failed(target, "No result configured"));
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var result = await PingAsync(target, timeoutMs, cancellationToken).ConfigureAwait(false);
            results.Add(result);
        }

        return results;
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
SIZE: 1.74 KB
MODIFIED: 2025-12-26 07:23:02
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Tests for the FakePingService itself.
/// Ensures our test doubles work correctly.
/// </summary>
public sealed class FakePingServiceTests
{
    [Fact]
    public async Task AlwaysSucceed_ReturnsSuccessfulPings()
    {
        // Arrange
        var fake = new FakePingService().AlwaysSucceed(25);

        // Act
        var result = await fake.PingAsync("test", 1000, TestContext.Current.CancellationToken);

        // Assert
        Assert.True(result.Success);
        Assert.Equal(25, result.RoundtripTimeMs);
    }

    [Fact]
    public async Task QueuedResults_ReturnedInOrder()
    {
        // Arrange
        var fake = new FakePingService()
            .QueueResult(PingResult.Succeeded("", 10))
            .QueueResult(PingResult.Succeeded("", 20))
            .QueueResult(PingResult.Failed("", "error"));

        // Act
        var r1 = await fake.PingAsync("target", 1000, TestContext.Current.CancellationToken);
        var r2 = await fake.PingAsync("target", 1000, TestContext.Current.CancellationToken);
        var r3 = await fake.PingAsync("target", 1000, TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(10, r1.RoundtripTimeMs);
        Assert.Equal(20, r2.RoundtripTimeMs);
        Assert.False(r3.Success);
    }

    [Fact]
    public async Task PingMultipleAsync_ReturnsRequestedCount()
    {
        // Arrange
        var fake = new FakePingService().AlwaysSucceed();

        // Act
        var results = await fake.PingMultipleAsync("test", 5, 1000, TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(5, results.Count);
        Assert.All(results, r => Assert.True(r.Success));
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
SIZE: 1.61 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Storage;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// In-memory storage for testing.
/// Stores data in memory without any I/O.
/// </summary>
internal sealed class FakeStorageService : IStorageService
{
    private readonly List<NetworkStatus> _statuses = new();
    private readonly List<PingResult> _pings = new();

    public IReadOnlyList<NetworkStatus> SavedStatuses => _statuses;
    public IReadOnlyList<PingResult> SavedPings => _pings;

    public Task SaveStatusAsync(NetworkStatus status, CancellationToken cancellationToken = default)
    {
        _statuses.Add(status);

        if (status.RouterResult != null)
        {
            _pings.Add(status.RouterResult);
        }

        if (status.InternetResult != null)
        {
            _pings.Add(status.InternetResult);
        }

        return Task.CompletedTask;
    }

    public Task<IReadOnlyList<HistoricalData>> GetHistoricalDataAsync(
        DateTimeOffset from,
        DateTimeOffset to,
        TimeGranularity granularity,
        CancellationToken cancellationToken = default)
    {
        // Simple implementation for testing
        return Task.FromResult<IReadOnlyList<HistoricalData>>(Array.Empty<HistoricalData>());
    }

    public Task<IReadOnlyList<PingResult>> GetRecentPingsAsync(
        int count,
        CancellationToken cancellationToken = default)
    {
        return Task.FromResult<IReadOnlyList<PingResult>>(
            _pings.TakeLast(count).Reverse().ToList());
    }

    public void Clear()
    {
        _statuses.Clear();
        _pings.Clear();
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/NullLogger.cs
SIZE: 0.68 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Logger that discards all log messages.
/// Useful for tests where we don't care about logging output.
/// </summary>
internal sealed class NullLogger<T> : ILogger<T>
{
    public static readonly NullLogger<T> Instance = new();

    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => null;

    public bool IsEnabled(LogLevel logLevel) => false;

    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        // Intentionally empty
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
SIZE: 0.95 KB
MODIFIED: 2025-12-26 07:45:26
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    Unit tests using xUnit 3.
    
    Testing approach:
    - Use manual fakes/stubs instead of mocking frameworks (Moq is banned)
    - Focus on behavior, not implementation details
    - Each test class tests one component in isolation
    - Integration tests can test multiple components together
  -->
  <PropertyGroup>
    <!-- 
      CA1707: Identifiers should not contain underscores
      Disabled because test methods commonly use Method_Scenario_Expected naming.
    -->
    <NoWarn>$(NoWarn);CA1707</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="xunit.v3" />
    <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\NetworkMonitor.Core\NetworkMonitor.Core.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Tests/NetworkStatusTests.cs
SIZE: 0.83 KB
MODIFIED: 2025-12-26 07:23:02
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests;

/// <summary>
/// Tests for NetworkStatus model.
/// </summary>
public sealed class NetworkStatusTests
{
    [Theory]
    [InlineData(NetworkHealth.Excellent, true)]
    [InlineData(NetworkHealth.Good, true)]
    [InlineData(NetworkHealth.Degraded, true)]
    [InlineData(NetworkHealth.Poor, false)]
    [InlineData(NetworkHealth.Offline, false)]
    public void IsUsable_ReturnsCorrectValue(NetworkHealth health, bool expectedUsable)
    {
        // Arrange
        var status = new NetworkStatus(
            health,
            PingResult.Succeeded("router", 10),
            PingResult.Succeeded("internet", 20),
            DateTimeOffset.UtcNow,
            "Test message");

        // Act & Assert
        Assert.Equal(expectedUsable, status.IsUsable);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/PingResultTests.cs
SIZE: 1.19 KB
MODIFIED: 2025-12-26 07:23:02
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests;

/// <summary>
/// Tests for PingResult model.
/// </summary>
public sealed class PingResultTests
{
    [Fact]
    public void Succeeded_CreatesSuccessfulResult()
    {
        // Arrange & Act
        var result = PingResult.Succeeded("192.168.1.1", 42);

        // Assert
        Assert.True(result.Success);
        Assert.Equal("192.168.1.1", result.Target);
        Assert.Equal(42, result.RoundtripTimeMs);
        Assert.Null(result.ErrorMessage);
    }

    [Fact]
    public void Failed_CreatesFailedResult()
    {
        // Arrange & Act
        var result = PingResult.Failed("8.8.8.8", "Timeout");

        // Assert
        Assert.False(result.Success);
        Assert.Equal("8.8.8.8", result.Target);
        Assert.Null(result.RoundtripTimeMs);
        Assert.Equal("Timeout", result.ErrorMessage);
    }

    [Fact]
    public void Timestamp_IsSetToUtcNow()
    {
        // Arrange
        var before = DateTimeOffset.UtcNow;

        // Act
        var result = PingResult.Succeeded("test", 10);

        // Assert
        var after = DateTimeOffset.UtcNow;
        Assert.InRange(result.Timestamp, before, after);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs
SIZE: 4.03 KB
MODIFIED: 2025-12-26 08:00:20
================================================================================

using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellent()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Excellent, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("No route to host");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
        Assert.Contains("local network", status.Message, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoor()
    {
        // Arrange - Router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("router", 10))
            .QueueResult(PingResult.Succeeded("router", 10))
            .QueueResult(PingResult.Succeeded("router", 10))
            .QueueResult(PingResult.Failed("internet", "Timeout"))
            .QueueResult(PingResult.Failed("internet", "Timeout"))
            .QueueResult(PingResult.Failed("internet", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.False(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegraded()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("router", 10))
            .QueueResult(PingResult.Succeeded("router", 10))
            .QueueResult(PingResult.Succeeded("router", 10))
            .QueueResult(PingResult.Succeeded("internet", 150))
            .QueueResult(PingResult.Succeeded("internet", 150))
            .QueueResult(PingResult.Succeeded("internet", 150));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Degraded, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? receivedArgs = null;
        _service.StatusChanged += (_, e) => receivedArgs = e;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedArgs);
        Assert.Equal(NetworkHealth.Excellent, receivedArgs.Status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }
}


===============================================================================
EXPORT COMPLETED: Fri Dec 26 08:45:15 AM CST 2025
Total Files Exported: 36
Output File: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
===============================================================================
