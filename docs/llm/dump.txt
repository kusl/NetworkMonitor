===============================================================================
PROJECT EXPORT
Generated: Fri Dec 26 12:44:39 PM CST 2025
Project Path: /home/kushal/src/dotnet/network-monitor
===============================================================================

DIRECTORY STRUCTURE:
===================

/home/kushal/src/dotnet/network-monitor
‚îú‚îÄ‚îÄ export.sh
‚îú‚îÄ‚îÄ .github
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ workflows
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ build-and-test.yml
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ release.yml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ Directory.Build.props
    ‚îú‚îÄ‚îÄ Directory.Packages.props
    ‚îú‚îÄ‚îÄ generate-network-monitor.sh
    ‚îú‚îÄ‚îÄ .gitignore
    ‚îú‚îÄ‚îÄ NetworkMonitor.Console
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ appsettings.json
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitor.Console.csproj
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Program.cs
    ‚îú‚îÄ‚îÄ NetworkMonitor.Core
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Exporters
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FileExporterExtensions.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FileExporterOptions.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ FileMetricExporter.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Models
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HistoricalData.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MonitorOptions.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatus.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatusEventArgs.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PingResult.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ StorageOptions.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitor.Core.csproj
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ServiceCollectionExtensions.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Services
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ConsoleStatusDisplay.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GatewayDetector.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IGatewayDetector.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IInternetTargetProvider.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ INetworkConfigurationService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ INetworkMonitorService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ InternetTargetProvider.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IPingService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IStatusDisplay.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MonitorBackgroundService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkConfigurationService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitorService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ PingService.cs
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Storage
    ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ IStorageService.cs
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ SqliteStorageService.cs
    ‚îú‚îÄ‚îÄ NetworkMonitor.slnx
    ‚îú‚îÄ‚îÄ NetworkMonitor.Tests
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Fakes
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakeGatewayDetector.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakeInternetTargetProvider.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakeNetworkConfigurationService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakePingService.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FakePingServiceTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ FakeStorageService.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Models
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MonitorOptionsTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkHealthTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatusEventArgsTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ PingResultTests.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkMonitor.Tests.csproj
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkStatusTests.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PingResultTests.cs
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Services
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GatewayDetectorTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ InternetTargetProviderTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NetworkConfigurationServiceTests.cs
    ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ NetworkMonitorServiceTests.cs
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Storage
    ‚îî‚îÄ‚îÄ run.sh


FILE CONTENTS:
==============

================================================================================
FILE: .github/workflows/build-and-test.yml
SIZE: 1.34 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

# GitHub Actions Workflow: Build and Test
# Triggers on every push and pull request to any branch
# Builds and tests on all major platforms

name: Build and Test

on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'

permissions:
  contents: read

jobs:
  build-and-test:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'preview'

      - name: Display .NET info
        run: dotnet --info

      - name: Restore dependencies
        run: dotnet restore src/NetworkMonitor.slnx

      - name: Build solution
        run: dotnet build src/NetworkMonitor.slnx --configuration Release --no-restore

      - name: Run tests
        run: dotnet test src/NetworkMonitor.slnx --configuration Release --no-build --verbosity normal --logger "trx;LogFileName=test-results.trx"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: '**/test-results.trx'
          if-no-files-found: warn
          retention-days: 30


================================================================================
FILE: .github/workflows/release.yml
SIZE: 11.50 KB
MODIFIED: 2025-12-26 10:23:56
================================================================================

# GitHub Actions Workflow: Build and Create Release
# Triggers on every push to any branch
# Creates self-contained executables for all major desktop platforms
# Publishes a full GitHub release (never pre-release) with all binaries
#
# Supported platforms:
#   - Windows: x64, ARM64
#   - macOS: x64 (Intel), ARM64 (Apple Silicon)
#   - Linux: x64, ARM64
#
# Design Philosophy:
#   - Avoid high-level GitHub Actions abstractions where possible
#   - Use shell commands directly instead of specialized actions
#   - Only use actions/checkout, actions/upload-artifact, actions/download-artifact
#     (these are fundamental and have no simpler alternative)
#   - Use GitHub CLI (gh) for release creation instead of specialized release actions
#   - Install .NET manually using official install scripts

name: Build and Release

on:
  push:
    branches:
      - '**'  # All branches

permissions:
  contents: write  # Required to create releases and upload assets

env:
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  PROJECT_PATH: src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
  SOLUTION_PATH: src/NetworkMonitor.slnx

jobs:
  # ==========================================================================
  # Build binaries for each platform
  # Each platform builds on its native runner for best compatibility
  # ==========================================================================
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows x64
          - os: windows-latest
            rid: win-x64
            artifact-name: network-monitor-win-x64
            archive-type: zip
          # Windows ARM64 (cross-compile from x64)
          - os: windows-latest
            rid: win-arm64
            artifact-name: network-monitor-win-arm64
            archive-type: zip
          # macOS x64 (Intel) - uses macos-latest
          - os: macos-latest
            rid: osx-x64
            artifact-name: network-monitor-osx-x64
            archive-type: tar
          # macOS ARM64 (Apple Silicon) - uses macos-latest
          - os: macos-latest
            rid: osx-arm64
            artifact-name: network-monitor-osx-arm64
            archive-type: tar
          # Linux x64
          - os: ubuntu-latest
            rid: linux-x64
            artifact-name: network-monitor-linux-x64
            archive-type: tar
          # Linux ARM64 (cross-compile from x64)
          - os: ubuntu-latest
            rid: linux-arm64
            artifact-name: network-monitor-linux-arm64
            archive-type: tar

    runs-on: ${{ matrix.os }}

    steps:
      # Checkout - fundamental action, no simpler alternative exists
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install .NET manually using official Microsoft install scripts
      # This avoids the actions/setup-dotnet abstraction
      - name: Install .NET 10 (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh
          chmod +x dotnet-install.sh
          ./dotnet-install.sh --channel 10.0 --quality preview --install-dir "$HOME/.dotnet"
          echo "$HOME/.dotnet" >> $GITHUB_PATH
          echo "DOTNET_ROOT=$HOME/.dotnet" >> $GITHUB_ENV

      - name: Install .NET 10 (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri https://dot.net/v1/dotnet-install.ps1 -OutFile dotnet-install.ps1
          ./dotnet-install.ps1 -Channel 10.0 -Quality preview -InstallDir "$env:USERPROFILE\.dotnet"
          echo "$env:USERPROFILE\.dotnet" | Out-File -FilePath $env:GITHUB_PATH -Append
          echo "DOTNET_ROOT=$env:USERPROFILE\.dotnet" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Verify .NET installation
        shell: bash
        run: |
          dotnet --info

      - name: Restore dependencies
        shell: bash
        run: |
          dotnet restore ${{ env.SOLUTION_PATH }}

      - name: Publish self-contained binary
        shell: bash
        run: |
          dotnet publish ${{ env.PROJECT_PATH }} \
            --configuration Release \
            --runtime ${{ matrix.rid }} \
            --self-contained true \
            -p:PublishSingleFile=true \
            -p:PublishTrimmed=false \
            -p:IncludeNativeLibrariesForSelfExtract=true \
            -p:DebugType=None \
            -p:DebugSymbols=false \
            --output ./publish/${{ matrix.rid }}

      - name: List published files
        shell: bash
        run: |
          echo "Published files for ${{ matrix.rid }}:"
          ls -la ./publish/${{ matrix.rid }}/

      - name: Create tar.gz archive (Unix)
        if: matrix.archive-type == 'tar'
        shell: bash
        run: |
          cd publish
          tar -czvf ../${{ matrix.artifact-name }}.tar.gz ${{ matrix.rid }}
          cd ..
          echo "Created archive:"
          ls -la ${{ matrix.artifact-name }}.tar.gz

      - name: Create zip archive (Windows)
        if: matrix.archive-type == 'zip'
        shell: pwsh
        run: |
          Compress-Archive -Path "publish\${{ matrix.rid }}\*" -DestinationPath "${{ matrix.artifact-name }}.zip"
          Write-Host "Created archive:"
          Get-ChildItem "${{ matrix.artifact-name }}.zip"

      # Upload artifact - fundamental action for passing files between jobs
      # No simpler alternative exists in GitHub Actions
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: |
            ${{ matrix.artifact-name }}.tar.gz
            ${{ matrix.artifact-name }}.zip
          retention-days: 1
          if-no-files-found: error

  # ==========================================================================
  # Create GitHub Release with all binaries
  # Uses GitHub CLI (gh) instead of specialized release actions
  # ==========================================================================
  release:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50  # Get some history for release notes

      # Download artifacts - fundamental action for receiving files from other jobs
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p ./release-assets
          
          # Move all archives to a flat directory
          find ./artifacts -type f \( -name "*.zip" -o -name "*.tar.gz" \) -exec mv {} ./release-assets/ \;
          
          echo "=== Release Assets ==="
          ls -la ./release-assets/

      - name: Generate version string
        id: version
        shell: bash
        run: |
          # Version format: v1.0.YYYYMMDD.HHMMSS
          # This ensures unique, sortable versions for every push
          VERSION="v1.0.$(date -u +%Y%m%d.%H%M%S)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

      - name: Generate checksums
        shell: bash
        run: |
          cd ./release-assets
          sha256sum * > SHA256SUMS.txt
          echo "=== Checksums ==="
          cat SHA256SUMS.txt

      - name: Generate release notes
        shell: bash
        run: |
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          COMMIT_AUTHOR=$(git log -1 --pretty=format:"%an")
          COMMIT_DATE=$(git log -1 --pretty=format:"%ai")
          
          cat > release-notes.md << 'NOTES_EOF'
          ## Network Monitor Release
          
          **Branch:** `${{ github.ref_name }}`
          **Commit:** `${{ github.sha }}`
          **Author:** COMMIT_AUTHOR_PLACEHOLDER
          **Date:** COMMIT_DATE_PLACEHOLDER
          
          ### Commit Message
          COMMIT_MSG_PLACEHOLDER
          
          ---
          
          ### Downloads
          
          | Platform | Architecture | Filename |
          |----------|--------------|----------|
          | Windows | x64 | `network-monitor-win-x64.zip` |
          | Windows | ARM64 | `network-monitor-win-arm64.zip` |
          | macOS | x64 (Intel) | `network-monitor-osx-x64.tar.gz` |
          | macOS | ARM64 (Apple Silicon) | `network-monitor-osx-arm64.tar.gz` |
          | Linux | x64 | `network-monitor-linux-x64.tar.gz` |
          | Linux | ARM64 | `network-monitor-linux-arm64.tar.gz` |
          
          ### Installation
          
          **Windows:**
          ```powershell
          # Extract and run
          Expand-Archive network-monitor-win-x64.zip -DestinationPath .
          .\win-x64\NetworkMonitor.Console.exe
          ```
          
          **macOS / Linux:**
          ```bash
          # Extract and run
          tar -xzf network-monitor-linux-x64.tar.gz
          ./linux-x64/NetworkMonitor.Console
          ```
          
          ### SHA256 Checksums
          
          ```
          CHECKSUMS_PLACEHOLDER
          ```
          NOTES_EOF
          
          # Replace placeholders with actual values
          sed -i "s/COMMIT_AUTHOR_PLACEHOLDER/${COMMIT_AUTHOR}/" release-notes.md
          sed -i "s/COMMIT_DATE_PLACEHOLDER/${COMMIT_DATE}/" release-notes.md
          sed -i "s/COMMIT_MSG_PLACEHOLDER/${COMMIT_MSG}/" release-notes.md
          
          # Insert checksums
          CHECKSUMS=$(cat ./release-assets/SHA256SUMS.txt)
          # Use awk for multi-line replacement
          awk -v checksums="$CHECKSUMS" '{gsub(/CHECKSUMS_PLACEHOLDER/, checksums); print}' release-notes.md > release-notes-final.md
          mv release-notes-final.md release-notes.md
          
          echo "=== Release Notes ==="
          cat release-notes.md

      - name: Create Git tag
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.version.outputs.version }}" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "${{ steps.version.outputs.version }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        shell: bash
        run: |
          # Using GitHub CLI (pre-installed) instead of a release action
          # --latest marks this as the latest release (not pre-release)
          gh release create "${{ steps.version.outputs.version }}" \
            --title "Release ${{ steps.version.outputs.version }}" \
            --notes-file release-notes.md \
            --latest \
            ./release-assets/*.zip \
            ./release-assets/*.tar.gz \
            ./release-assets/SHA256SUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Output release summary
        shell: bash
        run: |
          echo "## ‚úÖ Release Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL:** https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Assets" >> $GITHUB_STEP_SUMMARY
          for file in ./release-assets/*; do
            filename=$(basename "$file")
            size=$(ls -lh "$file" | awk '{print $5}')
            echo "- \`${filename}\` (${size})" >> $GITHUB_STEP_SUMMARY
          done


================================================================================
FILE: src/Directory.Build.props
SIZE: 1.85 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

<Project>
  <!-- 
    Shared build properties for all projects in the solution.
    
    ANALYSIS LEVEL NOTE:
    We use 'latest-recommended' instead of 'latest-all' because 'latest-all'
    enables rules that are impractical for a console application:
    - CA1303: Requires resource files for ALL literal strings
    - CA1848: Requires LoggerMessage for ALL log calls
    - CA2007: Requires ConfigureAwait everywhere (not needed in console apps)
    
    These rules are valuable for large libraries but overkill here.
  -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <!-- Use 'recommended' level - 'all' is too strict for console apps -->
    <AnalysisLevel>latest-recommended</AnalysisLevel>
    <!-- Enable .NET analyzers -->
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <!-- Enforce code style on build -->
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
  </PropertyGroup>

  <!-- Disable specific rules that don't make sense for this project -->
  <PropertyGroup>
    <!-- CA1303: Do not pass literals as localized parameters - not localizing this app -->
    <NoWarn>$(NoWarn);CA1303</NoWarn>
    <!-- CA2007: Consider calling ConfigureAwait - not needed in console app -->
    <NoWarn>$(NoWarn);CA2007</NoWarn>
    <!-- CA1848: Use LoggerMessage delegates - overkill for simple console app -->
    <NoWarn>$(NoWarn);CA1848</NoWarn>
    <!-- CA1716: Identifiers should not match keywords - 'from/to' are fine param names -->
    <NoWarn>$(NoWarn);CA1716</NoWarn>
  </PropertyGroup>

  <!-- Test projects don't need to be packaged -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
</Project>


================================================================================
FILE: src/Directory.Packages.props
SIZE: 2.11 KB
MODIFIED: 2025-12-26 10:11:10
================================================================================

<Project>
  <!--
    Central Package Management (CPM)
    All NuGet package versions are defined here for consistency.
    
    PACKAGE SELECTION CRITERIA:
    1. Must be free/open source (Apache 2.0, MIT, BSD, etc.)
    2. Must be actively maintained
    3. Prefer Microsoft/official packages where available
    4. Minimal footprint - only include what's truly needed
    
    BANNED PACKAGES (DO NOT ADD):
    - FluentAssertions (restrictive license)
    - MassTransit (restrictive license)
    - Moq (controversial maintainer)
    - Any package with "non-commercial only" license
    
    LAST UPDATED: 2025-12-26
  -->
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- Microsoft.Extensions.* - Core DI and hosting (MIT License) -->
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Options" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.1" />
    
    <!-- SQLite - Official Microsoft package (MIT License) -->
    <PackageVersion Include="Microsoft.Data.Sqlite" Version="10.0.1" />
    
    <!-- OpenTelemetry - Official packages (Apache 2.0 License) -->
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    
    <!-- Testing - xUnit 3 (Apache 2.0 License) -->
    <PackageVersion Include="xunit.v3" Version="3.2.1" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="3.1.5" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Console/appsettings.json
SIZE: 0.49 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "NetworkMonitor": "Information"
    }
  },
  "NetworkMonitor": {
    "RouterAddress": "auto",
    "InternetTarget": "8.8.8.8",
    "TimeoutMs": 3000,
    "IntervalMs": 5000,
    "PingsPerCycle": 3,
    "ExcellentLatencyMs": 20,
    "GoodLatencyMs": 100,
    "DegradedPacketLossPercent": 10,
    "EnableFallbackTargets": true
  },
  "Storage": {
    "RetentionDays": 30,
    "DatabasePath": ""
  }
}


================================================================================
FILE: src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
SIZE: 0.82 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    Console application entry point.
    Thin layer that wires up hosting and runs the monitor.
    All business logic is in NetworkMonitor.Core.
  -->
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\NetworkMonitor.Core\NetworkMonitor.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Console/Program.cs
SIZE: 2.45 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using NetworkMonitor.Core;
using NetworkMonitor.Core.Exporters;

// =============================================================================
// Network Monitor Console Application
// =============================================================================
// A cross-platform network monitoring tool that provides:
// - At-a-glance network health status (PRIMARY GOAL)
// - Historical trendlines via SQLite storage
// - OpenTelemetry metrics exported to files
//
// Usage:
//   dotnet run                          # Run with defaults
//   dotnet run -- --help                # Show help (future)
//   Ctrl+C                              # Graceful shutdown
//
// Configuration via appsettings.json or environment variables.
// =============================================================================

Console.WriteLine("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
Console.WriteLine("‚ïë           Network Monitor - Cross-Platform Edition           ‚ïë");
Console.WriteLine("‚ïë                  Press Ctrl+C to stop                        ‚ïë");
Console.WriteLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
Console.WriteLine();

var fileExporterOptions = new FileExporterOptions();
Console.WriteLine($"üìÅ Telemetry: {fileExporterOptions.Directory}");
Console.WriteLine($"üÜî Run ID: {fileExporterOptions.RunId}");
Console.WriteLine();

var builder = Host.CreateApplicationBuilder(args);

// Configure logging
builder.Logging.SetMinimumLevel(LogLevel.Warning);
builder.Logging.AddFilter("NetworkMonitor", LogLevel.Information);

// Register Network Monitor services
builder.Services.AddNetworkMonitor(builder.Configuration);
builder.Services.AddNetworkMonitorTelemetry(fileExporterOptions);

var host = builder.Build();

// Handle Ctrl+C gracefully
Console.CancelKeyPress += (_, e) =>
{
    e.Cancel = true;
    Console.WriteLine("\n\n‚èπÔ∏è  Shutting down...");
};

try
{
    await host.RunAsync().ConfigureAwait(false);
}
catch (OperationCanceledException)
{
    // Normal shutdown
}
finally
{
    Console.WriteLine("üëã Network Monitor stopped. Goodbye!");
}


================================================================================
FILE: src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
SIZE: 1.55 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using OpenTelemetry.Metrics;

namespace NetworkMonitor.Core.Exporters;

/// <summary>
/// Extension methods for registering file exporters.
/// </summary>
public static class FileExporterExtensions
{
    /// <summary>
    /// Adds a file exporter for metrics.
    /// </summary>
    /// <param name="builder">The meter provider builder.</param>
    /// <param name="options">Optional exporter options.</param>
    /// <returns>The builder for chaining.</returns>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        FileExporterOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(builder);

        options ??= FileExporterOptions.Default;

        var exporter = new FileMetricExporter(options);
        var reader = new PeriodicExportingMetricReader(exporter, exportIntervalMilliseconds: 10000);

        return builder.AddReader(reader);
    }

    /// <summary>
    /// Adds a file exporter with custom configuration.
    /// </summary>
    /// <param name="builder">The meter provider builder.</param>
    /// <param name="configure">Configuration action.</param>
    /// <returns>The builder for chaining.</returns>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        Action<FileExporterOptions> configure)
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(configure);

        var options = new FileExporterOptions();
        configure(options);
        return builder.AddFileExporter(options);
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
SIZE: 2.07 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using System.Globalization;

namespace NetworkMonitor.Core.Exporters;

/// <summary>
/// Configuration for file-based OpenTelemetry exporters.
/// Follows XDG specification with fallbacks.
/// </summary>
public sealed class FileExporterOptions
{
    /// <summary>
    /// Directory where telemetry files will be written.
    /// Automatically determined based on XDG spec if not set.
    /// </summary>
    public string Directory { get; set; } = GetDefaultDirectory();

    /// <summary>
    /// Maximum file size before rotation (25MB default).
    /// </summary>
    public long MaxFileSizeBytes { get; set; } = 25 * 1024 * 1024;

    /// <summary>
    /// Application name for directory structure.
    /// </summary>
    public string ApplicationName { get; set; } = "NetworkMonitor";

    /// <summary>
    /// Unique run identifier for file naming.
    /// </summary>
    public string RunId { get; set; } = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss", CultureInfo.InvariantCulture);

    private static string GetDefaultDirectory()
    {
        // XDG_DATA_HOME (Linux)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            return Path.Combine(xdgDataHome, "NetworkMonitor", "telemetry");
        }

        // Platform-specific app data
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            return Path.Combine(localAppData, "NetworkMonitor", "telemetry");
        }

        // Fallback to ~/.local/share
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(home))
        {
            return Path.Combine(home, ".local", "share", "NetworkMonitor", "telemetry");
        }

        // Final fallback: current directory
        return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    /// <summary>
    /// Gets default options instance.
    /// </summary>
    public static FileExporterOptions Default => new();
}


================================================================================
FILE: src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
SIZE: 5.32 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using System.Globalization;
using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace NetworkMonitor.Core.Exporters;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// Files are rotated based on size and date.
/// Failures are logged but don't stop the application.
/// </summary>
public sealed class FileMetricExporter : BaseExporter<Metric>
{
    private readonly FileExporterOptions _options;
    private readonly Lock _lock = new();
    private StreamWriter? _writer;
    private string _currentFilePath = string.Empty;
    private DateTime _currentDate;
    private long _currentSize;
    private int _fileNumber;
    private bool _firstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions;

    /// <summary>
    /// Creates a new file metric exporter.
    /// </summary>
    /// <param name="options">Exporter options.</param>
    public FileMetricExporter(FileExporterOptions? options = null)
    {
        _options = options ?? FileExporterOptions.Default;
        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        EnsureDirectory();
    }

    /// <inheritdoc />
    public override ExportResult Export(in Batch<Metric> batch)
    {
        try
        {
            lock (_lock)
            {
                EnsureWriter();

                foreach (var metric in batch)
                {
                    foreach (var point in metric.GetMetricPoints())
                    {
                        var record = SerializeMetricPoint(metric, point);
                        var json = JsonSerializer.Serialize(record, _jsonOptions);
                        WriteJson(json);
                    }
                }

                _writer?.Flush();
            }

            return ExportResult.Success;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[FileMetricExporter] Export failed: {ex.Message}");
            return ExportResult.Failure;
        }
    }

    private static object SerializeMetricPoint(Metric metric, MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }

        object? value = metric.MetricType switch
        {
            MetricType.LongSum => point.GetSumLong(),
            MetricType.DoubleSum => point.GetSumDouble(),
            MetricType.LongGauge => point.GetGaugeLastValueLong(),
            MetricType.DoubleGauge => point.GetGaugeLastValueDouble(),
            MetricType.Histogram => new
            {
                Count = point.GetHistogramCount(),
                Sum = point.GetHistogramSum()
            },
            _ => null
        };

        return new
        {
            Timestamp = point.EndTime.ToString("O", CultureInfo.InvariantCulture),
            Name = metric.Name,
            Description = metric.Description,
            Unit = metric.Unit,
            Type = metric.MetricType.ToString(),
            Tags = tags,
            Value = value
        };
    }

    private void WriteJson(string json)
    {
        var bytes = Encoding.UTF8.GetByteCount(json) + 2;

        if (ShouldRotate(bytes))
        {
            RotateFile();
        }

        if (!_firstRecord)
        {
            _writer!.WriteLine(",");
        }
        else
        {
            _firstRecord = false;
        }

        _writer!.Write(json);
        _currentSize += bytes;
    }

    private bool ShouldRotate(long bytes) =>
        _currentSize + bytes > _options.MaxFileSizeBytes ||
        _currentDate != DateTime.UtcNow.Date;

    private void EnsureDirectory()
    {
        try
        {
            System.IO.Directory.CreateDirectory(_options.Directory);
        }
        catch
        {
            // Fallback to current directory
            _options.Directory = Environment.CurrentDirectory;
        }
    }

    private void EnsureWriter()
    {
        if (_writer == null)
        {
            OpenNewFile();
        }
        else if (_currentDate != DateTime.UtcNow.Date)
        {
            RotateFile();
        }
    }

    private void OpenNewFile()
    {
        _currentDate = DateTime.UtcNow.Date;
        _fileNumber = 0;
        _currentFilePath = GetFilePath();

        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentSize = 0;
        _firstRecord = true;

        _writer.WriteLine("[");
        _currentSize = 2;
    }

    private void RotateFile()
    {
        CloseWriter();
        _fileNumber++;
        OpenNewFile();
    }

    private string GetFilePath()
    {
        var fileName = _fileNumber == 0
            ? $"metrics_{_options.RunId}.json"
            : $"metrics_{_options.RunId}_{_fileNumber:D3}.json";
        return Path.Combine(_options.Directory, fileName);
    }

    private void CloseWriter()
    {
        if (_writer != null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    /// <inheritdoc />
    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/HistoricalData.cs
SIZE: 0.84 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Aggregated historical data for trendline display.
/// </summary>
/// <param name="Period">Time period this data covers</param>
/// <param name="AverageLatencyMs">Average latency in milliseconds</param>
/// <param name="MinLatencyMs">Minimum latency observed</param>
/// <param name="MaxLatencyMs">Maximum latency observed</param>
/// <param name="PacketLossPercent">Percentage of failed pings</param>
/// <param name="SampleCount">Number of pings in this period</param>
public sealed record HistoricalData(
    DateTimeOffset Period,
    double AverageLatencyMs,
    long MinLatencyMs,
    long MaxLatencyMs,
    double PacketLossPercent,
    int SampleCount);

/// <summary>
/// Time granularity for historical data aggregation.
/// </summary>
public enum TimeGranularity
{
    Minute,
    Hour,
    Day
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/MonitorOptions.cs
SIZE: 2.97 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration options for the network monitor.
/// Bound from appsettings.json or environment variables.
/// </summary>
public sealed class MonitorOptions
{
    /// <summary>
    /// Configuration section name in appsettings.json
    /// </summary>
    public const string SectionName = "NetworkMonitor";

    /// <summary>
    /// Special value indicating auto-detection should be used.
    /// </summary>
    public const string AutoDetect = "auto";

    /// <summary>
    /// Router/gateway IP address to ping for local network health.
    /// </summary>
    /// <remarks>
    /// Set to "auto" (default) to automatically detect the default gateway.
    /// The gateway is advertised by DHCP and can be read from the OS.
    /// 
    /// If auto-detection fails, common gateway addresses will be tried:
    /// 192.168.1.1, 192.168.0.1, 10.0.0.1, etc.
    /// 
    /// Set to a specific IP address to override auto-detection.
    /// </remarks>
    public string RouterAddress { get; set; } = AutoDetect;

    /// <summary>
    /// Internet target to ping for WAN connectivity.
    /// </summary>
    /// <remarks>
    /// Default: 8.8.8.8 (Google DNS - highly reliable)
    /// 
    /// If this target is unreachable, fallback targets will be tried:
    /// 1.1.1.1 (Cloudflare), 9.9.9.9 (Quad9), etc.
    /// 
    /// This is useful for networks that block specific DNS providers.
    /// </remarks>
    public string InternetTarget { get; set; } = "8.8.8.8";

    /// <summary>
    /// Timeout for each ping in milliseconds.
    /// Default: 3000ms (3 seconds)
    /// </summary>
    public int TimeoutMs { get; set; } = 3000;

    /// <summary>
    /// Interval between monitoring cycles in milliseconds.
    /// Default: 5000ms (5 seconds)
    /// </summary>
    public int IntervalMs { get; set; } = 5000;

    /// <summary>
    /// Number of pings per target per cycle.
    /// Default: 3 (for statistical significance)
    /// </summary>
    public int PingsPerCycle { get; set; } = 3;

    /// <summary>
    /// Latency threshold (ms) below which is considered "excellent".
    /// Default: 20ms
    /// </summary>
    public int ExcellentLatencyMs { get; set; } = 20;

    /// <summary>
    /// Latency threshold (ms) below which is considered "good".
    /// Default: 100ms
    /// </summary>
    public int GoodLatencyMs { get; set; } = 100;

    /// <summary>
    /// Packet loss percentage above which network is "degraded".
    /// Default: 10%
    /// </summary>
    public int DegradedPacketLossPercent { get; set; } = 10;

    /// <summary>
    /// Whether to use fallback targets if primary fails.
    /// Default: true
    /// </summary>
    public bool EnableFallbackTargets { get; set; } = true;

    /// <summary>
    /// Checks if router address should be auto-detected.
    /// </summary>
    public bool IsRouterAutoDetect =>
        string.IsNullOrWhiteSpace(RouterAddress) ||
        RouterAddress.Equals(AutoDetect, StringComparison.OrdinalIgnoreCase);
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/NetworkStatus.cs
SIZE: 1.69 KB
MODIFIED: 2025-12-26 12:27:18
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Represents the overall network health status.
/// This is the "at a glance" view that's our highest priority.
/// </summary>
/// <remarks>
/// Values are ordered from worst (0) to best (4) for natural comparison.
/// This allows: NetworkHealth.Excellent > NetworkHealth.Poor
/// </remarks>
public enum NetworkHealth
{
    /// <summary>No connectivity</summary>
    Offline = 0,

    /// <summary>Significant connectivity issues</summary>
    Poor = 1,

    /// <summary>Some packet loss or high latency</summary>
    Degraded = 2,

    /// <summary>All targets responding but some latency</summary>
    Good = 3,

    /// <summary>All targets responding with good latency</summary>
    Excellent = 4
}

/// <summary>
/// Comprehensive network status at a point in time.
/// Aggregates multiple ping results into a single status view.
/// </summary>
/// <param name="Health">Overall health assessment</param>
/// <param name="RouterResult">Result of pinging the local router/gateway</param>
/// <param name="InternetResult">Result of pinging an internet target (e.g., 8.8.8.8)</param>
/// <param name="Timestamp">When this status was computed</param>
/// <param name="Message">Human-readable status message</param>
public sealed record NetworkStatus(
    NetworkHealth Health,
    PingResult? RouterResult,
    PingResult? InternetResult,
    DateTimeOffset Timestamp,
    string Message)
{
    /// <summary>
    /// Quick check if network is usable (Excellent, Good, or Degraded).
    /// </summary>
    public bool IsUsable => Health is NetworkHealth.Excellent
                            or NetworkHealth.Good
                            or NetworkHealth.Degraded;
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
SIZE: 1.42 KB
MODIFIED: 2025-12-26 11:27:44
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Event arguments for network status change events.
/// Required for CA1003 compliance (EventHandler should use EventArgs).
/// </summary>
public sealed class NetworkStatusEventArgs : EventArgs
{
    /// <summary>
    /// The current network status.
    /// </summary>
    public NetworkStatus CurrentStatus { get; }

    /// <summary>
    /// The previous network status (null if this is the first check).
    /// </summary>
    public NetworkStatus? PreviousStatus { get; }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs with current status only.
    /// </summary>
    /// <param name="currentStatus">The current network status.</param>
    public NetworkStatusEventArgs(NetworkStatus currentStatus)
        : this(currentStatus, null)
    {
    }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs with current and previous status.
    /// </summary>
    /// <param name="currentStatus">The current network status.</param>
    /// <param name="previousStatus">The previous network status.</param>
    public NetworkStatusEventArgs(NetworkStatus currentStatus, NetworkStatus? previousStatus)
    {
        CurrentStatus = currentStatus;
        PreviousStatus = previousStatus;
    }

    /// <summary>
    /// Alias for CurrentStatus to maintain backward compatibility.
    /// </summary>
    public NetworkStatus Status => CurrentStatus;
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/PingResult.cs
SIZE: 1.14 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

namespace NetworkMonitor.Core.Models;

/// <summary>
/// Represents the result of a single ping operation.
/// Immutable record for thread safety and easy comparison.
/// </summary>
/// <param name="Target">The hostname or IP address that was pinged</param>
/// <param name="Success">Whether the ping succeeded</param>
/// <param name="RoundtripTimeMs">Round-trip time in milliseconds (null if failed)</param>
/// <param name="Timestamp">When the ping was performed (UTC)</param>
/// <param name="ErrorMessage">Error message if the ping failed</param>
public sealed record PingResult(
    string Target,
    bool Success,
    long? RoundtripTimeMs,
    DateTimeOffset Timestamp,
    string? ErrorMessage = null)
{
    /// <summary>
    /// Creates a successful ping result.
    /// </summary>
    public static PingResult Succeeded(string target, long roundtripTimeMs) =>
        new(target, true, roundtripTimeMs, DateTimeOffset.UtcNow);

    /// <summary>
    /// Creates a failed ping result.
    /// </summary>
    public static PingResult Failed(string target, string errorMessage) =>
        new(target, false, null, DateTimeOffset.UtcNow, errorMessage);
}


================================================================================
FILE: src/NetworkMonitor.Core/Models/StorageOptions.cs
SIZE: 2.85 KB
MODIFIED: 2025-12-26 07:36:03
================================================================================

using System.Globalization;
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration for telemetry storage.
/// Follows XDG Base Directory Specification with graceful fallbacks.
/// </summary>
public sealed class StorageOptions
{
    public const string SectionName = "Storage";

    /// <summary>
    /// Application name used for directory structure.
    /// </summary>
    public string ApplicationName { get; set; } = "NetworkMonitor";

    /// <summary>
    /// Maximum file size in bytes before rotation (25MB default).
    /// </summary>
    public long MaxFileSizeBytes { get; set; } = 25 * 1024 * 1024;

    /// <summary>
    /// How many days of data to retain in SQLite.
    /// Default: 30 days
    /// </summary>
    public int RetentionDays { get; set; } = 30;

    /// <summary>
    /// Get the data directory following XDG specification with fallbacks.
    /// Priority:
    /// 1. XDG_DATA_HOME (Linux)
    /// 2. LocalApplicationData (Windows/macOS)
    /// 3. Current directory (final fallback)
    /// </summary>
    public string GetDataDirectory()
    {
        // Try XDG_DATA_HOME first (Linux)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome) && CanWriteToDirectory(xdgDataHome))
        {
            return Path.Combine(xdgDataHome, ApplicationName);
        }

        // Try platform-specific app data
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData) && CanWriteToDirectory(localAppData))
        {
            return Path.Combine(localAppData, ApplicationName);
        }

        // Try ~/.local/share (Linux fallback)
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            var localShare = Path.Combine(homeDir, ".local", "share");
            if (CanWriteToDirectory(localShare) || CanWriteToDirectory(homeDir))
            {
                return Path.Combine(localShare, ApplicationName);
            }
        }

        // Final fallback: current directory with timestamp subfolder
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss", CultureInfo.InvariantCulture);
        return Path.Combine(Environment.CurrentDirectory, $"{ApplicationName}_{timestamp}");
    }

    private static bool CanWriteToDirectory(string path)
    {
        try
        {
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }

            // Test write access
            var testFile = Path.Combine(path, $".write_test_{Guid.NewGuid()}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
SIZE: 0.92 KB
MODIFIED: 2025-12-26 07:26:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    Core library containing:
    - Domain models (PingResult, NetworkStatus, etc.)
    - Service interfaces and implementations
    - Storage abstractions and implementations (File, SQLite)
    - OpenTelemetry exporters
    
    This project has no UI dependencies and can be tested in isolation.
  -->
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Options" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
    <PackageReference Include="Microsoft.Data.Sqlite" />
    <!-- OpenTelemetry packages -->
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
SIZE: 2.52 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NetworkMonitor.Core.Exporters;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Core.Storage;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NetworkMonitor.Core;

/// <summary>
/// Extension methods for registering Network Monitor services.
/// Encapsulates all the DI wiring in one place.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers all Network Monitor services with the DI container.
    /// </summary>
    public static IServiceCollection AddNetworkMonitor(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Bind options from configuration
        services.Configure<MonitorOptions>(
            configuration.GetSection(MonitorOptions.SectionName));
        services.Configure<StorageOptions>(
            configuration.GetSection(StorageOptions.SectionName));

        // Register core services
        services.AddSingleton<IPingService, PingService>();
        services.AddSingleton<IGatewayDetector, GatewayDetector>();
        services.AddSingleton<IInternetTargetProvider, InternetTargetProvider>();
        services.AddSingleton<INetworkConfigurationService, NetworkConfigurationService>();
        services.AddSingleton<INetworkMonitorService, NetworkMonitorService>();
        services.AddSingleton<IStatusDisplay, ConsoleStatusDisplay>();
        services.AddSingleton<IStorageService, SqliteStorageService>();

        // Register background service
        services.AddHostedService<MonitorBackgroundService>();

        return services;
    }

    /// <summary>
    /// Adds OpenTelemetry metrics with file and console export.
    /// </summary>
    public static IServiceCollection AddNetworkMonitorTelemetry(
        this IServiceCollection services,
        FileExporterOptions? fileOptions = null)
    {
        fileOptions ??= FileExporterOptions.Default;

        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource
                .AddService(
                    serviceName: "NetworkMonitor",
                    serviceVersion: "1.0.0"))
            .WithMetrics(metrics =>
            {
                metrics
                    .AddMeter("NetworkMonitor.Core")
                    .AddRuntimeInstrumentation()
                    .AddConsoleExporter()
                    .AddFileExporter(fileOptions);
            });

        return services;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
SIZE: 2.28 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Console-based status display with ANSI colors.
/// Provides "at a glance" network status visualization.
/// </summary>
public sealed class ConsoleStatusDisplay : IStatusDisplay
{
    private readonly Lock _lock = new();

    // ANSI color codes
    private const string Reset = "\x1b[0m";
    private const string Bold = "\x1b[1m";
    private const string Green = "\x1b[32m";
    private const string Yellow = "\x1b[33m";
    private const string Red = "\x1b[31m";
    private const string Cyan = "\x1b[36m";
    private const string Magenta = "\x1b[35m";

    /// <inheritdoc />
    public void UpdateStatus(NetworkStatus status)
    {
        ArgumentNullException.ThrowIfNull(status);

        lock (_lock)
        {
            var (color, symbol) = status.Health switch
            {
                NetworkHealth.Excellent => (Green, "‚óè"),
                NetworkHealth.Good => (Green, "‚óã"),
                NetworkHealth.Degraded => (Yellow, "‚óê"),
                NetworkHealth.Poor => (Red, "‚óë"),
                NetworkHealth.Offline => (Red, "‚óã"),
                _ => (Reset, "?")
            };

            Console.Write($"\r{color}{Bold}{symbol} {status.Health,-10}{Reset} ");
            Console.Write($"{Cyan}Router:{Reset} ");

            if (status.RouterResult?.Success == true)
            {
                Console.Write($"{Green}{status.RouterResult.RoundtripTimeMs,4}ms{Reset} ");
            }
            else
            {
                Console.Write($"{Red}FAIL{Reset}   ");
            }

            Console.Write($"{Cyan}Internet:{Reset} ");

            if (status.InternetResult?.Success == true)
            {
                Console.Write($"{Green}{status.InternetResult.RoundtripTimeMs,4}ms{Reset} ");
            }
            else
            {
                Console.Write($"{Red}FAIL{Reset}   ");
            }

            Console.Write($"{Magenta}[{status.Timestamp:HH:mm:ss}]{Reset}");

            // Pad to clear any previous longer text
            Console.Write("          ");
        }
    }

    /// <inheritdoc />
    public void Clear()
    {
        lock (_lock)
        {
            Console.Write("\r" + new string(' ', Console.WindowWidth - 1) + "\r");
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/GatewayDetector.cs
SIZE: 3.33 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

using System.Net.NetworkInformation;
using System.Net.Sockets;
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform default gateway detector using System.Net.NetworkInformation.
/// </summary>
/// <remarks>
/// This implementation reads the default gateway from the OS routing table,
/// which is populated by DHCP or static configuration. Works on Windows,
/// macOS, and Linux without external dependencies.
/// </remarks>
public sealed class GatewayDetector : IGatewayDetector
{
    private readonly ILogger<GatewayDetector> _logger;

    /// <summary>
    /// Common gateway addresses used by consumer routers, ordered by popularity.
    /// These are used as fallbacks if auto-detection fails.
    /// </summary>
    private static readonly string[] CommonGateways =
    [
        "192.168.1.1",   // Most common (Linksys, TP-Link, many ISP routers)
        "192.168.0.1",   // Second most common (D-Link, Netgear, some ISPs)
        "10.0.0.1",      // Apple AirPort, some enterprise networks
        "192.168.2.1",   // Belkin, SMC
        "192.168.1.254", // Some ISP-provided routers (BT, etc.)
        "192.168.0.254", // Some ISP-provided routers
        "10.0.1.1",      // Apple AirPort alternate
        "192.168.10.1",  // Some business routers
        "192.168.100.1", // Some cable modems
        "172.16.0.1",    // Private network range (less common for home)
    ];

    public GatewayDetector(ILogger<GatewayDetector> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public string? DetectDefaultGateway()
    {
        try
        {
            _logger.LogDebug("Attempting to detect default gateway...");

            // Get all network interfaces that are up and have IPv4 connectivity
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(nic => nic.OperationalStatus == OperationalStatus.Up)
                .Where(nic => nic.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                .Where(nic => nic.Supports(NetworkInterfaceComponent.IPv4))
                .ToList();

            _logger.LogDebug("Found {Count} active network interfaces", interfaces.Count);

            foreach (var nic in interfaces)
            {
                var ipProps = nic.GetIPProperties();
                var gateways = ipProps.GatewayAddresses;

                foreach (var gateway in gateways)
                {
                    // Skip IPv6 gateways and 0.0.0.0 (no gateway)
                    if (gateway.Address.AddressFamily != AddressFamily.InterNetwork)
                        continue;

                    var address = gateway.Address.ToString();
                    if (address == "0.0.0.0")
                        continue;

                    _logger.LogInformation(
                        "Detected default gateway: {Gateway} on interface {Interface}",
                        address, nic.Name);

                    return address;
                }
            }

            _logger.LogWarning("No default gateway found on any network interface");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to detect default gateway");
            return null;
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetCommonGatewayAddresses() => CommonGateways;
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/IGatewayDetector.cs
SIZE: 1.30 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Detects the default gateway (router) IP address.
/// </summary>
/// <remarks>
/// The default gateway is advertised by DHCP and can be read from the OS
/// network configuration. This allows the application to work "out of the box"
/// without requiring users to manually configure their router IP.
/// </remarks>
public interface IGatewayDetector
{
    /// <summary>
    /// Attempts to detect the default gateway IP address.
    /// </summary>
    /// <returns>
    /// The IP address of the default gateway, or null if it cannot be detected.
    /// </returns>
    /// <remarks>
    /// On most systems, this returns the router IP (e.g., 192.168.1.1, 192.168.0.1, 10.0.0.1).
    /// Returns null if:
    /// - No network interfaces are available
    /// - No default gateway is configured (e.g., disconnected)
    /// - The system doesn't support gateway detection
    /// </remarks>
    string? DetectDefaultGateway();

    /// <summary>
    /// Gets a list of common gateway addresses to try as fallbacks.
    /// </summary>
    /// <remarks>
    /// If auto-detection fails, these are the most common gateway addresses
    /// used by consumer routers. The list is ordered by popularity.
    /// </remarks>
    IReadOnlyList<string> GetCommonGatewayAddresses();
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/IInternetTargetProvider.cs
SIZE: 0.99 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with fallback support.
/// </summary>
/// <remarks>
/// Not all networks can reach all DNS providers. For example:
/// - Some countries block Google DNS (8.8.8.8)
/// - Some corporate networks only allow specific DNS servers
/// - Some ISPs intercept DNS traffic
/// 
/// This provider allows testing multiple targets and using the first
/// one that responds, ensuring the application works in various
/// network environments.
/// </remarks>
public interface IInternetTargetProvider
{
    /// <summary>
    /// Gets the ordered list of internet targets to try.
    /// </summary>
    /// <remarks>
    /// The first reachable target will be used for monitoring.
    /// Targets are ordered by reliability and global availability.
    /// </remarks>
    IReadOnlyList<string> GetTargets();

    /// <summary>
    /// Gets the primary (preferred) target.
    /// </summary>
    string PrimaryTarget { get; }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/INetworkConfigurationService.cs
SIZE: 1.43 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides resolved network configuration for monitoring.
/// </summary>
/// <remarks>
/// This service handles the complexity of:
/// - Auto-detecting the default gateway
/// - Falling back to common gateway addresses
/// - Finding a reachable internet target
/// - Caching resolved addresses
/// </remarks>
public interface INetworkConfigurationService
{
    /// <summary>
    /// Gets the resolved router/gateway address to monitor.
    /// </summary>
    /// <returns>
    /// The router IP address, or null if no router could be found.
    /// When null, router monitoring should be skipped.
    /// </returns>
    Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the resolved internet target to monitor.
    /// </summary>
    /// <returns>
    /// The internet target IP address. Always returns a value,
    /// falling back to the configured default if nothing is reachable.
    /// </returns>
    Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Initializes the service by detecting and verifying targets.
    /// </summary>
    /// <remarks>
    /// This is called automatically on first access, but can be called
    /// explicitly during startup for eager initialization.
    /// </remarks>
    Task InitializeAsync(CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
SIZE: 0.69 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main service for monitoring network health.
/// Orchestrates ping operations and computes overall status.
/// </summary>
public interface INetworkMonitorService
{
    /// <summary>
    /// Performs a single network health check.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Current network status.</returns>
    Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Event raised when network status changes.
    /// </summary>
    event EventHandler<NetworkStatusEventArgs>? StatusChanged;
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/InternetTargetProvider.cs
SIZE: 2.38 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with automatic fallback.
/// </summary>
public sealed class InternetTargetProvider : IInternetTargetProvider
{
    private readonly ILogger<InternetTargetProvider> _logger;
    private readonly MonitorOptions _options;

    /// <summary>
    /// Well-known, highly available DNS servers that can be used for
    /// connectivity testing. Ordered by global reliability.
    /// </summary>
    private static readonly string[] DefaultTargets =
    [
        "8.8.8.8",       // Google Public DNS (primary)
        "1.1.1.1",       // Cloudflare DNS (very fast, privacy-focused)
        "8.8.4.4",       // Google Public DNS (secondary)
        "1.0.0.1",       // Cloudflare DNS (secondary)
        "9.9.9.9",       // Quad9 DNS (security-focused)
        "208.67.222.222", // OpenDNS (Cisco)
        "208.67.220.220", // OpenDNS (secondary)
    ];

    public InternetTargetProvider(
        IOptions<MonitorOptions> options,
        ILogger<InternetTargetProvider> logger)
    {
        _options = options.Value;
        _logger = logger;

        _logger.LogDebug(
            "Internet target provider initialized with primary target: {Target}",
            PrimaryTarget);
    }

    /// <inheritdoc />
    public string PrimaryTarget => _options.InternetTarget;

    /// <inheritdoc />
    public IReadOnlyList<string> GetTargets()
    {
        // If user specified a custom target, put it first
        if (!string.IsNullOrWhiteSpace(_options.InternetTarget) &&
            !DefaultTargets.Contains(_options.InternetTarget, StringComparer.OrdinalIgnoreCase))
        {
            var customList = new List<string> { _options.InternetTarget };
            customList.AddRange(DefaultTargets);
            return customList;
        }

        // Reorder default list to put configured target first
        var targets = new List<string>(DefaultTargets);
        var configuredIndex = targets.FindIndex(
            t => t.Equals(_options.InternetTarget, StringComparison.OrdinalIgnoreCase));

        if (configuredIndex > 0)
        {
            var configured = targets[configuredIndex];
            targets.RemoveAt(configuredIndex);
            targets.Insert(0, configured);
        }

        return targets;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/IPingService.cs
SIZE: 1.31 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Abstraction for ping operations.
/// Allows for easy testing with fake implementations.
/// </summary>
public interface IPingService
{
    /// <summary>
    /// Sends a single ICMP ping to the specified target.
    /// </summary>
    /// <param name="target">Hostname or IP address</param>
    /// <param name="timeoutMs">Timeout in milliseconds</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Result of the ping operation</returns>
    Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Sends multiple pings and returns all results.
    /// Useful for calculating statistics like packet loss.
    /// </summary>
    /// <param name="target">Hostname or IP address</param>
    /// <param name="count">Number of pings to send</param>
    /// <param name="timeoutMs">Timeout per ping in milliseconds</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All ping results</returns>
    Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/IStatusDisplay.cs
SIZE: 0.54 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Abstraction for displaying network status.
/// Allows for different display implementations (console, GUI, etc.).
/// </summary>
public interface IStatusDisplay
{
    /// <summary>
    /// Updates the display with the current network status.
    /// </summary>
    /// <param name="status">Current status to display</param>
    void UpdateStatus(NetworkStatus status);

    /// <summary>
    /// Clears the display.
    /// </summary>
    void Clear();
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
SIZE: 3.33 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Storage;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Background service that runs the continuous monitoring loop.
/// Implements IHostedService for proper lifecycle management.
/// </summary>
public sealed class MonitorBackgroundService : BackgroundService
{
    private readonly INetworkMonitorService _monitorService;
    private readonly IStatusDisplay _display;
    private readonly IStorageService _storage;
    private readonly MonitorOptions _options;
    private readonly ILogger<MonitorBackgroundService> _logger;

    /// <summary>
    /// Creates a new monitor background service.
    /// </summary>
    public MonitorBackgroundService(
        INetworkMonitorService monitorService,
        IStatusDisplay display,
        IStorageService storage,
        IOptions<MonitorOptions> options,
        ILogger<MonitorBackgroundService> logger)
    {
        _monitorService = monitorService;
        _display = display;
        _storage = storage;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation(
            "Network Monitor starting. Interval: {IntervalMs}ms, Router: {Router}, Internet: {Internet}",
            _options.IntervalMs,
            _options.RouterAddress,
            _options.InternetTarget);

        // Subscribe to status changes for logging significant events
        _monitorService.StatusChanged += OnStatusChanged;

        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var status = await _monitorService.CheckNetworkAsync(stoppingToken);

                    // Update display
                    _display.UpdateStatus(status);

                    // Persist results
                    await _storage.SaveStatusAsync(status, stoppingToken);

                    // Wait for next cycle
                    await Task.Delay(_options.IntervalMs, stoppingToken);
                }
                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)
                {
                    // Normal shutdown
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error during monitoring cycle");

                    // Continue monitoring even if one cycle fails
                    await Task.Delay(_options.IntervalMs, stoppingToken);
                }
            }
        }
        finally
        {
            _monitorService.StatusChanged -= OnStatusChanged;
            _display.Clear();
        }

        _logger.LogInformation("Network Monitor stopped");
    }

    private void OnStatusChanged(object? sender, NetworkStatusEventArgs e)
    {
        // Log significant status changes
        if (e.Status.Health == NetworkHealth.Offline)
        {
            _logger.LogWarning("Network is OFFLINE: {Message}", e.Status.Message);
        }
        else if (e.Status.Health == NetworkHealth.Poor)
        {
            _logger.LogWarning("Network is POOR: {Message}", e.Status.Message);
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs
SIZE: 7.10 KB
MODIFIED: 2025-12-26 11:50:06
================================================================================

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService, IDisposable
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;
    private bool _disposed;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (_initialized) return;

        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized) return;

            _logger.LogDebug("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);

            _initialized = true;

            _logger.LogInformation(
                "Network configuration initialized. Router: {Router}, Internet: {Internet}",
                _resolvedRouterAddress ?? "(none)",
                _resolvedInternetTarget);
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address (not "auto"), use it
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        _logger.LogDebug("Auto-detecting gateway...");

        // Try OS-level detection first
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (!string.IsNullOrEmpty(detected))
        {
            _logger.LogDebug("OS detected gateway: {Gateway}", detected);
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogInformation("Using detected gateway: {Gateway}", detected);
                return detected;
            }
            _logger.LogDebug("Detected gateway {Gateway} is not reachable", detected);
        }

        // Fall back to common gateway addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var gateway in _gatewayDetector.GetCommonGatewayAddresses())
        {
            if (await IsReachableAsync(gateway, cancellationToken))
            {
                _logger.LogInformation("Using fallback gateway: {Gateway}", gateway);
                return gateway;
            }
        }

        _logger.LogWarning("No reachable gateway found. Router monitoring will be disabled.");
        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        foreach (var target in targets)
        {
            if (await IsReachableAsync(target, cancellationToken))
            {
                _logger.LogDebug("Using internet target: {Target}", target);
                return target;
            }
            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // Return primary target even if not reachable - we'll report the failure
        _logger.LogWarning("No reachable internet targets found. Using primary: {Target}",
            _internetTargetProvider.PrimaryTarget);
        return _internetTargetProvider.PrimaryTarget;
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(target, 2000, cancellationToken);
            return result.Success;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to ping {Target}", target);
            return false;
        }
    }

    /// <inheritdoc />
    public async Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized)
                return;

            _logger.LogInformation("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);
            if (_resolvedRouterAddress != null)
            {
                _logger.LogInformation("Router address resolved to: {Address}", _resolvedRouterAddress);
            }
            else
            {
                _logger.LogWarning("Could not resolve router address - router monitoring will be skipped");
            }

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);
            _logger.LogInformation("Internet target resolved to: {Target}", _resolvedInternetTarget);

            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    /// <summary>
    /// Disposes the service and releases resources.
    /// </summary>
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        _initLock.Dispose();
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
SIZE: 8.38 KB
MODIFIED: 2025-12-26 11:27:44
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (!string.IsNullOrEmpty(routerAddress))
        {
            routerResult = await PingWithAggregationAsync(routerAddress, cancellationToken);
            if (routerResult is { Success: true, RoundtripTimeMs: not null })
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }
        }

        // Ping internet target
        var internetResult = await PingWithAggregationAsync(internetTarget, cancellationToken);
        if (internetResult is { Success: true, RoundtripTimeMs: not null })
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult, _options);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());
        activity?.SetTag("router.success", routerResult?.Success ?? false);
        activity?.SetTag("internet.success", internetResult.Success);

        // Fire event if status changed
        if (_lastStatus?.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private async Task<PingResult> PingWithAggregationAsync(
        string target,
        CancellationToken cancellationToken)
    {
        try
        {
            var results = await _pingService.PingMultipleAsync(
                target,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            return AggregateResults(results);
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error pinging {Target}", target);
            return PingResult.Failed(target, ex.Message);
        }
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return median latency of successful pings for stability
        var sortedLatencies = successful
            .Where(r => r.RoundtripTimeMs.HasValue)
            .Select(r => r.RoundtripTimeMs!.Value)
            .OrderBy(l => l)
            .ToList();

        var medianLatency = sortedLatencies.Count > 0
            ? sortedLatencies[sortedLatencies.Count / 2]
            : 0;

        return PingResult.Succeeded(target, medianLatency);
    }

    /// <summary>
    /// Computes network health based on ping results.
    /// </summary>
    /// <remarks>
    /// This method is static as it does not access instance data (CA1822).
    /// </remarks>
    private static (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult,
        MonitorOptions options)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        if (internetLatency <= options.ExcellentLatencyMs &&
            routerLatency <= options.ExcellentLatencyMs)
        {
            return (NetworkHealth.Excellent,
                $"Excellent - Router: {routerLatency}ms, Internet: {internetLatency}ms");
        }

        if (internetLatency <= options.GoodLatencyMs &&
            routerLatency <= options.GoodLatencyMs)
        {
            return (NetworkHealth.Good,
                $"Good - Router: {routerLatency}ms, Internet: {internetLatency}ms");
        }

        // High latency somewhere
        if (routerLatency > options.GoodLatencyMs && routerResult != null)
        {
            return (NetworkHealth.Degraded,
                $"High local latency: Router {routerLatency}ms - possible WiFi interference");
        }

        return (NetworkHealth.Poor,
            $"High internet latency: {internetLatency}ms - possible ISP issues");
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Services/PingService.cs
SIZE: 3.34 KB
MODIFIED: 2025-12-26 07:53:31
================================================================================

using System.Diagnostics;
using System.Net.NetworkInformation;
using Microsoft.Extensions.Logging;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform ping implementation using System.Net.NetworkInformation.
/// Works on Windows, macOS, and Linux without external dependencies.
/// </summary>
public sealed class PingService : IPingService
{
    private readonly ILogger<PingService> _logger;

    public PingService(ILogger<PingService> logger)
    {
        _logger = logger;
    }

    public async Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        // Check cancellation before doing any work
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            _logger.LogDebug("Pinging {Target} with timeout {TimeoutMs}ms", target, timeoutMs);

            // Create a new Ping instance per call to allow concurrent pings.
            // The Ping class does not support multiple concurrent async operations
            // on the same instance.
            using var ping = new Ping();

            var stopwatch = Stopwatch.StartNew();

            // Note: PingAsync doesn't accept CancellationToken directly,
            // but we can use the timeout parameter
            var reply = await ping.SendPingAsync(target, timeoutMs).ConfigureAwait(false);

            stopwatch.Stop();

            // Check cancellation after the ping completes
            cancellationToken.ThrowIfCancellationRequested();

            if (reply.Status == IPStatus.Success)
            {
                _logger.LogDebug(
                    "Ping to {Target} succeeded: {RoundtripMs}ms",
                    target,
                    reply.RoundtripTime);

                return PingResult.Succeeded(target, reply.RoundtripTime);
            }

            var errorMessage = reply.Status.ToString();
            _logger.LogDebug("Ping to {Target} failed: {Status}", target, errorMessage);

            return PingResult.Failed(target, errorMessage);
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug("Ping to {Target} cancelled", target);
            throw;
        }
        catch (PingException ex)
        {
            _logger.LogWarning(ex, "Ping to {Target} threw exception", target);
            return PingResult.Failed(target, ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error pinging {Target}", target);
            return PingResult.Failed(target, $"Unexpected error: {ex.Message}");
        }
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var result = await PingAsync(target, timeoutMs, cancellationToken).ConfigureAwait(false);
            results.Add(result);

            // Small delay between pings to avoid flooding
            if (i < count - 1)
            {
                await Task.Delay(50, cancellationToken).ConfigureAwait(false);
            }
        }

        return results;
    }
}


================================================================================
FILE: src/NetworkMonitor.Core/Storage/IStorageService.cs
SIZE: 1.44 KB
MODIFIED: 2025-12-26 07:27:47
================================================================================

using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Storage;

/// <summary>
/// Abstraction for persisting network status data.
/// Implementations may write to files, SQLite, or both.
/// </summary>
public interface IStorageService
{
    /// <summary>
    /// Persists a network status snapshot.
    /// </summary>
    /// <param name="status">The status to save.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task SaveStatusAsync(NetworkStatus status, CancellationToken cancellationToken = default);

    /// <summary>
    /// Retrieves historical data for trendline display.
    /// </summary>
    /// <param name="from">Start of time range.</param>
    /// <param name="to">End of time range.</param>
    /// <param name="granularity">Time granularity for aggregation.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<IReadOnlyList<HistoricalData>> GetHistoricalDataAsync(
        DateTimeOffset from,
        DateTimeOffset to,
        TimeGranularity granularity,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets recent raw ping results for detailed analysis.
    /// </summary>
    /// <param name="count">Number of results to retrieve.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<IReadOnlyList<PingResult>> GetRecentPingsAsync(
        int count,
        CancellationToken cancellationToken = default);
}


================================================================================
FILE: src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
SIZE: 12.16 KB
MODIFIED: 2025-12-26 07:36:03
================================================================================

using System.Globalization;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Storage;

/// <summary>
/// SQLite-based storage for network monitoring data.
/// Provides durable storage with efficient querying for trendlines.
/// 
/// Schema is automatically created/migrated on startup.
/// Old data is automatically pruned based on retention settings.
/// </summary>
public sealed class SqliteStorageService : IStorageService, IAsyncDisposable
{
    private readonly StorageOptions _options;
    private readonly ILogger<SqliteStorageService> _logger;
    private readonly string _connectionString;
    private bool _initialized;
    private readonly SemaphoreSlim _initLock = new(1, 1);

    /// <summary>
    /// Creates a new SQLite storage service.
    /// </summary>
    public SqliteStorageService(
        IOptions<StorageOptions> options,
        ILogger<SqliteStorageService> logger)
    {
        _options = options.Value;
        _logger = logger;

        var dataDir = _options.GetDataDirectory();
        Directory.CreateDirectory(dataDir);

        var dbPath = Path.Combine(dataDir, "network-monitor.db");
        _connectionString = $"Data Source={dbPath}";

        _logger.LogInformation("SQLite database path: {DbPath}", dbPath);
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (_initialized) return;

        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized) return;

            await using var connection = new SqliteConnection(_connectionString);
            await connection.OpenAsync(cancellationToken);

            // Create tables
            const string createTablesSql = """
                CREATE TABLE IF NOT EXISTS ping_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target TEXT NOT NULL,
                    success INTEGER NOT NULL,
                    roundtrip_ms INTEGER,
                    timestamp TEXT NOT NULL,
                    error_message TEXT,
                    target_type TEXT NOT NULL
                );
                
                CREATE INDEX IF NOT EXISTS idx_ping_results_timestamp 
                ON ping_results(timestamp DESC);
                
                CREATE INDEX IF NOT EXISTS idx_ping_results_target_type 
                ON ping_results(target_type, timestamp DESC);
                
                CREATE TABLE IF NOT EXISTS network_status (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    health TEXT NOT NULL,
                    message TEXT NOT NULL,
                    timestamp TEXT NOT NULL,
                    router_latency_ms INTEGER,
                    internet_latency_ms INTEGER
                );
                
                CREATE INDEX IF NOT EXISTS idx_network_status_timestamp 
                ON network_status(timestamp DESC);
                """;

            await using var command = connection.CreateCommand();
            command.CommandText = createTablesSql;
            await command.ExecuteNonQueryAsync(cancellationToken);

            _logger.LogDebug("Database schema initialized");
            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task SaveStatusAsync(NetworkStatus status, CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(status);

        try
        {
            await EnsureInitializedAsync(cancellationToken);

            await using var connection = new SqliteConnection(_connectionString);
            await connection.OpenAsync(cancellationToken);

            // Save status
            await using var statusCommand = connection.CreateCommand();
            statusCommand.CommandText = """
                INSERT INTO network_status (health, message, timestamp, router_latency_ms, internet_latency_ms)
                VALUES (@health, @message, @timestamp, @routerLatency, @internetLatency)
                """;

            statusCommand.Parameters.AddWithValue("@health", status.Health.ToString());
            statusCommand.Parameters.AddWithValue("@message", status.Message);
            statusCommand.Parameters.AddWithValue("@timestamp", status.Timestamp.ToString("O", CultureInfo.InvariantCulture));
            statusCommand.Parameters.AddWithValue("@routerLatency",
                (object?)status.RouterResult?.RoundtripTimeMs ?? DBNull.Value);
            statusCommand.Parameters.AddWithValue("@internetLatency",
                (object?)status.InternetResult?.RoundtripTimeMs ?? DBNull.Value);

            await statusCommand.ExecuteNonQueryAsync(cancellationToken);

            // Save individual ping results
            if (status.RouterResult != null)
            {
                await SavePingResultAsync(connection, status.RouterResult, "router", cancellationToken);
            }

            if (status.InternetResult != null)
            {
                await SavePingResultAsync(connection, status.InternetResult, "internet", cancellationToken);
            }

            // Periodically prune old data (roughly every 100 saves)
            if (Random.Shared.Next(100) == 0)
            {
                await PruneOldDataAsync(connection, cancellationToken);
            }
        }
        catch (Exception ex)
        {
            // Log but don't throw - storage failures shouldn't stop monitoring
            _logger.LogWarning(ex, "Failed to save status to SQLite");
        }
    }

    private static async Task SavePingResultAsync(
        SqliteConnection connection,
        PingResult result,
        string targetType,
        CancellationToken cancellationToken)
    {
        await using var command = connection.CreateCommand();
        command.CommandText = """
            INSERT INTO ping_results (target, success, roundtrip_ms, timestamp, error_message, target_type)
            VALUES (@target, @success, @roundtripMs, @timestamp, @errorMessage, @targetType)
            """;

        command.Parameters.AddWithValue("@target", result.Target);
        command.Parameters.AddWithValue("@success", result.Success ? 1 : 0);
        command.Parameters.AddWithValue("@roundtripMs", (object?)result.RoundtripTimeMs ?? DBNull.Value);
        command.Parameters.AddWithValue("@timestamp", result.Timestamp.ToString("O", CultureInfo.InvariantCulture));
        command.Parameters.AddWithValue("@errorMessage", (object?)result.ErrorMessage ?? DBNull.Value);
        command.Parameters.AddWithValue("@targetType", targetType);

        await command.ExecuteNonQueryAsync(cancellationToken);
    }

    private async Task PruneOldDataAsync(SqliteConnection connection, CancellationToken cancellationToken)
    {
        var cutoff = DateTimeOffset.UtcNow.AddDays(-_options.RetentionDays).ToString("O", CultureInfo.InvariantCulture);

        await using var command = connection.CreateCommand();
        command.CommandText = """
            DELETE FROM ping_results WHERE timestamp < @cutoff;
            DELETE FROM network_status WHERE timestamp < @cutoff;
            """;
        command.Parameters.AddWithValue("@cutoff", cutoff);

        var deleted = await command.ExecuteNonQueryAsync(cancellationToken);

        if (deleted > 0)
        {
            _logger.LogDebug("Pruned {Count} old records", deleted);
        }
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<HistoricalData>> GetHistoricalDataAsync(
        DateTimeOffset from,
        DateTimeOffset to,
        TimeGranularity granularity,
        CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);

        await using var connection = new SqliteConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = """
            SELECT roundtrip_ms, timestamp, success, target_type
            FROM ping_results
            WHERE timestamp >= @from AND timestamp <= @to
            ORDER BY timestamp
            """;

        command.Parameters.AddWithValue("@from", from.ToString("O", CultureInfo.InvariantCulture));
        command.Parameters.AddWithValue("@to", to.ToString("O", CultureInfo.InvariantCulture));

        var results = new List<(long? LatencyMs, DateTimeOffset Timestamp, bool Success)>();

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        while (await reader.ReadAsync(cancellationToken))
        {
            var latencyMs = reader.IsDBNull(0) ? (long?)null : reader.GetInt64(0);
            var timestamp = DateTimeOffset.Parse(reader.GetString(1), CultureInfo.InvariantCulture);
            var success = reader.GetInt32(2) == 1;

            results.Add((latencyMs, timestamp, success));
        }

        return AggregateByGranularity(results, granularity);
    }

    private static List<HistoricalData> AggregateByGranularity(
        List<(long? LatencyMs, DateTimeOffset Timestamp, bool Success)> results,
        TimeGranularity granularity)
    {
        if (results.Count == 0)
        {
            return [];
        }

        var grouped = results.GroupBy(r => TruncateToPeriod(r.Timestamp, granularity));

        return grouped.Select(g =>
        {
            var successfulPings = g.Where(p => p.Success && p.LatencyMs.HasValue).ToList();
            var latencies = successfulPings.Select(p => p.LatencyMs!.Value).ToList();

            return new HistoricalData(
                Period: g.Key,
                AverageLatencyMs: latencies.Count > 0 ? latencies.Average() : 0,
                MinLatencyMs: latencies.Count > 0 ? latencies.Min() : 0,
                MaxLatencyMs: latencies.Count > 0 ? latencies.Max() : 0,
                PacketLossPercent: g.Any() ?
                    (double)(g.Count() - successfulPings.Count) / g.Count() * 100 : 0,
                SampleCount: g.Count());
        }).OrderBy(h => h.Period).ToList();
    }

    private static DateTimeOffset TruncateToPeriod(DateTimeOffset timestamp, TimeGranularity granularity)
    {
        return granularity switch
        {
            TimeGranularity.Minute => new DateTimeOffset(
                timestamp.Year, timestamp.Month, timestamp.Day,
                timestamp.Hour, timestamp.Minute, 0, timestamp.Offset),
            TimeGranularity.Hour => new DateTimeOffset(
                timestamp.Year, timestamp.Month, timestamp.Day,
                timestamp.Hour, 0, 0, timestamp.Offset),
            TimeGranularity.Day => new DateTimeOffset(
                timestamp.Year, timestamp.Month, timestamp.Day,
                0, 0, 0, timestamp.Offset),
            _ => timestamp
        };
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<PingResult>> GetRecentPingsAsync(
        int count,
        CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);

        await using var connection = new SqliteConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = """
            SELECT target, success, roundtrip_ms, timestamp, error_message
            FROM ping_results
            ORDER BY timestamp DESC
            LIMIT @count
            """;
        command.Parameters.AddWithValue("@count", count);

        var results = new List<PingResult>();

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        while (await reader.ReadAsync(cancellationToken))
        {
            results.Add(new PingResult(
                Target: reader.GetString(0),
                Success: reader.GetInt32(1) == 1,
                RoundtripTimeMs: reader.IsDBNull(2) ? null : reader.GetInt64(2),
                Timestamp: DateTimeOffset.Parse(reader.GetString(3), CultureInfo.InvariantCulture),
                ErrorMessage: reader.IsDBNull(4) ? null : reader.GetString(4)));
        }

        return results;
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        _initLock.Dispose();
        await Task.CompletedTask;
    }
}


================================================================================
FILE: src/NetworkMonitor.slnx
SIZE: 0.23 KB
MODIFIED: 2025-12-26 07:04:46
================================================================================

<Solution>
  <Project Path="NetworkMonitor.Core/NetworkMonitor.Core.csproj" />
  <Project Path="NetworkMonitor.Console/NetworkMonitor.Console.csproj" />
  <Project Path="NetworkMonitor.Tests/NetworkMonitor.Tests.csproj" />
</Solution>


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs
SIZE: 1.17 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake gateway detector for testing.
/// </summary>
public sealed class FakeGatewayDetector : IGatewayDetector
{
    private string? _gatewayToReturn;
    private readonly List<string> _commonGateways = ["192.168.1.1", "192.168.0.1", "10.0.0.1"];

    /// <summary>
    /// Configures the detector to return a specific gateway.
    /// </summary>
    public FakeGatewayDetector WithGateway(string? gateway)
    {
        _gatewayToReturn = gateway;
        return this;
    }

    /// <summary>
    /// Configures the detector to return null (no gateway found).
    /// </summary>
    public FakeGatewayDetector WithNoGateway()
    {
        _gatewayToReturn = null;
        return this;
    }

    /// <summary>
    /// Configures the common gateways list.
    /// </summary>
    public FakeGatewayDetector WithCommonGateways(params string[] gateways)
    {
        _commonGateways.Clear();
        _commonGateways.AddRange(gateways);
        return this;
    }

    public string? DetectDefaultGateway() => _gatewayToReturn;

    public IReadOnlyList<string> GetCommonGatewayAddresses() => _commonGateways;
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs
SIZE: 1.01 KB
MODIFIED: 2025-12-26 12:33:40
================================================================================

using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private string _primaryTarget = "8.8.8.8";
    private List<string> _targets = ["8.8.8.8", "1.1.1.1", "208.67.222.222"];

    public string PrimaryTarget => _primaryTarget;

    public FakeInternetTargetProvider WithPrimaryTarget(string target)
    {
        _primaryTarget = target;

        // Remove the target if it exists (no need to check Contains first)
        _targets.Remove(target);

        // Now insert it at the start
        _targets.Insert(0, target);

        return this;
    }

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets = targets.ToList();
        if (_targets.Count > 0)
        {
            _primaryTarget = _targets[0];
        }
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs
SIZE: 1.16 KB
MODIFIED: 2025-12-26 12:27:18
================================================================================

using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// Returns configurable addresses without actual network operations.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService, IDisposable
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public Task InitializeAsync(CancellationToken cancellationToken = default)
        => Task.CompletedTask;

    public void Dispose()
    {
        // Nothing to dispose in fake
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakePingService.cs
SIZE: 2.72 KB
MODIFIED: 2025-12-26 12:43:07
================================================================================

using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake ping service for testing.
/// Allows controlled responses without actual network calls.
/// </summary>
public sealed class FakePingService : IPingService
{
    private readonly Queue<PingResult> _queuedResults = new();
    private Func<string, PingResult>? _resultFactory;

    /// <summary>
    /// Queues a specific result to be returned.
    /// Results are dequeued in FIFO order.
    /// </summary>
    public FakePingService QueueResult(PingResult result)
    {
        _queuedResults.Enqueue(result);
        return this;
    }

    /// <summary>
    /// Configures the service to always succeed with the given latency.
    /// </summary>
    public FakePingService AlwaysSucceed(long latencyMs = 10)
    {
        _resultFactory = target => PingResult.Succeeded(target, latencyMs);
        return this;
    }

    /// <summary>
    /// Configures the service to always fail with the given error.
    /// </summary>
    public FakePingService AlwaysFail(string error = "Timeout")
    {
        _resultFactory = target => PingResult.Failed(target, error);
        return this;
    }

    /// <summary>
    /// Configures a custom factory for generating results.
    /// </summary>
    public FakePingService WithFactory(Func<string, PingResult> factory)
    {
        _resultFactory = factory;
        return this;
    }

    /// <summary>
    /// Clears all queued results and resets the factory.
    /// </summary>
    public FakePingService Reset()
    {
        _queuedResults.Clear();
        _resultFactory = null;
        return this;
    }

    public Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (_queuedResults.Count > 0)
        {
            return Task.FromResult(_queuedResults.Dequeue());
        }

        if (_resultFactory != null)
        {
            return Task.FromResult(_resultFactory(target));
        }

        // Default: succeed with 10ms latency
        return Task.FromResult(PingResult.Succeeded(target, 10));
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            results.Add(await PingAsync(target, timeoutMs, cancellationToken));
        }

        return results;
    }
    
    public void Reset() 
{
    _queuedResults.Clear();
    _specificResults.Clear();
    _alwaysSucceed = false;
}
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
SIZE: 1.74 KB
MODIFIED: 2025-12-26 07:23:02
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Tests for the FakePingService itself.
/// Ensures our test doubles work correctly.
/// </summary>
public sealed class FakePingServiceTests
{
    [Fact]
    public async Task AlwaysSucceed_ReturnsSuccessfulPings()
    {
        // Arrange
        var fake = new FakePingService().AlwaysSucceed(25);

        // Act
        var result = await fake.PingAsync("test", 1000, TestContext.Current.CancellationToken);

        // Assert
        Assert.True(result.Success);
        Assert.Equal(25, result.RoundtripTimeMs);
    }

    [Fact]
    public async Task QueuedResults_ReturnedInOrder()
    {
        // Arrange
        var fake = new FakePingService()
            .QueueResult(PingResult.Succeeded("", 10))
            .QueueResult(PingResult.Succeeded("", 20))
            .QueueResult(PingResult.Failed("", "error"));

        // Act
        var r1 = await fake.PingAsync("target", 1000, TestContext.Current.CancellationToken);
        var r2 = await fake.PingAsync("target", 1000, TestContext.Current.CancellationToken);
        var r3 = await fake.PingAsync("target", 1000, TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(10, r1.RoundtripTimeMs);
        Assert.Equal(20, r2.RoundtripTimeMs);
        Assert.False(r3.Success);
    }

    [Fact]
    public async Task PingMultipleAsync_ReturnsRequestedCount()
    {
        // Arrange
        var fake = new FakePingService().AlwaysSucceed();

        // Act
        var results = await fake.PingMultipleAsync("test", 5, 1000, TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(5, results.Count);
        Assert.All(results, r => Assert.True(r.Success));
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
SIZE: 1.61 KB
MODIFIED: 2025-12-26 07:08:12
================================================================================

using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Storage;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// In-memory storage for testing.
/// Stores data in memory without any I/O.
/// </summary>
internal sealed class FakeStorageService : IStorageService
{
    private readonly List<NetworkStatus> _statuses = new();
    private readonly List<PingResult> _pings = new();

    public IReadOnlyList<NetworkStatus> SavedStatuses => _statuses;
    public IReadOnlyList<PingResult> SavedPings => _pings;

    public Task SaveStatusAsync(NetworkStatus status, CancellationToken cancellationToken = default)
    {
        _statuses.Add(status);

        if (status.RouterResult != null)
        {
            _pings.Add(status.RouterResult);
        }

        if (status.InternetResult != null)
        {
            _pings.Add(status.InternetResult);
        }

        return Task.CompletedTask;
    }

    public Task<IReadOnlyList<HistoricalData>> GetHistoricalDataAsync(
        DateTimeOffset from,
        DateTimeOffset to,
        TimeGranularity granularity,
        CancellationToken cancellationToken = default)
    {
        // Simple implementation for testing
        return Task.FromResult<IReadOnlyList<HistoricalData>>(Array.Empty<HistoricalData>());
    }

    public Task<IReadOnlyList<PingResult>> GetRecentPingsAsync(
        int count,
        CancellationToken cancellationToken = default)
    {
        return Task.FromResult<IReadOnlyList<PingResult>>(
            _pings.TakeLast(count).Reverse().ToList());
    }

    public void Clear()
    {
        _statuses.Clear();
        _pings.Clear();
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Models/MonitorOptionsTests.cs
SIZE: 1.86 KB
MODIFIED: 2025-12-26 12:04:18
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for MonitorOptions.
/// </summary>
public sealed class MonitorOptionsTests
{
    [Fact]
    public void IsRouterAutoDetect_WhenAuto_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "auto" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenAutoUppercase_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "AUTO" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenEmpty_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenNull_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = null! };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenIpAddress_ReturnsFalse()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "192.168.1.1" };

        // Act & Assert
        Assert.False(options.IsRouterAutoDetect);
    }

    [Fact]
    public void DefaultRouterAddress_IsAuto()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.Equal("auto", options.RouterAddress);
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void EnableFallbackTargets_DefaultsToTrue()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.True(options.EnableFallbackTargets);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Models/NetworkHealthTests.cs
SIZE: 2.63 KB
MODIFIED: 2025-12-26 12:30:29
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for NetworkHealth enum values.
/// </summary>
public sealed class NetworkHealthTests
{
    [Fact]
    public void NetworkHealth_HasExpectedValues()
    {
        // Assert all expected values exist and have correct numeric values
        // Ordered from worst (0) to best (4)
        Assert.Equal(0, (int)NetworkHealth.Offline);
        Assert.Equal(1, (int)NetworkHealth.Poor);
        Assert.Equal(2, (int)NetworkHealth.Degraded);
        Assert.Equal(3, (int)NetworkHealth.Good);
        Assert.Equal(4, (int)NetworkHealth.Excellent);
    }

    [Fact]
    public void NetworkHealth_ValuesAreDefined()
    {
        // Assert all expected values are defined in the enum
        Assert.True(Enum.IsDefined<NetworkHealth>(NetworkHealth.Offline));
        Assert.True(Enum.IsDefined<NetworkHealth>(NetworkHealth.Poor));
        Assert.True(Enum.IsDefined<NetworkHealth>(NetworkHealth.Degraded));
        Assert.True(Enum.IsDefined<NetworkHealth>(NetworkHealth.Good));
        Assert.True(Enum.IsDefined<NetworkHealth>(NetworkHealth.Excellent));
    }

    [Fact]
    public void NetworkHealth_CanCompare()
    {
        // Assert ordering works as expected (Excellent > Good > Degraded > Poor > Offline)
        Assert.True(NetworkHealth.Excellent > NetworkHealth.Good);
        Assert.True(NetworkHealth.Good > NetworkHealth.Degraded);
        Assert.True(NetworkHealth.Degraded > NetworkHealth.Poor);
        Assert.True(NetworkHealth.Poor > NetworkHealth.Offline);
    }

    [Fact]
    public void NetworkHealth_ToString_ReturnsName()
    {
        Assert.Equal("Excellent", NetworkHealth.Excellent.ToString());
        Assert.Equal("Good", NetworkHealth.Good.ToString());
        Assert.Equal("Degraded", NetworkHealth.Degraded.ToString());
        Assert.Equal("Poor", NetworkHealth.Poor.ToString());
        Assert.Equal("Offline", NetworkHealth.Offline.ToString());
    }

    [Fact]
    public void NetworkHealth_ComparisonOperators_WorkCorrectly()
    {
        // Test various comparison operators
        // Assert.True(NetworkHealth.Excellent >= NetworkHealth.Excellent);
        Assert.True(NetworkHealth.Excellent >= NetworkHealth.Good);
        Assert.False(NetworkHealth.Good >= NetworkHealth.Excellent);

        // Assert.True(NetworkHealth.Offline <= NetworkHealth.Offline);
        Assert.True(NetworkHealth.Offline <= NetworkHealth.Poor);
        Assert.False(NetworkHealth.Poor <= NetworkHealth.Offline);

        Assert.True(NetworkHealth.Excellent != NetworkHealth.Good);
        // Assert.True(NetworkHealth.Excellent == NetworkHealth.Excellent);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Models/NetworkStatusEventArgsTests.cs
SIZE: 1.79 KB
MODIFIED: 2025-12-26 12:04:18
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for NetworkStatusEventArgs.
/// </summary>
public sealed class NetworkStatusEventArgsTests
{
    private static NetworkStatus CreateTestStatus(NetworkHealth health) =>
        new(health, null, null, DateTimeOffset.UtcNow, "Test");

    [Fact]
    public void Constructor_SingleArg_SetsCurrentStatus()
    {
        // Arrange
        var status = CreateTestStatus(NetworkHealth.Excellent);

        // Act
        var args = new NetworkStatusEventArgs(status);

        // Assert
        Assert.Equal(status, args.CurrentStatus);
        Assert.Null(args.PreviousStatus);
    }

    [Fact]
    public void Constructor_TwoArgs_SetsBothStatuses()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Excellent);
        var previous = CreateTestStatus(NetworkHealth.Poor);

        // Act
        var args = new NetworkStatusEventArgs(current, previous);

        // Assert
        Assert.Equal(current, args.CurrentStatus);
        Assert.Equal(previous, args.PreviousStatus);
    }

    [Fact]
    public void Status_ReturnsCurrentStatus()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Good);
        var previous = CreateTestStatus(NetworkHealth.Degraded);
        var args = new NetworkStatusEventArgs(current, previous);

        // Act & Assert
        Assert.Same(args.CurrentStatus, args.Status);
    }

    [Fact]
    public void Constructor_WithNullPrevious_Succeeds()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Excellent);

        // Act
        var args = new NetworkStatusEventArgs(current, null);

        // Assert
        Assert.Equal(current, args.CurrentStatus);
        Assert.Null(args.PreviousStatus);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Models/PingResultTests.cs
SIZE: 1.92 KB
MODIFIED: 2025-12-26 12:04:18
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for PingResult.
/// </summary>
public sealed class PingResultTests
{
    [Fact]
    public void Succeeded_CreatesSuccessfulResult()
    {
        // Act
        var result = PingResult.Succeeded("8.8.8.8", 15);

        // Assert
        Assert.True(result.Success);
        Assert.Equal("8.8.8.8", result.Target);
        Assert.Equal(15, result.RoundtripTimeMs);
        Assert.Null(result.ErrorMessage);
    }

    [Fact]
    public void Failed_CreatesFailedResult()
    {
        // Act
        var result = PingResult.Failed("8.8.8.8", "Request timed out");

        // Assert
        Assert.False(result.Success);
        Assert.Equal("8.8.8.8", result.Target);
        Assert.Null(result.RoundtripTimeMs);
        Assert.Equal("Request timed out", result.ErrorMessage);
    }

    [Fact]
    public void Timestamp_IsSetToCurrentTime()
    {
        // Arrange
        var before = DateTimeOffset.UtcNow;

        // Act
        var result = PingResult.Succeeded("8.8.8.8", 10);

        // Assert
        var after = DateTimeOffset.UtcNow;
        Assert.True(result.Timestamp >= before);
        Assert.True(result.Timestamp <= after);
    }

    [Fact]
    public void Succeeded_WithZeroLatency_IsValid()
    {
        // Act
        var result = PingResult.Succeeded("localhost", 0);

        // Assert
        Assert.True(result.Success);
        Assert.Equal(0, result.RoundtripTimeMs);
    }

    [Fact]
    public void Record_Equality_WorksCorrectly()
    {
        // Arrange
        var timestamp = DateTimeOffset.UtcNow;
        var result1 = new PingResult("8.8.8.8", true, 10, timestamp);
        var result2 = new PingResult("8.8.8.8", true, 10, timestamp);
        var result3 = new PingResult("8.8.8.8", true, 20, timestamp);

        // Assert
        Assert.Equal(result1, result2);
        Assert.NotEqual(result1, result3);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
SIZE: 0.95 KB
MODIFIED: 2025-12-26 07:45:26
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    Unit tests using xUnit 3.
    
    Testing approach:
    - Use manual fakes/stubs instead of mocking frameworks (Moq is banned)
    - Focus on behavior, not implementation details
    - Each test class tests one component in isolation
    - Integration tests can test multiple components together
  -->
  <PropertyGroup>
    <!-- 
      CA1707: Identifiers should not contain underscores
      Disabled because test methods commonly use Method_Scenario_Expected naming.
    -->
    <NoWarn>$(NoWarn);CA1707</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="xunit.v3" />
    <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\NetworkMonitor.Core\NetworkMonitor.Core.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: src/NetworkMonitor.Tests/NetworkStatusTests.cs
SIZE: 0.83 KB
MODIFIED: 2025-12-26 07:23:02
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests;

/// <summary>
/// Tests for NetworkStatus model.
/// </summary>
public sealed class NetworkStatusTests
{
    [Theory]
    [InlineData(NetworkHealth.Excellent, true)]
    [InlineData(NetworkHealth.Good, true)]
    [InlineData(NetworkHealth.Degraded, true)]
    [InlineData(NetworkHealth.Poor, false)]
    [InlineData(NetworkHealth.Offline, false)]
    public void IsUsable_ReturnsCorrectValue(NetworkHealth health, bool expectedUsable)
    {
        // Arrange
        var status = new NetworkStatus(
            health,
            PingResult.Succeeded("router", 10),
            PingResult.Succeeded("internet", 20),
            DateTimeOffset.UtcNow,
            "Test message");

        // Act & Assert
        Assert.Equal(expectedUsable, status.IsUsable);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/PingResultTests.cs
SIZE: 1.19 KB
MODIFIED: 2025-12-26 07:23:02
================================================================================

using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests;

/// <summary>
/// Tests for PingResult model.
/// </summary>
public sealed class PingResultTests
{
    [Fact]
    public void Succeeded_CreatesSuccessfulResult()
    {
        // Arrange & Act
        var result = PingResult.Succeeded("192.168.1.1", 42);

        // Assert
        Assert.True(result.Success);
        Assert.Equal("192.168.1.1", result.Target);
        Assert.Equal(42, result.RoundtripTimeMs);
        Assert.Null(result.ErrorMessage);
    }

    [Fact]
    public void Failed_CreatesFailedResult()
    {
        // Arrange & Act
        var result = PingResult.Failed("8.8.8.8", "Timeout");

        // Assert
        Assert.False(result.Success);
        Assert.Equal("8.8.8.8", result.Target);
        Assert.Null(result.RoundtripTimeMs);
        Assert.Equal("Timeout", result.ErrorMessage);
    }

    [Fact]
    public void Timestamp_IsSetToUtcNow()
    {
        // Arrange
        var before = DateTimeOffset.UtcNow;

        // Act
        var result = PingResult.Succeeded("test", 10);

        // Assert
        var after = DateTimeOffset.UtcNow;
        Assert.InRange(result.Timestamp, before, after);
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Services/GatewayDetectorTests.cs
SIZE: 1.55 KB
MODIFIED: 2025-12-26 11:16:05
================================================================================

using Microsoft.Extensions.Logging.Abstractions;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for GatewayDetector.
/// Note: These tests run against the real network stack, so results
/// depend on the test environment. We test the interface contract.
/// </summary>
public sealed class GatewayDetectorTests
{
    private readonly GatewayDetector _detector;

    public GatewayDetectorTests()
    {
        _detector = new GatewayDetector(NullLogger<GatewayDetector>.Instance);
    }

    [Fact]
    public void DetectDefaultGateway_ReturnsValidIpOrNull()
    {
        // Act
        var result = _detector.DetectDefaultGateway();

        // Assert - should be null or a valid IP
        if (result != null)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", result);
        }
    }

    [Fact]
    public void GetCommonGatewayAddresses_ReturnsNonEmptyList()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        Assert.NotEmpty(addresses);
        Assert.Contains("192.168.1.1", addresses);
        Assert.Contains("192.168.0.1", addresses);
        Assert.Contains("10.0.0.1", addresses);
    }

    [Fact]
    public void GetCommonGatewayAddresses_AllAreValidIpAddresses()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        foreach (var address in addresses)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", address);
        }
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs
SIZE: 2.12 KB
MODIFIED: 2025-12-26 12:04:18
================================================================================

using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for InternetTargetProvider.
/// </summary>
public sealed class InternetTargetProviderTests
{
    [Fact]
    public void PrimaryTarget_ReturnsConfiguredTarget()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act & Assert
        Assert.Equal("1.1.1.1", provider.PrimaryTarget);
    }

    [Fact]
    public void GetTargets_ReturnsConfiguredTargetFirst()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("1.1.1.1", targets[0]);
    }

    [Fact]
    public void GetTargets_IncludesMultipleFallbacks()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions());
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.True(targets.Count >= 3, "Should have multiple fallback targets");
        Assert.Contains("8.8.8.8", targets);
        Assert.Contains("1.1.1.1", targets);
    }

    [Fact]
    public void GetTargets_CustomTargetAddedToFront()
    {
        // Arrange - use a target not in the default list
        var options = Options.Create(new MonitorOptions { InternetTarget = "4.4.4.4" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("4.4.4.4", targets[0]);
        Assert.Contains("8.8.8.8", targets); // Default fallbacks still present
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs
SIZE: 5.99 KB
MODIFIED: 2025-12-26 12:43:57
================================================================================

using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests : IDisposable
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;
    private NetworkConfigurationService? _service;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        _service = new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
        return _service;
    }

    public void Dispose()
    {
        _service?.Dispose();
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenExplicitlyConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "10.0.0.1" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_UsesGatewayDetector()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetectFails_TriesCommonGateways()
    {
        // Arrange
        _gatewayDetector.WithGateway(null); // No auto-detected gateway
        _gatewayDetector.WithCommonGateways("192.168.0.1", "192.168.1.1", "10.0.0.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result); // First common gateway that responds
    }

    [Fact]
    public async Task GetInternetTargetAsync_ReturnsPrimaryTarget()
    {
        // Arrange - Configure the fake to use "1.1.1.1" as primary
        _internetTargetProvider.WithPrimaryTarget("1.1.1.1");
        _internetTargetProvider.WithTargets("1.1.1.1", "8.8.8.8");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { EnableFallbackTargets = false };
        var service = CreateService(options);

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenFallbackEnabled_ReturnsFirstReachable()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { EnableFallbackTargets = true };
        var service = CreateService(options);

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result); // First reachable target
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryUnreachable_UsesFallback()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        // First target fails, second succeeds
        _pingService.Reset();
        _pingService.QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));
        _pingService.QueueResult(PingResult.Succeeded("1.1.1.1", 10));
        var options = new MonitorOptions { EnableFallbackTargets = true };
        var service = CreateService(options);

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task ResultsAreCached_MultipleCallsReturnSameValue()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);
        _gatewayDetector.WithGateway("10.0.0.1"); // Change gateway
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - Should return cached value
        Assert.Equal(result1, result2);
        Assert.Equal("192.168.1.1", result2);
    }

    [Fact]
    public void Dispose_CanBeCalledMultipleTimes()
    {
        // Arrange
        var service = CreateService();

        // Act & Assert - Should not throw
        service.Dispose();
        service.Dispose();
    }

    [Fact]
    public async Task GetRouterAddressAsync_AfterDispose_ThrowsObjectDisposedException()
    {
        // Arrange
        var service = CreateService();
        service.Dispose();

        // Act & Assert
        await Assert.ThrowsAsync<ObjectDisposedException>(
            () => service.GetRouterAddressAsync(TestContext.Current.CancellationToken));
    }
}


================================================================================
FILE: src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs
SIZE: 7.87 KB
MODIFIED: 2025-12-26 12:29:22
================================================================================

using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// </summary>
public sealed class NetworkMonitorServiceTests : IDisposable
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly MonitorOptions _options;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        _options = new MonitorOptions
        {
            PingsPerCycle = 1,
            TimeoutMs = 1000,
            ExcellentLatencyMs = 20,
            GoodLatencyMs = 50
        };
    }

    public void Dispose()
    {
        _configService.Dispose();
    }

    private NetworkMonitorService CreateService(MonitorOptions? options = null)
    {
        return new NetworkMonitorService(
            _pingService,
            _configService,
            Options.Create(options ?? _options),
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenAllSucceed_ReturnsExcellentOrGood()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        // Queue successful pings with low latency
        _pingService.QueueResult(PingResult.Succeeded("192.168.1.1", 5));
        _pingService.QueueResult(PingResult.Succeeded("8.8.8.8", 10));

        var service = CreateService();

        // Act
        var status = await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(
            status.Health is NetworkHealth.Excellent or NetworkHealth.Good,
            $"Expected Excellent or Good but got {status.Health}");
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsOfflineOrDegraded()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        // Router fails, internet succeeds
        _pingService.QueueResult(PingResult.Failed("192.168.1.1", "Timeout"));
        _pingService.QueueResult(PingResult.Succeeded("8.8.8.8", 10));

        var service = CreateService();

        // Act
        var status = await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert - Router failure with internet success = Degraded
        Assert.True(
            status.Health is NetworkHealth.Offline or NetworkHealth.Degraded,
            $"Expected Offline or Degraded but got {status.Health}");
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsDegradedOrPoor()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        // Router succeeds, internet fails
        _pingService.QueueResult(PingResult.Succeeded("192.168.1.1", 5));
        _pingService.QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        var service = CreateService();

        // Act
        var status = await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert - Router OK but no internet = Poor (not Degraded)
        Assert.True(
            status.Health is NetworkHealth.Degraded or NetworkHealth.Poor,
            $"Expected Degraded or Poor but got {status.Health}");
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        // Both fail
        _pingService.QueueResult(PingResult.Failed("192.168.1.1", "Timeout"));
        _pingService.QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        var service = CreateService();

        // Act
        var status = await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouter_StillChecksInternet()
    {
        // Arrange
        _configService.WithRouterAddress(null); // No router configured
        _configService.WithInternetTarget("8.8.8.8");

        _pingService.QueueResult(PingResult.Succeeded("8.8.8.8", 10));

        var service = CreateService();

        // Act
        var status = await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert - Should still work without router
        Assert.True(status.Health >= NetworkHealth.Degraded);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenHighLatency_ReturnsDegradedOrPoor()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        // High latency (above GoodLatencyMs of 50)
        _pingService.QueueResult(PingResult.Succeeded("192.168.1.1", 5));
        _pingService.QueueResult(PingResult.Succeeded("8.8.8.8", 250));

        var service = CreateService();

        // Act
        var status = await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(
            status.Health is NetworkHealth.Degraded or NetworkHealth.Poor,
            $"Expected Degraded or Poor for high latency but got {status.Health}");
    }

    [Fact]
    public async Task CheckNetworkAsync_RaisesStatusChangedEvent()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        _pingService.QueueResult(PingResult.Succeeded("192.168.1.1", 5));
        _pingService.QueueResult(PingResult.Succeeded("8.8.8.8", 10));

        var service = CreateService();
        NetworkStatusEventArgs? eventArgs = null;
        service.StatusChanged += (_, args) => eventArgs = args;

        // Act
        await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(eventArgs);
        Assert.NotNull(eventArgs.CurrentStatus);
    }

    [Fact]
    public async Task CheckNetworkAsync_StatusChangedEvent_IncludesPreviousStatus()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        // First check - excellent
        _pingService.QueueResult(PingResult.Succeeded("192.168.1.1", 5));
        _pingService.QueueResult(PingResult.Succeeded("8.8.8.8", 10));

        // Second check - offline
        _pingService.QueueResult(PingResult.Failed("192.168.1.1", "Timeout"));
        _pingService.QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        var service = CreateService();
        var events = new List<NetworkStatusEventArgs>();
        service.StatusChanged += (_, args) => events.Add(args);

        // Act
        await service.CheckNetworkAsync(TestContext.Current.CancellationToken);
        await service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert - Should have two events, second one has previous status
        Assert.Equal(2, events.Count);
        Assert.Null(events[0].PreviousStatus); // First event has no previous
        Assert.NotNull(events[1].PreviousStatus); // Second event has previous
    }

    [Fact]
    public async Task CheckNetworkAsync_SupportsCancellation()
    {
        // Arrange
        _configService.WithRouterAddress("192.168.1.1");
        _configService.WithInternetTarget("8.8.8.8");

        var service = CreateService();
        using var cts = new CancellationTokenSource();
        cts.Cancel();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => service.CheckNetworkAsync(cts.Token));
    }
}


===============================================================================
EXPORT COMPLETED: Fri Dec 26 12:44:39 PM CST 2025
Total Files Exported: 51
Output File: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
===============================================================================
