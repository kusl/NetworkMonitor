Kushal is developing NetworkMonitor, a cross-platform .NET 10 network monitoring application that provides real-time network health status with historical data capabilities. The application monitors both local network (router) and internet connectivity, uses SQLite for persistent storage, and integrates OpenTelemetry for observability. This project demonstrates modern software architecture with dependency injection, interface-based design for testability, and follows XDG compliance for cross-platform data storage.
Key principles guiding the project include a "just works out of the box" philosophy with automatic detection of network configuration while maintaining full configurability for special requirements, minimal third-party dependencies with specific bans on packages like Moq and FluentAssertions due to licensing or maintainer concerns, and cross-platform compatibility across Windows, macOS, and Linux on both x86 and ARM architectures.
The project was developed with extensive assistance from Large Language Models, specifically Claude, and this AI collaboration is prominently featured in the project documentation. Kushal uses git for version control and prefers incremental, focused fixes over comprehensive rewrites.
Current state
The NetworkMonitor application is in a mature, functional state with comprehensive unit test coverage and automated CI/CD pipelines. The core functionality includes automatic router IP detection using system routing tables with fallback to common gateway addresses, internet connectivity monitoring with multiple fallback targets (8.8.8.8, 1.1.1.1, 9.9.9.9), threshold-based network health classification (Excellent, Good, Degraded, Poor, Offline), and persistent data storage with SQLite.
The project has resolved numerous technical challenges including concurrency issues with System.Net.NetworkInformation.Ping operations, code analysis compliance with CA rules, proper disposal patterns and resource management, and comprehensive error handling that ensures storage failures don't interrupt monitoring operations.
Tools & resources
The application is built on .NET 10 with C# using xUnit for unit testing, SQLite for data persistence, OpenTelemetry for observability and metrics, and System.Net.NetworkInformation for network operations. The project uses GitHub Actions for CI/CD with workflows that build and test across multiple platforms and create self-contained executable releases for all major desktop platforms.
Development tools include manual fakes instead of mocking frameworks for unit testing, comprehensive shell scripts for build automation and error resolution, and git-based version control with support for multiple branch strategies (master, main, develop).
Approach & patterns
Kushal follows a systematic approach to development with strong emphasis on automated testing and incremental problem-solving. When encountering build errors, he provides specific error outputs and references to current code state, preferring targeted fixes that address only the immediate issues rather than comprehensive rewrites.
The development workflow includes comprehensive unit test coverage with threshold-based testing, automated build verification after each fix, and detailed logging and error reporting in fix scripts. Code organization follows modern .NET patterns with dependency injection, async/await with proper cancellation token support, and interface-based design for testability.
Key learnings & principles
Critical insights from the development process include the importance of proper concurrency handling when using shared Ping instances (resolved by creating new instances per operation), the need for early cancellation token checks in async methods to ensure responsive cancellation, and the balance between strict code analysis rules and practical development (adjusting AnalysisLevel from "latest-all" to "latest-recommended").
The project demonstrates that automatic network configuration detection significantly improves user experience while maintaining configurability for edge cases, and that comprehensive test coverage with manual fakes provides better control and understanding than mocking frameworks.
