kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/; time bash export.sh; cd ~/src/dotnet/network-monitor/src; time dotnet --info; time dotnet format; time dotnet restore; time dotnet clean; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 36 files to export
Processing (1/36): .github/workflows/build-and-test.yml
Processing (2/36): .github/workflows/release.yml
Processing (3/36): src/Directory.Build.props
Processing (4/36): src/Directory.Packages.props
Processing (5/36): src/NetworkMonitor.Console/appsettings.json
Processing (6/36): src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
Processing (7/36): src/NetworkMonitor.Console/Program.cs
Processing (8/36): src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
Processing (9/36): src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
Processing (10/36): src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
Processing (11/36): src/NetworkMonitor.Core/Models/HistoricalData.cs
Processing (12/36): src/NetworkMonitor.Core/Models/MonitorOptions.cs
Processing (13/36): src/NetworkMonitor.Core/Models/NetworkStatus.cs
Processing (14/36): src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
Processing (15/36): src/NetworkMonitor.Core/Models/PingResult.cs
Processing (16/36): src/NetworkMonitor.Core/Models/StorageOptions.cs
Processing (17/36): src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
Processing (18/36): src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
Processing (19/36): src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
Processing (20/36): src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
Processing (21/36): src/NetworkMonitor.Core/Services/IPingService.cs
Processing (22/36): src/NetworkMonitor.Core/Services/IStatusDisplay.cs
Processing (23/36): src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
Processing (24/36): src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
Processing (25/36): src/NetworkMonitor.Core/Services/PingService.cs
Processing (26/36): src/NetworkMonitor.Core/Storage/IStorageService.cs
Processing (27/36): src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
Processing (28/36): src/NetworkMonitor.slnx
Processing (29/36): src/NetworkMonitor.Tests/Fakes/FakePingService.cs
Processing (30/36): src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
Processing (31/36): src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
Processing (32/36): src/NetworkMonitor.Tests/Fakes/NullLogger.cs
Processing (33/36): src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
Processing (34/36): src/NetworkMonitor.Tests/NetworkStatusTests.cs
Processing (35/36): src/NetworkMonitor.Tests/PingResultTests.cs
Processing (36/36): src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 36
Output file size: 0.10 MB

real	0m0.313s
user	0m0.179s
sys	0m0.201s
.NET SDK:
 Version:           10.0.101
 Commit:            fad253f51b
 Workload version:  10.0.101.1
 MSBuild version:   18.0.6+fad253f51

Runtime Environment:
 OS Name:     fedora
 OS Version:  43
 OS Platform: Linux
 RID:         fedora.43-x64
 Base Path:   /usr/lib64/dotnet/sdk/10.0.101/

.NET workloads installed:
 [android]
   Installation Source: SDK 10.0.100
   Manifest Version:    36.1.2/10.0.100
   Manifest Path:       /home/kushal/.dotnet/sdk-manifests/10.0.100/microsoft.net.sdk.android/36.1.2/WorkloadManifest.json
   Install Type:        FileBased

Configured to use workload sets when installing new manifests.

Host:
  Version:      10.0.1
  Architecture: x64
  Commit:       fad253f51b

.NET SDKs installed:
  10.0.101 [/usr/lib64/dotnet/sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]

Other architectures found:
  None

Environment variables:
  DOTNET_BUNDLE_EXTRACT_BASE_DIR           [/home/kushal/.cache/dotnet_bundle_extract]
  DOTNET_ROOT                              [/usr/lib64/dotnet]

global.json file:
  Not found

Learn more:
  https://aka.ms/dotnet/info

Download .NET:
  https://aka.ms/dotnet/download

real	0m0.143s
user	0m0.115s
sys	0m0.027s

real	0m5.330s
user	0m6.750s
sys	0m0.636s
Restore complete (0.5s)

Build succeeded in 0.6s

real	0m0.704s
user	0m0.702s
sys	0m0.126s

Build succeeded in 0.4s

real	0m0.569s
user	0m0.587s
sys	0m0.106s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 succeeded (0.3s) → NetworkMonitor.Core/bin/Debug/net10.0/NetworkMonitor.Core.dll
  NetworkMonitor.Console net10.0 succeeded (0.3s) → NetworkMonitor.Console/bin/Debug/net10.0/NetworkMonitor.Console.dll
  NetworkMonitor.Tests net10.0 succeeded (0.4s) → NetworkMonitor.Tests/bin/Debug/net10.0/NetworkMonitor.Tests.dll

Build succeeded in 1.2s

real	0m1.378s
user	0m1.218s
sys	0m0.246s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 succeeded (0.1s) → NetworkMonitor.Core/bin/Debug/net10.0/NetworkMonitor.Core.dll
  NetworkMonitor.Tests net10.0 succeeded (0.1s) → NetworkMonitor.Tests/bin/Debug/net10.0/NetworkMonitor.Tests.dll
[xUnit.net 00:00:00.00] xUnit.net VSTest Adapter v3.1.5+1b188a7b0a (64-bit .NET 10.0.1)
[xUnit.net 00:00:00.14]   Discovering: NetworkMonitor.Tests
[xUnit.net 00:00:00.31]   Discovered:  NetworkMonitor.Tests
[xUnit.net 00:00:00.46]   Starting:    NetworkMonitor.Tests
[xUnit.net 00:00:00.57]   Finished:    NetworkMonitor.Tests (ID = '2e8f57cd5826539fc7a5cd3a97d27721fcb9a15ff7c496b1112166f6757858fe')
  NetworkMonitor.Tests test net10.0 succeeded (1.1s)

Test summary: total: 17, failed: 0, succeeded: 17, skipped: 0, duration: 1.1s
Build succeeded in 1.9s

real	0m2.026s
user	0m1.002s
sys	0m0.236s
Restore complete (0.4s)

Build succeeded in 0.5s
Project 'NetworkMonitor.Console' has the following package references
   [net10.0]: 
   Top-level Package                            Requested   Resolved
   > Microsoft.Extensions.Hosting               10.0.1      10.0.1  
   > OpenTelemetry.Exporter.Console             1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting           1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime      1.14.0      1.14.0  

Project 'NetworkMonitor.Core' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Data.Sqlite                          10.0.1      10.0.1  
   > Microsoft.Extensions.Hosting                   10.0.1      10.0.1  
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.Extensions.Options                   10.0.1      10.0.1  
   > OpenTelemetry                                  1.14.0      1.14.0  
   > OpenTelemetry.Exporter.Console                 1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting               1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime          1.14.0      1.14.0  

Project 'NetworkMonitor.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.NET.Test.Sdk                         18.0.1      18.0.1  
   > xunit.runner.visualstudio                      3.1.5       3.1.5   
   > xunit.v3                                       3.2.1       3.2.1   


real	0m1.342s
user	0m1.342s
sys	0m0.245s
Restore complete (0.4s)

Build succeeded in 0.5s

The following sources were used:
   https://api.nuget.org/v3/index.json

The given project `NetworkMonitor.Console` has no updates given the current sources.
The given project `NetworkMonitor.Core` has no updates given the current sources.
The given project `NetworkMonitor.Tests` has no updates given the current sources.

real	0m1.564s
user	0m1.560s
sys	0m0.245s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
#!/bin/bash
# =============================================================================
# Add Gateway Auto-Detection and Internet Target Fallback
# =============================================================================
# This script adds:
# 1. IGatewayDetector interface and cross-platform implementation
# 2. Auto-detection of default gateway (router) IP address
# 3. Fallback internet targets (1.1.1.1 if 8.8.8.8 is unavailable)
# 4. MonitorOptions changes to support "auto" detection
# 5. Comprehensive unit tests for all new functionality
#
# Philosophy: Make things work out of the box for most users while still
# allowing full configurability for those with special network setups.
# =============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in the src directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

log_info "Adding gateway auto-detection and internet target fallback..."
log_info "Working directory: $(pwd)"

# =============================================================================
# 1. Create IGatewayDetector interface
# =============================================================================
log_info "Creating IGatewayDetector interface..."

cat > NetworkMonitor.Core/Services/IGatewayDetector.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Detects the default gateway (router) IP address.
/// </summary>
/// <remarks>
/// The default gateway is advertised by DHCP and can be read from the OS
/// network configuration. This allows the application to work "out of the box"
/// without requiring users to manually configure their router IP.
/// </remarks>
public interface IGatewayDetector
{
    /// <summary>
    /// Attempts to detect the default gateway IP address.
    /// </summary>
    /// <returns>
    /// The IP address of the default gateway, or null if it cannot be detected.
    /// </returns>
    /// <remarks>
    /// On most systems, this returns the router IP (e.g., 192.168.1.1, 192.168.0.1, 10.0.0.1).
    /// Returns null if:
    /// - No network interfaces are available
    /// - No default gateway is configured (e.g., disconnected)
    /// - The system doesn't support gateway detection
    /// </remarks>
    string? DetectDefaultGateway();

    /// <summary>
    /// Gets a list of common gateway addresses to try as fallbacks.
    /// </summary>
    /// <remarks>
    /// If auto-detection fails, these are the most common gateway addresses
    /// used by consumer routers. The list is ordered by popularity.
    /// </remarks>
    IReadOnlyList<string> GetCommonGatewayAddresses();
}
EOF

# =============================================================================
# 2. Create GatewayDetector implementation
# =============================================================================
log_info "Creating GatewayDetector implementation..."

cat > NetworkMonitor.Core/Services/GatewayDetector.cs << 'EOF'
using System.Net.NetworkInformation;
using System.Net.Sockets;
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform default gateway detector using System.Net.NetworkInformation.
/// </summary>
/// <remarks>
/// This implementation reads the default gateway from the OS routing table,
/// which is populated by DHCP or static configuration. Works on Windows,
/// macOS, and Linux without external dependencies.
/// </remarks>
public sealed class GatewayDetector : IGatewayDetector
{
    private readonly ILogger<GatewayDetector> _logger;

    /// <summary>
    /// Common gateway addresses used by consumer routers, ordered by popularity.
    /// These are used as fallbacks if auto-detection fails.
    /// </summary>
    private static readonly string[] CommonGateways =
    [
        "192.168.1.1",   // Most common (Linksys, TP-Link, many ISP routers)
        "192.168.0.1",   // Second most common (D-Link, Netgear, some ISPs)
        "10.0.0.1",      // Apple AirPort, some enterprise networks
        "192.168.2.1",   // Belkin, SMC
        "192.168.1.254", // Some ISP-provided routers (BT, etc.)
        "192.168.0.254", // Some ISP-provided routers
        "10.0.1.1",      // Apple AirPort alternate
        "192.168.10.1",  // Some business routers
        "192.168.100.1", // Some cable modems
        "172.16.0.1",    // Private network range (less common for home)
    ];

    public GatewayDetector(ILogger<GatewayDetector> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public string? DetectDefaultGateway()
    {
        try
        {
            _logger.LogDebug("Attempting to detect default gateway...");

            // Get all network interfaces that are up and have IPv4 connectivity
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(nic => nic.OperationalStatus == OperationalStatus.Up)
                .Where(nic => nic.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                .Where(nic => nic.Supports(NetworkInterfaceComponent.IPv4))
                .ToList();

            _logger.LogDebug("Found {Count} active network interfaces", interfaces.Count);

            foreach (var nic in interfaces)
            {
                var ipProps = nic.GetIPProperties();
                var gateways = ipProps.GatewayAddresses;

                foreach (var gateway in gateways)
                {
                    // Skip IPv6 gateways and 0.0.0.0 (no gateway)
                    if (gateway.Address.AddressFamily != AddressFamily.InterNetwork)
                        continue;

                    var address = gateway.Address.ToString();
                    if (address == "0.0.0.0")
                        continue;

                    _logger.LogInformation(
                        "Detected default gateway: {Gateway} on interface {Interface}",
                        address, nic.Name);

                    return address;
                }
            }

            _logger.LogWarning("No default gateway found on any network interface");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to detect default gateway");
            return null;
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetCommonGatewayAddresses() => CommonGateways;
}
EOF

# =============================================================================
# 3. Create IInternetTargetProvider interface and implementation
# =============================================================================
log_info "Creating IInternetTargetProvider interface..."

cat > NetworkMonitor.Core/Services/IInternetTargetProvider.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with fallback support.
/// </summary>
/// <remarks>
/// Not all networks can reach all DNS providers. For example:
/// - Some countries block Google DNS (8.8.8.8)
/// - Some corporate networks only allow specific DNS servers
/// - Some ISPs intercept DNS traffic
/// 
/// This provider allows testing multiple targets and using the first
/// one that responds, ensuring the application works in various
/// network environments.
/// </remarks>
public interface IInternetTargetProvider
{
    /// <summary>
    /// Gets the ordered list of internet targets to try.
    /// </summary>
    /// <remarks>
    /// The first reachable target will be used for monitoring.
    /// Targets are ordered by reliability and global availability.
    /// </remarks>
    IReadOnlyList<string> GetTargets();

    /// <summary>
    /// Gets the primary (preferred) target.
    /// </summary>
    string PrimaryTarget { get; }
}
EOF

log_info "Creating InternetTargetProvider implementation..."

cat > NetworkMonitor.Core/Services/InternetTargetProvider.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with automatic fallback.
/// </summary>
public sealed class InternetTargetProvider : IInternetTargetProvider
{
    private readonly ILogger<InternetTargetProvider> _logger;
    private readonly MonitorOptions _options;

    /// <summary>
    /// Well-known, highly available DNS servers that can be used for
    /// connectivity testing. Ordered by global reliability.
    /// </summary>
    private static readonly string[] DefaultTargets =
    [
        "8.8.8.8",       // Google Public DNS (primary)
        "1.1.1.1",       // Cloudflare DNS (very fast, privacy-focused)
        "8.8.4.4",       // Google Public DNS (secondary)
        "1.0.0.1",       // Cloudflare DNS (secondary)
        "9.9.9.9",       // Quad9 DNS (security-focused)
        "208.67.222.222", // OpenDNS (Cisco)
        "208.67.220.220", // OpenDNS (secondary)
    ];

    public InternetTargetProvider(
        IOptions<MonitorOptions> options,
        ILogger<InternetTargetProvider> logger)
    {
        _options = options.Value;
        _logger = logger;

        _logger.LogDebug(
            "Internet target provider initialized with primary target: {Target}",
            PrimaryTarget);
    }

    /// <inheritdoc />
    public string PrimaryTarget => _options.InternetTarget;

    /// <inheritdoc />
    public IReadOnlyList<string> GetTargets()
    {
        // If user specified a custom target, put it first
        if (!string.IsNullOrWhiteSpace(_options.InternetTarget) &&
            !DefaultTargets.Contains(_options.InternetTarget, StringComparer.OrdinalIgnoreCase))
        {
            var customList = new List<string> { _options.InternetTarget };
            customList.AddRange(DefaultTargets);
            return customList;
        }

        // Reorder default list to put configured target first
        var targets = new List<string>(DefaultTargets);
        var configuredIndex = targets.FindIndex(
            t => t.Equals(_options.InternetTarget, StringComparison.OrdinalIgnoreCase));

        if (configuredIndex > 0)
        {
            var configured = targets[configuredIndex];
            targets.RemoveAt(configuredIndex);
            targets.Insert(0, configured);
        }

        return targets;
    }
}
EOF

# =============================================================================
# 4. Update MonitorOptions to support "auto" detection
# =============================================================================
log_info "Updating MonitorOptions..."

cat > NetworkMonitor.Core/Models/MonitorOptions.cs << 'EOF'
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration options for the network monitor.
/// Bound from appsettings.json or environment variables.
/// </summary>
public sealed class MonitorOptions
{
    /// <summary>
    /// Configuration section name in appsettings.json
    /// </summary>
    public const string SectionName = "NetworkMonitor";

    /// <summary>
    /// Special value indicating auto-detection should be used.
    /// </summary>
    public const string AutoDetect = "auto";

    /// <summary>
    /// Router/gateway IP address to ping for local network health.
    /// </summary>
    /// <remarks>
    /// Set to "auto" (default) to automatically detect the default gateway.
    /// The gateway is advertised by DHCP and can be read from the OS.
    /// 
    /// If auto-detection fails, common gateway addresses will be tried:
    /// 192.168.1.1, 192.168.0.1, 10.0.0.1, etc.
    /// 
    /// Set to a specific IP address to override auto-detection.
    /// </remarks>
    public string RouterAddress { get; set; } = AutoDetect;

    /// <summary>
    /// Internet target to ping for WAN connectivity.
    /// </summary>
    /// <remarks>
    /// Default: 8.8.8.8 (Google DNS - highly reliable)
    /// 
    /// If this target is unreachable, fallback targets will be tried:
    /// 1.1.1.1 (Cloudflare), 9.9.9.9 (Quad9), etc.
    /// 
    /// This is useful for networks that block specific DNS providers.
    /// </remarks>
    public string InternetTarget { get; set; } = "8.8.8.8";

    /// <summary>
    /// Timeout for each ping in milliseconds.
    /// Default: 3000ms (3 seconds)
    /// </summary>
    public int TimeoutMs { get; set; } = 3000;

    /// <summary>
    /// Interval between monitoring cycles in milliseconds.
    /// Default: 5000ms (5 seconds)
    /// </summary>
    public int IntervalMs { get; set; } = 5000;

    /// <summary>
    /// Number of pings per target per cycle.
    /// Default: 3 (for statistical significance)
    /// </summary>
    public int PingsPerCycle { get; set; } = 3;

    /// <summary>
    /// Latency threshold (ms) below which is considered "excellent".
    /// Default: 20ms
    /// </summary>
    public int ExcellentLatencyMs { get; set; } = 20;

    /// <summary>
    /// Latency threshold (ms) below which is considered "good".
    /// Default: 100ms
    /// </summary>
    public int GoodLatencyMs { get; set; } = 100;

    /// <summary>
    /// Packet loss percentage above which network is "degraded".
    /// Default: 10%
    /// </summary>
    public int DegradedPacketLossPercent { get; set; } = 10;

    /// <summary>
    /// Whether to use fallback targets if primary fails.
    /// Default: true
    /// </summary>
    public bool EnableFallbackTargets { get; set; } = true;

    /// <summary>
    /// Checks if router address should be auto-detected.
    /// </summary>
    public bool IsRouterAutoDetect =>
        string.IsNullOrWhiteSpace(RouterAddress) ||
        RouterAddress.Equals(AutoDetect, StringComparison.OrdinalIgnoreCase);
}
EOF

# =============================================================================
# 5. Create NetworkConfigurationService to handle detection and fallbacks
# =============================================================================
log_info "Creating NetworkConfigurationService..."

cat > NetworkMonitor.Core/Services/NetworkConfigurationService.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    /// <inheritdoc />
    public async Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized)
                return;

            _logger.LogInformation("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);
            if (_resolvedRouterAddress != null)
            {
                _logger.LogInformation("Router address resolved to: {Address}", _resolvedRouterAddress);
            }
            else
            {
                _logger.LogWarning("Could not resolve router address - router monitoring will be skipped");
            }

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);
            _logger.LogInformation("Internet target resolved to: {Target}", _resolvedInternetTarget);

            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (!_initialized)
        {
            await InitializeAsync(cancellationToken);
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address, use it directly
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        // Try auto-detection first
        _logger.LogDebug("Attempting router auto-detection...");
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (detected != null)
        {
            // Verify it's reachable
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogDebug("Auto-detected gateway {Address} is reachable", detected);
                return detected;
            }
            _logger.LogWarning("Auto-detected gateway {Address} is not reachable", detected);
        }

        // Fall back to common addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var address in _gatewayDetector.GetCommonGatewayAddresses())
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(address, cancellationToken))
            {
                _logger.LogInformation("Found reachable gateway at common address: {Address}", address);
                return address;
            }
        }

        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        // If fallback is disabled, just use the primary
        if (!_options.EnableFallbackTargets)
        {
            _logger.LogDebug("Fallback targets disabled, using primary: {Target}", targets[0]);
            return targets[0];
        }

        // Try each target until one responds
        foreach (var target in targets)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(target, cancellationToken))
            {
                if (target != targets[0])
                {
                    _logger.LogInformation(
                        "Primary target {Primary} unreachable, using fallback: {Fallback}",
                        targets[0], target);
                }
                return target;
            }

            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // If nothing is reachable, use the primary anyway (might come back online)
        _logger.LogWarning(
            "No internet targets are reachable, defaulting to: {Target}",
            targets[0]);
        return targets[0];
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(
                target,
                _options.TimeoutMs,
                cancellationToken);
            return result.Success;
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Ping to {Target} failed", target);
            return false;
        }
    }
}
EOF

# =============================================================================
# 6. Create INetworkConfigurationService interface
# =============================================================================
log_info "Creating INetworkConfigurationService interface..."

cat > NetworkMonitor.Core/Services/INetworkConfigurationService.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides resolved network configuration for monitoring.
/// </summary>
/// <remarks>
/// This service handles the complexity of:
/// - Auto-detecting the default gateway
/// - Falling back to common gateway addresses
/// - Finding a reachable internet target
/// - Caching resolved addresses
/// </remarks>
public interface INetworkConfigurationService
{
    /// <summary>
    /// Gets the resolved router/gateway address to monitor.
    /// </summary>
    /// <returns>
    /// The router IP address, or null if no router could be found.
    /// When null, router monitoring should be skipped.
    /// </returns>
    Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the resolved internet target to monitor.
    /// </summary>
    /// <returns>
    /// The internet target IP address. Always returns a value,
    /// falling back to the configured default if nothing is reachable.
    /// </returns>
    Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Initializes the service by detecting and verifying targets.
    /// </summary>
    /// <remarks>
    /// This is called automatically on first access, but can be called
    /// explicitly during startup for eager initialization.
    /// </remarks>
    Task InitializeAsync(CancellationToken cancellationToken = default);
}
EOF

# =============================================================================
# 7. Update NetworkMonitorService to use configuration service
# =============================================================================
log_info "Updating NetworkMonitorService..."

cat > NetworkMonitor.Core/Services/NetworkMonitorService.cs << 'EOF'
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (routerAddress != null)
        {
            var routerResults = await _pingService.PingMultipleAsync(
                routerAddress,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            routerResult = AggregateResults(routerResults);

            if (routerResult.Success && routerResult.RoundtripTimeMs.HasValue)
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }

            activity?.SetTag("router.success", routerResult.Success);
            activity?.SetTag("router.latency_ms", routerResult.RoundtripTimeMs);
        }
        else
        {
            _logger.LogDebug("No router address configured, skipping router ping");
        }

        // Ping internet
        var internetResults = await _pingService.PingMultipleAsync(
            internetTarget,
            _options.PingsPerCycle,
            _options.TimeoutMs,
            cancellationToken);

        var internetResult = AggregateResults(internetResults);

        if (internetResult.Success && internetResult.RoundtripTimeMs.HasValue)
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        activity?.SetTag("internet.success", internetResult.Success);
        activity?.SetTag("internet.latency_ms", internetResult.RoundtripTimeMs);

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());

        // Fire event if status changed
        if (_lastStatus == null || _lastStatus.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return average latency of successful pings
        var avgLatency = (long)successful.Average(r => r.RoundtripTimeMs ?? 0);
        return PingResult.Succeeded(target, avgLatency);
    }

    private (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        return internetLatency switch
        {
            <= 50 when routerLatency <= 10 => (NetworkHealth.Excellent, "Network is excellent"),
            <= 100 => (NetworkHealth.Good, "Network is good"),
            <= 200 => (NetworkHealth.Degraded, "Network is degraded (high latency)"),
            _ => (NetworkHealth.Poor, "Network is poor (very high latency)")
        };
    }
}
EOF

# =============================================================================
# 8. Update ServiceCollectionExtensions to register new services
# =============================================================================
log_info "Updating ServiceCollectionExtensions..."

cat > NetworkMonitor.Core/ServiceCollectionExtensions.cs << 'EOF'
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NetworkMonitor.Core.Exporters;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Core.Storage;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NetworkMonitor.Core;

/// <summary>
/// Extension methods for registering Network Monitor services.
/// Encapsulates all the DI wiring in one place.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers all Network Monitor services with the DI container.
    /// </summary>
    public static IServiceCollection AddNetworkMonitor(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Bind options from configuration
        services.Configure<MonitorOptions>(
            configuration.GetSection(MonitorOptions.SectionName));
        services.Configure<StorageOptions>(
            configuration.GetSection(StorageOptions.SectionName));

        // Register core services
        services.AddSingleton<IPingService, PingService>();
        services.AddSingleton<IGatewayDetector, GatewayDetector>();
        services.AddSingleton<IInternetTargetProvider, InternetTargetProvider>();
        services.AddSingleton<INetworkConfigurationService, NetworkConfigurationService>();
        services.AddSingleton<INetworkMonitorService, NetworkMonitorService>();
        services.AddSingleton<IStatusDisplay, ConsoleStatusDisplay>();
        services.AddSingleton<IStorageService, SqliteStorageService>();

        // Register background service
        services.AddHostedService<MonitorBackgroundService>();

        return services;
    }

    /// <summary>
    /// Adds OpenTelemetry metrics with file and console export.
    /// </summary>
    public static IServiceCollection AddNetworkMonitorTelemetry(
        this IServiceCollection services,
        FileExporterOptions? fileOptions = null)
    {
        fileOptions ??= FileExporterOptions.Default;

        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource
                .AddService(
                    serviceName: "NetworkMonitor",
                    serviceVersion: "1.0.0"))
            .WithMetrics(metrics =>
            {
                metrics
                    .AddMeter("NetworkMonitor.Core")
                    .AddRuntimeInstrumentation()
                    .AddConsoleExporter()
                    .AddFileExporter(fileOptions);
            });

        return services;
    }
}
EOF

# =============================================================================
# 9. Update appsettings.json to use auto-detection by default
# =============================================================================
log_info "Updating appsettings.json..."

cat > NetworkMonitor.Console/appsettings.json << 'EOF'
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "NetworkMonitor": "Information"
    }
  },
  "NetworkMonitor": {
    "RouterAddress": "auto",
    "InternetTarget": "8.8.8.8",
    "TimeoutMs": 3000,
    "IntervalMs": 5000,
    "PingsPerCycle": 3,
    "ExcellentLatencyMs": 20,
    "GoodLatencyMs": 100,
    "DegradedPacketLossPercent": 10,
    "EnableFallbackTargets": true
  },
  "Storage": {
    "RetentionDays": 30,
    "DatabasePath": ""
  }
}
EOF

# =============================================================================
# 10. Create unit tests for gateway detection
# =============================================================================
log_info "Creating unit tests..."

mkdir -p NetworkMonitor.Tests/Services

# Create fake gateway detector for tests
cat > NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake gateway detector for testing.
/// </summary>
public sealed class FakeGatewayDetector : IGatewayDetector
{
    private string? _gatewayToReturn;
    private readonly List<string> _commonGateways = ["192.168.1.1", "192.168.0.1", "10.0.0.1"];

    /// <summary>
    /// Configures the detector to return a specific gateway.
    /// </summary>
    public FakeGatewayDetector WithGateway(string? gateway)
    {
        _gatewayToReturn = gateway;
        return this;
    }

    /// <summary>
    /// Configures the detector to return null (no gateway found).
    /// </summary>
    public FakeGatewayDetector WithNoGateway()
    {
        _gatewayToReturn = null;
        return this;
    }

    /// <summary>
    /// Configures the common gateways list.
    /// </summary>
    public FakeGatewayDetector WithCommonGateways(params string[] gateways)
    {
        _commonGateways.Clear();
        _commonGateways.AddRange(gateways);
        return this;
    }

    public string? DetectDefaultGateway() => _gatewayToReturn;

    public IReadOnlyList<string> GetCommonGatewayAddresses() => _commonGateways;
}
EOF

# Create fake internet target provider
cat > NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private readonly List<string> _targets = ["8.8.8.8", "1.1.1.1"];

    public string PrimaryTarget => _targets[0];

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets.Clear();
        _targets.AddRange(targets);
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}
EOF

# Create fake network configuration service
cat > NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public Task InitializeAsync(CancellationToken cancellationToken = default)
        => Task.CompletedTask;
}
EOF

# Create GatewayDetector tests
cat > NetworkMonitor.Tests/Services/GatewayDetectorTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for GatewayDetector.
/// Note: These tests run against the real network stack, so results
/// depend on the test environment. We test the interface contract.
/// </summary>
public sealed class GatewayDetectorTests
{
    private readonly GatewayDetector _detector;

    public GatewayDetectorTests()
    {
        _detector = new GatewayDetector(NullLogger<GatewayDetector>.Instance);
    }

    [Fact]
    public void DetectDefaultGateway_ReturnsValidIpOrNull()
    {
        // Act
        var result = _detector.DetectDefaultGateway();

        // Assert - should be null or a valid IP
        if (result != null)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", result);
        }
    }

    [Fact]
    public void GetCommonGatewayAddresses_ReturnsNonEmptyList()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        Assert.NotEmpty(addresses);
        Assert.Contains("192.168.1.1", addresses);
        Assert.Contains("192.168.0.1", addresses);
        Assert.Contains("10.0.0.1", addresses);
    }

    [Fact]
    public void GetCommonGatewayAddresses_AllAreValidIpAddresses()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        foreach (var address in addresses)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", address);
        }
    }
}
EOF

# Create InternetTargetProvider tests
cat > NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for InternetTargetProvider.
/// </summary>
public sealed class InternetTargetProviderTests
{
    [Fact]
    public void PrimaryTarget_ReturnsConfiguredTarget()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act & Assert
        Assert.Equal("1.1.1.1", provider.PrimaryTarget);
    }

    [Fact]
    public void GetTargets_ReturnsConfiguredTargetFirst()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("1.1.1.1", targets[0]);
    }

    [Fact]
    public void GetTargets_IncludesMultipleFallbacks()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions());
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.True(targets.Count >= 3, "Should have multiple fallback targets");
        Assert.Contains("8.8.8.8", targets);
        Assert.Contains("1.1.1.1", targets);
    }

    [Fact]
    public void GetTargets_CustomTargetAddedToFront()
    {
        // Arrange - use a target not in the default list
        var options = Options.Create(new MonitorOptions { InternetTarget = "4.4.4.4" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("4.4.4.4", targets[0]);
        Assert.Contains("8.8.8.8", targets); // Default fallbacks still present
    }
}
EOF

# Create NetworkConfigurationService tests
cat > NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        return new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_ReturnsDetectedGateway()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254");
        _pingService.AlwaysSucceed(5);
        var service = CreateService(new MonitorOptions { RouterAddress = "auto" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.254", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254"); // Should be ignored
        var service = CreateService(new MonitorOptions { RouterAddress = "10.0.0.1" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenDetectionFails_TriesCommonAddresses()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1", "192.168.0.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("192.168.0.1", 5));
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenNothingReachable_ReturnsNull()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryReachable_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(10);
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryUnreachable_ReturnsFallback()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("1.1.1.1", 10));
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenFallbackDisabled_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService(new MonitorOptions { EnableFallbackTargets = false });

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result); // Returns primary even if unreachable
    }

    [Fact]
    public async Task InitializeAsync_CachesResults()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var service = CreateService();

        // Act
        await service.InitializeAsync(TestContext.Current.CancellationToken);
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Change the detector (shouldn't affect cached result)
        _gatewayDetector.WithGateway("10.0.0.1");
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - both should return cached value
        Assert.Equal("192.168.1.1", result1);
        Assert.Equal("192.168.1.1", result2);
    }
}
EOF

# Update NetworkMonitorServiceTests to use new configuration service
cat > NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            _configService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellent()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Excellent, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsDegradedOrPoor()
    {
        // Arrange - router fails, internet succeeds
        _configService.WithRouterAddress("192.168.1.1");
        _pingService
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Degraded, status.Health);
        Assert.False(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoor()
    {
        // Arrange - router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.False(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("Network unreachable");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouterConfigured_SkipsRouterPing()
    {
        // Arrange
        _configService.WithRouterAddress(null);
        _pingService.AlwaysSucceed(20);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(status.RouterResult);
        Assert.NotNull(status.InternetResult);
        Assert.True(status.InternetResult.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegraded()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatus? receivedStatus = null;
        _service.StatusChanged += (_, e) => receivedStatus = e.CurrentStatus;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedStatus);
        Assert.Equal(NetworkHealth.Excellent, receivedStatus.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }
}
EOF

# Create MonitorOptions tests
cat > NetworkMonitor.Tests/Models/MonitorOptionsTests.cs << 'EOF'
using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for MonitorOptions.
/// </summary>
public sealed class MonitorOptionsTests
{
    [Fact]
    public void IsRouterAutoDetect_WhenAuto_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "auto" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenAutoUppercase_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "AUTO" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenEmpty_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenNull_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = null! };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenIpAddress_ReturnsFalse()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "192.168.1.1" };

        // Act & Assert
        Assert.False(options.IsRouterAutoDetect);
    }

    [Fact]
    public void DefaultRouterAddress_IsAuto()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.Equal("auto", options.RouterAddress);
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void EnableFallbackTargets_DefaultsToTrue()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.True(options.EnableFallbackTargets);
    }
}
EOF

# Create Models directory in tests if needed
mkdir -p NetworkMonitor.Tests/Models

# =============================================================================
# 11. Update FakePingService with additional helper methods
# =============================================================================
log_info "Updating FakePingService..."

cat > NetworkMonitor.Tests/Fakes/FakePingService.cs << 'EOF'
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake ping service for testing.
/// Allows controlled responses without actual network calls.
/// </summary>
public sealed class FakePingService : IPingService
{
    private readonly Queue<PingResult> _queuedResults = new();
    private Func<string, PingResult>? _resultFactory;

    /// <summary>
    /// Queues a specific result to be returned.
    /// Results are dequeued in FIFO order.
    /// </summary>
    public FakePingService QueueResult(PingResult result)
    {
        _queuedResults.Enqueue(result);
        return this;
    }

    /// <summary>
    /// Configures the service to always succeed with the given latency.
    /// </summary>
    public FakePingService AlwaysSucceed(long latencyMs = 10)
    {
        _resultFactory = target => PingResult.Succeeded(target, latencyMs);
        return this;
    }

    /// <summary>
    /// Configures the service to always fail with the given error.
    /// </summary>
    public FakePingService AlwaysFail(string error = "Timeout")
    {
        _resultFactory = target => PingResult.Failed(target, error);
        return this;
    }

    /// <summary>
    /// Configures a custom factory for generating results.
    /// </summary>
    public FakePingService WithFactory(Func<string, PingResult> factory)
    {
        _resultFactory = factory;
        return this;
    }

    /// <summary>
    /// Clears all queued results and resets the factory.
    /// </summary>
    public FakePingService Reset()
    {
        _queuedResults.Clear();
        _resultFactory = null;
        return this;
    }

    public Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (_queuedResults.Count > 0)
        {
            return Task.FromResult(_queuedResults.Dequeue());
        }

        if (_resultFactory != null)
        {
            return Task.FromResult(_resultFactory(target));
        }

        // Default: succeed with 10ms latency
        return Task.FromResult(PingResult.Succeeded(target, 10));
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            results.Add(await PingAsync(target, timeoutMs, cancellationToken));
        }

        return results;
    }
}
EOF

# =============================================================================
# 12. Update NullLogger helper
# =============================================================================
log_info "Updating NullLogger helper..."

cat > NetworkMonitor.Tests/Fakes/NullLogger.cs << 'EOF'
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Null logger implementation for tests.
/// </summary>
public sealed class NullLogger<T> : ILogger<T>
{
    public static readonly NullLogger<T> Instance = new();

    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => null;

    public bool IsEnabled(LogLevel logLevel) => false;

    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        // Intentionally empty
    }
}
EOF

# =============================================================================
# Completion
# =============================================================================
log_success "=========================================="
log_success "Gateway detection and fallback support added!"
log_success "=========================================="
echo ""
log_info "Changes made:"
echo "  1. Added IGatewayDetector interface and GatewayDetector implementation"
echo "  2. Added IInternetTargetProvider interface and implementation"
echo "  3. Added INetworkConfigurationService for resolving targets"
echo "  4. Updated MonitorOptions to support 'auto' detection (now the default)"
echo "  5. Updated NetworkMonitorService to use configuration service"
echo "  6. Updated ServiceCollectionExtensions to register new services"
echo "  7. Updated appsettings.json with new defaults"
echo "  8. Added comprehensive unit tests for all new functionality"
echo ""
log_info "How it works:"
echo "  - Router address defaults to 'auto' which detects the default gateway"
echo "  - If detection fails, common addresses are tried (192.168.1.1, etc.)"
echo "  - Internet target defaults to 8.8.8.8 with fallbacks (1.1.1.1, etc.)"
echo "  - All settings can still be manually configured in appsettings.json"
echo ""
log_info "Next steps:"
echo "  1. dotnet build"
echo "  2. dotnet test"
echo "  3. dotnet run --project NetworkMonitor.Console"
echo ""
[INFO] Adding gateway auto-detection and internet target fallback...
[INFO] Working directory: /home/kushal/src/dotnet/network-monitor/src
[INFO] Creating IGatewayDetector interface...
[INFO] Creating GatewayDetector implementation...
[INFO] Creating IInternetTargetProvider interface...
[INFO] Creating InternetTargetProvider implementation...
[INFO] Updating MonitorOptions...
[INFO] Creating NetworkConfigurationService...
[INFO] Creating INetworkConfigurationService interface...
[INFO] Updating NetworkMonitorService...
[INFO] Updating ServiceCollectionExtensions...
[INFO] Updating appsettings.json...
[INFO] Creating unit tests...
generate-network-monitor.sh: line 1574: NetworkMonitor.Tests/Models/MonitorOptionsTests.cs: No such file or directory

real	0m0.025s
user	0m0.009s
sys	0m0.009s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
#!/bin/bash
# =============================================================================
# Add Gateway Auto-Detection and Internet Target Fallback
# =============================================================================
# This script adds:
# 1. IGatewayDetector interface and cross-platform implementation
# 2. Auto-detection of default gateway (router) IP address
# 3. Fallback internet targets (1.1.1.1 if 8.8.8.8 is unavailable)
# 4. MonitorOptions changes to support "auto" detection
# 5. Comprehensive unit tests for all new functionality
#
# Philosophy: Make things work out of the box for most users while still
# allowing full configurability for those with special network setups.
# =============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in the src directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

log_info "Adding gateway auto-detection and internet target fallback..."
log_info "Working directory: $(pwd)"

# =============================================================================
# 1. Create IGatewayDetector interface
# =============================================================================
log_info "Creating IGatewayDetector interface..."

cat > NetworkMonitor.Core/Services/IGatewayDetector.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Detects the default gateway (router) IP address.
/// </summary>
/// <remarks>
/// The default gateway is advertised by DHCP and can be read from the OS
/// network configuration. This allows the application to work "out of the box"
/// without requiring users to manually configure their router IP.
/// </remarks>
public interface IGatewayDetector
{
    /// <summary>
    /// Attempts to detect the default gateway IP address.
    /// </summary>
    /// <returns>
    /// The IP address of the default gateway, or null if it cannot be detected.
    /// </returns>
    /// <remarks>
    /// On most systems, this returns the router IP (e.g., 192.168.1.1, 192.168.0.1, 10.0.0.1).
    /// Returns null if:
    /// - No network interfaces are available
    /// - No default gateway is configured (e.g., disconnected)
    /// - The system doesn't support gateway detection
    /// </remarks>
    string? DetectDefaultGateway();

    /// <summary>
    /// Gets a list of common gateway addresses to try as fallbacks.
    /// </summary>
    /// <remarks>
    /// If auto-detection fails, these are the most common gateway addresses
    /// used by consumer routers. The list is ordered by popularity.
    /// </remarks>
    IReadOnlyList<string> GetCommonGatewayAddresses();
}
EOF

# =============================================================================
# 2. Create GatewayDetector implementation
# =============================================================================
log_info "Creating GatewayDetector implementation..."

cat > NetworkMonitor.Core/Services/GatewayDetector.cs << 'EOF'
using System.Net.NetworkInformation;
using System.Net.Sockets;
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform default gateway detector using System.Net.NetworkInformation.
/// </summary>
/// <remarks>
/// This implementation reads the default gateway from the OS routing table,
/// which is populated by DHCP or static configuration. Works on Windows,
/// macOS, and Linux without external dependencies.
/// </remarks>
public sealed class GatewayDetector : IGatewayDetector
{
    private readonly ILogger<GatewayDetector> _logger;

    /// <summary>
    /// Common gateway addresses used by consumer routers, ordered by popularity.
    /// These are used as fallbacks if auto-detection fails.
    /// </summary>
    private static readonly string[] CommonGateways =
    [
        "192.168.1.1",   // Most common (Linksys, TP-Link, many ISP routers)
        "192.168.0.1",   // Second most common (D-Link, Netgear, some ISPs)
        "10.0.0.1",      // Apple AirPort, some enterprise networks
        "192.168.2.1",   // Belkin, SMC
        "192.168.1.254", // Some ISP-provided routers (BT, etc.)
        "192.168.0.254", // Some ISP-provided routers
        "10.0.1.1",      // Apple AirPort alternate
        "192.168.10.1",  // Some business routers
        "192.168.100.1", // Some cable modems
        "172.16.0.1",    // Private network range (less common for home)
    ];

    public GatewayDetector(ILogger<GatewayDetector> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public string? DetectDefaultGateway()
    {
        try
        {
            _logger.LogDebug("Attempting to detect default gateway...");

            // Get all network interfaces that are up and have IPv4 connectivity
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(nic => nic.OperationalStatus == OperationalStatus.Up)
                .Where(nic => nic.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                .Where(nic => nic.Supports(NetworkInterfaceComponent.IPv4))
                .ToList();

            _logger.LogDebug("Found {Count} active network interfaces", interfaces.Count);

            foreach (var nic in interfaces)
            {
                var ipProps = nic.GetIPProperties();
                var gateways = ipProps.GatewayAddresses;

                foreach (var gateway in gateways)
                {
                    // Skip IPv6 gateways and 0.0.0.0 (no gateway)
                    if (gateway.Address.AddressFamily != AddressFamily.InterNetwork)
                        continue;

                    var address = gateway.Address.ToString();
                    if (address == "0.0.0.0")
                        continue;

                    _logger.LogInformation(
                        "Detected default gateway: {Gateway} on interface {Interface}",
                        address, nic.Name);

                    return address;
                }
            }

            _logger.LogWarning("No default gateway found on any network interface");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to detect default gateway");
            return null;
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetCommonGatewayAddresses() => CommonGateways;
}
EOF

# =============================================================================
# 3. Create IInternetTargetProvider interface and implementation
# =============================================================================
log_info "Creating IInternetTargetProvider interface..."

cat > NetworkMonitor.Core/Services/IInternetTargetProvider.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with fallback support.
/// </summary>
/// <remarks>
/// Not all networks can reach all DNS providers. For example:
/// - Some countries block Google DNS (8.8.8.8)
/// - Some corporate networks only allow specific DNS servers
/// - Some ISPs intercept DNS traffic
/// 
/// This provider allows testing multiple targets and using the first
/// one that responds, ensuring the application works in various
/// network environments.
/// </remarks>
public interface IInternetTargetProvider
{
    /// <summary>
    /// Gets the ordered list of internet targets to try.
    /// </summary>
    /// <remarks>
    /// The first reachable target will be used for monitoring.
    /// Targets are ordered by reliability and global availability.
    /// </remarks>
    IReadOnlyList<string> GetTargets();

    /// <summary>
    /// Gets the primary (preferred) target.
    /// </summary>
    string PrimaryTarget { get; }
}
EOF

log_info "Creating InternetTargetProvider implementation..."

cat > NetworkMonitor.Core/Services/InternetTargetProvider.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with automatic fallback.
/// </summary>
public sealed class InternetTargetProvider : IInternetTargetProvider
{
    private readonly ILogger<InternetTargetProvider> _logger;
    private readonly MonitorOptions _options;

    /// <summary>
    /// Well-known, highly available DNS servers that can be used for
    /// connectivity testing. Ordered by global reliability.
    /// </summary>
    private static readonly string[] DefaultTargets =
    [
        "8.8.8.8",       // Google Public DNS (primary)
        "1.1.1.1",       // Cloudflare DNS (very fast, privacy-focused)
        "8.8.4.4",       // Google Public DNS (secondary)
        "1.0.0.1",       // Cloudflare DNS (secondary)
        "9.9.9.9",       // Quad9 DNS (security-focused)
        "208.67.222.222", // OpenDNS (Cisco)
        "208.67.220.220", // OpenDNS (secondary)
    ];

    public InternetTargetProvider(
        IOptions<MonitorOptions> options,
        ILogger<InternetTargetProvider> logger)
    {
        _options = options.Value;
        _logger = logger;

        _logger.LogDebug(
            "Internet target provider initialized with primary target: {Target}",
            PrimaryTarget);
    }

    /// <inheritdoc />
    public string PrimaryTarget => _options.InternetTarget;

    /// <inheritdoc />
    public IReadOnlyList<string> GetTargets()
    {
        // If user specified a custom target, put it first
        if (!string.IsNullOrWhiteSpace(_options.InternetTarget) &&
            !DefaultTargets.Contains(_options.InternetTarget, StringComparer.OrdinalIgnoreCase))
        {
            var customList = new List<string> { _options.InternetTarget };
            customList.AddRange(DefaultTargets);
            return customList;
        }

        // Reorder default list to put configured target first
        var targets = new List<string>(DefaultTargets);
        var configuredIndex = targets.FindIndex(
            t => t.Equals(_options.InternetTarget, StringComparison.OrdinalIgnoreCase));

        if (configuredIndex > 0)
        {
            var configured = targets[configuredIndex];
            targets.RemoveAt(configuredIndex);
            targets.Insert(0, configured);
        }

        return targets;
    }
}
EOF

# =============================================================================
# 4. Update MonitorOptions to support "auto" detection
# =============================================================================
log_info "Updating MonitorOptions..."

cat > NetworkMonitor.Core/Models/MonitorOptions.cs << 'EOF'
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration options for the network monitor.
/// Bound from appsettings.json or environment variables.
/// </summary>
public sealed class MonitorOptions
{
    /// <summary>
    /// Configuration section name in appsettings.json
    /// </summary>
    public const string SectionName = "NetworkMonitor";

    /// <summary>
    /// Special value indicating auto-detection should be used.
    /// </summary>
    public const string AutoDetect = "auto";

    /// <summary>
    /// Router/gateway IP address to ping for local network health.
    /// </summary>
    /// <remarks>
    /// Set to "auto" (default) to automatically detect the default gateway.
    /// The gateway is advertised by DHCP and can be read from the OS.
    /// 
    /// If auto-detection fails, common gateway addresses will be tried:
    /// 192.168.1.1, 192.168.0.1, 10.0.0.1, etc.
    /// 
    /// Set to a specific IP address to override auto-detection.
    /// </remarks>
    public string RouterAddress { get; set; } = AutoDetect;

    /// <summary>
    /// Internet target to ping for WAN connectivity.
    /// </summary>
    /// <remarks>
    /// Default: 8.8.8.8 (Google DNS - highly reliable)
    /// 
    /// If this target is unreachable, fallback targets will be tried:
    /// 1.1.1.1 (Cloudflare), 9.9.9.9 (Quad9), etc.
    /// 
    /// This is useful for networks that block specific DNS providers.
    /// </remarks>
    public string InternetTarget { get; set; } = "8.8.8.8";

    /// <summary>
    /// Timeout for each ping in milliseconds.
    /// Default: 3000ms (3 seconds)
    /// </summary>
    public int TimeoutMs { get; set; } = 3000;

    /// <summary>
    /// Interval between monitoring cycles in milliseconds.
    /// Default: 5000ms (5 seconds)
    /// </summary>
    public int IntervalMs { get; set; } = 5000;

    /// <summary>
    /// Number of pings per target per cycle.
    /// Default: 3 (for statistical significance)
    /// </summary>
    public int PingsPerCycle { get; set; } = 3;

    /// <summary>
    /// Latency threshold (ms) below which is considered "excellent".
    /// Default: 20ms
    /// </summary>
    public int ExcellentLatencyMs { get; set; } = 20;

    /// <summary>
    /// Latency threshold (ms) below which is considered "good".
    /// Default: 100ms
    /// </summary>
    public int GoodLatencyMs { get; set; } = 100;

    /// <summary>
    /// Packet loss percentage above which network is "degraded".
    /// Default: 10%
    /// </summary>
    public int DegradedPacketLossPercent { get; set; } = 10;

    /// <summary>
    /// Whether to use fallback targets if primary fails.
    /// Default: true
    /// </summary>
    public bool EnableFallbackTargets { get; set; } = true;

    /// <summary>
    /// Checks if router address should be auto-detected.
    /// </summary>
    public bool IsRouterAutoDetect =>
        string.IsNullOrWhiteSpace(RouterAddress) ||
        RouterAddress.Equals(AutoDetect, StringComparison.OrdinalIgnoreCase);
}
EOF

# =============================================================================
# 5. Create NetworkConfigurationService to handle detection and fallbacks
# =============================================================================
log_info "Creating NetworkConfigurationService..."

cat > NetworkMonitor.Core/Services/NetworkConfigurationService.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    /// <inheritdoc />
    public async Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized)
                return;

            _logger.LogInformation("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);
            if (_resolvedRouterAddress != null)
            {
                _logger.LogInformation("Router address resolved to: {Address}", _resolvedRouterAddress);
            }
            else
            {
                _logger.LogWarning("Could not resolve router address - router monitoring will be skipped");
            }

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);
            _logger.LogInformation("Internet target resolved to: {Target}", _resolvedInternetTarget);

            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (!_initialized)
        {
            await InitializeAsync(cancellationToken);
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address, use it directly
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        // Try auto-detection first
        _logger.LogDebug("Attempting router auto-detection...");
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (detected != null)
        {
            // Verify it's reachable
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogDebug("Auto-detected gateway {Address} is reachable", detected);
                return detected;
            }
            _logger.LogWarning("Auto-detected gateway {Address} is not reachable", detected);
        }

        // Fall back to common addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var address in _gatewayDetector.GetCommonGatewayAddresses())
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(address, cancellationToken))
            {
                _logger.LogInformation("Found reachable gateway at common address: {Address}", address);
                return address;
            }
        }

        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        // If fallback is disabled, just use the primary
        if (!_options.EnableFallbackTargets)
        {
            _logger.LogDebug("Fallback targets disabled, using primary: {Target}", targets[0]);
            return targets[0];
        }

        // Try each target until one responds
        foreach (var target in targets)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(target, cancellationToken))
            {
                if (target != targets[0])
                {
                    _logger.LogInformation(
                        "Primary target {Primary} unreachable, using fallback: {Fallback}",
                        targets[0], target);
                }
                return target;
            }

            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // If nothing is reachable, use the primary anyway (might come back online)
        _logger.LogWarning(
            "No internet targets are reachable, defaulting to: {Target}",
            targets[0]);
        return targets[0];
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(
                target,
                _options.TimeoutMs,
                cancellationToken);
            return result.Success;
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Ping to {Target} failed", target);
            return false;
        }
    }
}
EOF

# =============================================================================
# 6. Create INetworkConfigurationService interface
# =============================================================================
log_info "Creating INetworkConfigurationService interface..."

cat > NetworkMonitor.Core/Services/INetworkConfigurationService.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides resolved network configuration for monitoring.
/// </summary>
/// <remarks>
/// This service handles the complexity of:
/// - Auto-detecting the default gateway
/// - Falling back to common gateway addresses
/// - Finding a reachable internet target
/// - Caching resolved addresses
/// </remarks>
public interface INetworkConfigurationService
{
    /// <summary>
    /// Gets the resolved router/gateway address to monitor.
    /// </summary>
    /// <returns>
    /// The router IP address, or null if no router could be found.
    /// When null, router monitoring should be skipped.
    /// </returns>
    Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the resolved internet target to monitor.
    /// </summary>
    /// <returns>
    /// The internet target IP address. Always returns a value,
    /// falling back to the configured default if nothing is reachable.
    /// </returns>
    Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Initializes the service by detecting and verifying targets.
    /// </summary>
    /// <remarks>
    /// This is called automatically on first access, but can be called
    /// explicitly during startup for eager initialization.
    /// </remarks>
    Task InitializeAsync(CancellationToken cancellationToken = default);
}
EOF

# =============================================================================
# 7. Update NetworkMonitorService to use configuration service
# =============================================================================
log_info "Updating NetworkMonitorService..."

cat > NetworkMonitor.Core/Services/NetworkMonitorService.cs << 'EOF'
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (routerAddress != null)
        {
            var routerResults = await _pingService.PingMultipleAsync(
                routerAddress,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            routerResult = AggregateResults(routerResults);

            if (routerResult.Success && routerResult.RoundtripTimeMs.HasValue)
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }

            activity?.SetTag("router.success", routerResult.Success);
            activity?.SetTag("router.latency_ms", routerResult.RoundtripTimeMs);
        }
        else
        {
            _logger.LogDebug("No router address configured, skipping router ping");
        }

        // Ping internet
        var internetResults = await _pingService.PingMultipleAsync(
            internetTarget,
            _options.PingsPerCycle,
            _options.TimeoutMs,
            cancellationToken);

        var internetResult = AggregateResults(internetResults);

        if (internetResult.Success && internetResult.RoundtripTimeMs.HasValue)
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        activity?.SetTag("internet.success", internetResult.Success);
        activity?.SetTag("internet.latency_ms", internetResult.RoundtripTimeMs);

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());

        // Fire event if status changed
        if (_lastStatus == null || _lastStatus.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return average latency of successful pings
        var avgLatency = (long)successful.Average(r => r.RoundtripTimeMs ?? 0);
        return PingResult.Succeeded(target, avgLatency);
    }

    private (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        return internetLatency switch
        {
            <= 50 when routerLatency <= 10 => (NetworkHealth.Excellent, "Network is excellent"),
            <= 100 => (NetworkHealth.Good, "Network is good"),
            <= 200 => (NetworkHealth.Degraded, "Network is degraded (high latency)"),
            _ => (NetworkHealth.Poor, "Network is poor (very high latency)")
        };
    }
}
EOF

# =============================================================================
# 8. Update ServiceCollectionExtensions to register new services
# =============================================================================
log_info "Updating ServiceCollectionExtensions..."

cat > NetworkMonitor.Core/ServiceCollectionExtensions.cs << 'EOF'
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NetworkMonitor.Core.Exporters;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Core.Storage;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NetworkMonitor.Core;

/// <summary>
/// Extension methods for registering Network Monitor services.
/// Encapsulates all the DI wiring in one place.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers all Network Monitor services with the DI container.
    /// </summary>
    public static IServiceCollection AddNetworkMonitor(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Bind options from configuration
        services.Configure<MonitorOptions>(
            configuration.GetSection(MonitorOptions.SectionName));
        services.Configure<StorageOptions>(
            configuration.GetSection(StorageOptions.SectionName));

        // Register core services
        services.AddSingleton<IPingService, PingService>();
        services.AddSingleton<IGatewayDetector, GatewayDetector>();
        services.AddSingleton<IInternetTargetProvider, InternetTargetProvider>();
        services.AddSingleton<INetworkConfigurationService, NetworkConfigurationService>();
        services.AddSingleton<INetworkMonitorService, NetworkMonitorService>();
        services.AddSingleton<IStatusDisplay, ConsoleStatusDisplay>();
        services.AddSingleton<IStorageService, SqliteStorageService>();

        // Register background service
        services.AddHostedService<MonitorBackgroundService>();

        return services;
    }

    /// <summary>
    /// Adds OpenTelemetry metrics with file and console export.
    /// </summary>
    public static IServiceCollection AddNetworkMonitorTelemetry(
        this IServiceCollection services,
        FileExporterOptions? fileOptions = null)
    {
        fileOptions ??= FileExporterOptions.Default;

        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource
                .AddService(
                    serviceName: "NetworkMonitor",
                    serviceVersion: "1.0.0"))
            .WithMetrics(metrics =>
            {
                metrics
                    .AddMeter("NetworkMonitor.Core")
                    .AddRuntimeInstrumentation()
                    .AddConsoleExporter()
                    .AddFileExporter(fileOptions);
            });

        return services;
    }
}
EOF

# =============================================================================
# 9. Update appsettings.json to use auto-detection by default
# =============================================================================
log_info "Updating appsettings.json..."

cat > NetworkMonitor.Console/appsettings.json << 'EOF'
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "NetworkMonitor": "Information"
    }
  },
  "NetworkMonitor": {
    "RouterAddress": "auto",
    "InternetTarget": "8.8.8.8",
    "TimeoutMs": 3000,
    "IntervalMs": 5000,
    "PingsPerCycle": 3,
    "ExcellentLatencyMs": 20,
    "GoodLatencyMs": 100,
    "DegradedPacketLossPercent": 10,
    "EnableFallbackTargets": true
  },
  "Storage": {
    "RetentionDays": 30,
    "DatabasePath": ""
  }
}
EOF

# =============================================================================
# 10. Create unit tests for gateway detection
# =============================================================================
log_info "Creating unit tests..."

mkdir -p NetworkMonitor.Tests/Services

# Create fake gateway detector for tests
cat > NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake gateway detector for testing.
/// </summary>
public sealed class FakeGatewayDetector : IGatewayDetector
{
    private string? _gatewayToReturn;
    private readonly List<string> _commonGateways = ["192.168.1.1", "192.168.0.1", "10.0.0.1"];

    /// <summary>
    /// Configures the detector to return a specific gateway.
    /// </summary>
    public FakeGatewayDetector WithGateway(string? gateway)
    {
        _gatewayToReturn = gateway;
        return this;
    }

    /// <summary>
    /// Configures the detector to return null (no gateway found).
    /// </summary>
    public FakeGatewayDetector WithNoGateway()
    {
        _gatewayToReturn = null;
        return this;
    }

    /// <summary>
    /// Configures the common gateways list.
    /// </summary>
    public FakeGatewayDetector WithCommonGateways(params string[] gateways)
    {
        _commonGateways.Clear();
        _commonGateways.AddRange(gateways);
        return this;
    }

    public string? DetectDefaultGateway() => _gatewayToReturn;

    public IReadOnlyList<string> GetCommonGatewayAddresses() => _commonGateways;
}
EOF

# Create fake internet target provider
cat > NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private readonly List<string> _targets = ["8.8.8.8", "1.1.1.1"];

    public string PrimaryTarget => _targets[0];

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets.Clear();
        _targets.AddRange(targets);
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}
EOF

# Create fake network configuration service
cat > NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public Task InitializeAsync(CancellationToken cancellationToken = default)
        => Task.CompletedTask;
}
EOF

# Create GatewayDetector tests
cat > NetworkMonitor.Tests/Services/GatewayDetectorTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for GatewayDetector.
/// Note: These tests run against the real network stack, so results
/// depend on the test environment. We test the interface contract.
/// </summary>
public sealed class GatewayDetectorTests
{
    private readonly GatewayDetector _detector;

    public GatewayDetectorTests()
    {
        _detector = new GatewayDetector(NullLogger<GatewayDetector>.Instance);
    }

    [Fact]
    public void DetectDefaultGateway_ReturnsValidIpOrNull()
    {
        // Act
        var result = _detector.DetectDefaultGateway();

        // Assert - should be null or a valid IP
        if (result != null)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", result);
        }
    }

    [Fact]
    public void GetCommonGatewayAddresses_ReturnsNonEmptyList()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        Assert.NotEmpty(addresses);
        Assert.Contains("192.168.1.1", addresses);
        Assert.Contains("192.168.0.1", addresses);
        Assert.Contains("10.0.0.1", addresses);
    }

    [Fact]
    public void GetCommonGatewayAddresses_AllAreValidIpAddresses()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        foreach (var address in addresses)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", address);
        }
    }
}
EOF

# Create InternetTargetProvider tests
cat > NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for InternetTargetProvider.
/// </summary>
public sealed class InternetTargetProviderTests
{
    [Fact]
    public void PrimaryTarget_ReturnsConfiguredTarget()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act & Assert
        Assert.Equal("1.1.1.1", provider.PrimaryTarget);
    }

    [Fact]
    public void GetTargets_ReturnsConfiguredTargetFirst()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("1.1.1.1", targets[0]);
    }

    [Fact]
    public void GetTargets_IncludesMultipleFallbacks()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions());
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.True(targets.Count >= 3, "Should have multiple fallback targets");
        Assert.Contains("8.8.8.8", targets);
        Assert.Contains("1.1.1.1", targets);
    }

    [Fact]
    public void GetTargets_CustomTargetAddedToFront()
    {
        // Arrange - use a target not in the default list
        var options = Options.Create(new MonitorOptions { InternetTarget = "4.4.4.4" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("4.4.4.4", targets[0]);
        Assert.Contains("8.8.8.8", targets); // Default fallbacks still present
    }
}
EOF

# Create NetworkConfigurationService tests
cat > NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        return new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_ReturnsDetectedGateway()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254");
        _pingService.AlwaysSucceed(5);
        var service = CreateService(new MonitorOptions { RouterAddress = "auto" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.254", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254"); // Should be ignored
        var service = CreateService(new MonitorOptions { RouterAddress = "10.0.0.1" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenDetectionFails_TriesCommonAddresses()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1", "192.168.0.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("192.168.0.1", 5));
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenNothingReachable_ReturnsNull()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryReachable_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(10);
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryUnreachable_ReturnsFallback()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("1.1.1.1", 10));
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenFallbackDisabled_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService(new MonitorOptions { EnableFallbackTargets = false });

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result); // Returns primary even if unreachable
    }

    [Fact]
    public async Task InitializeAsync_CachesResults()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var service = CreateService();

        // Act
        await service.InitializeAsync(TestContext.Current.CancellationToken);
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Change the detector (shouldn't affect cached result)
        _gatewayDetector.WithGateway("10.0.0.1");
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - both should return cached value
        Assert.Equal("192.168.1.1", result1);
        Assert.Equal("192.168.1.1", result2);
    }
}
EOF

# Update NetworkMonitorServiceTests to use new configuration service
cat > NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            _configService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellent()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Excellent, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsDegradedOrPoor()
    {
        // Arrange - router fails, internet succeeds
        _configService.WithRouterAddress("192.168.1.1");
        _pingService
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Degraded, status.Health);
        Assert.False(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoor()
    {
        // Arrange - router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.False(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("Network unreachable");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouterConfigured_SkipsRouterPing()
    {
        // Arrange
        _configService.WithRouterAddress(null);
        _pingService.AlwaysSucceed(20);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(status.RouterResult);
        Assert.NotNull(status.InternetResult);
        Assert.True(status.InternetResult.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegraded()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatus? receivedStatus = null;
        _service.StatusChanged += (_, e) => receivedStatus = e.CurrentStatus;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedStatus);
        Assert.Equal(NetworkHealth.Excellent, receivedStatus.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }
}
EOF

# Create MonitorOptions tests
cat > NetworkMonitor.Tests/Models/MonitorOptionsTests.cs << 'EOF'
using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for MonitorOptions.
/// </summary>
public sealed class MonitorOptionsTests
{
    [Fact]
    public void IsRouterAutoDetect_WhenAuto_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "auto" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenAutoUppercase_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "AUTO" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenEmpty_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenNull_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = null! };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenIpAddress_ReturnsFalse()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "192.168.1.1" };

        // Act & Assert
        Assert.False(options.IsRouterAutoDetect);
    }

    [Fact]
    public void DefaultRouterAddress_IsAuto()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.Equal("auto", options.RouterAddress);
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void EnableFallbackTargets_DefaultsToTrue()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.True(options.EnableFallbackTargets);
    }
}
EOF

# Create Models directory in tests if needed
mkdir -p NetworkMonitor.Tests/Models

# =============================================================================
# 11. Update FakePingService with additional helper methods
# =============================================================================
log_info "Updating FakePingService..."

cat > NetworkMonitor.Tests/Fakes/FakePingService.cs << 'EOF'
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake ping service for testing.
/// Allows controlled responses without actual network calls.
/// </summary>
public sealed class FakePingService : IPingService
{
    private readonly Queue<PingResult> _queuedResults = new();
    private Func<string, PingResult>? _resultFactory;

    /// <summary>
    /// Queues a specific result to be returned.
    /// Results are dequeued in FIFO order.
    /// </summary>
    public FakePingService QueueResult(PingResult result)
    {
        _queuedResults.Enqueue(result);
        return this;
    }

    /// <summary>
    /// Configures the service to always succeed with the given latency.
    /// </summary>
    public FakePingService AlwaysSucceed(long latencyMs = 10)
    {
        _resultFactory = target => PingResult.Succeeded(target, latencyMs);
        return this;
    }

    /// <summary>
    /// Configures the service to always fail with the given error.
    /// </summary>
    public FakePingService AlwaysFail(string error = "Timeout")
    {
        _resultFactory = target => PingResult.Failed(target, error);
        return this;
    }

    /// <summary>
    /// Configures a custom factory for generating results.
    /// </summary>
    public FakePingService WithFactory(Func<string, PingResult> factory)
    {
        _resultFactory = factory;
        return this;
    }

    /// <summary>
    /// Clears all queued results and resets the factory.
    /// </summary>
    public FakePingService Reset()
    {
        _queuedResults.Clear();
        _resultFactory = null;
        return this;
    }

    public Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (_queuedResults.Count > 0)
        {
            return Task.FromResult(_queuedResults.Dequeue());
        }

        if (_resultFactory != null)
        {
            return Task.FromResult(_resultFactory(target));
        }

        // Default: succeed with 10ms latency
        return Task.FromResult(PingResult.Succeeded(target, 10));
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            results.Add(await PingAsync(target, timeoutMs, cancellationToken));
        }

        return results;
    }
}
EOF

# =============================================================================
# 12. Update NullLogger helper
# =============================================================================
log_info "Updating NullLogger helper..."

cat > NetworkMonitor.Tests/Fakes/NullLogger.cs << 'EOF'
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Null logger implementation for tests.
/// </summary>
public sealed class NullLogger<T> : ILogger<T>
{
    public static readonly NullLogger<T> Instance = new();

    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => null;

    public bool IsEnabled(LogLevel logLevel) => false;

    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        // Intentionally empty
    }
}
EOF

# =============================================================================
# Completion
# =============================================================================
log_success "=========================================="
log_success "Gateway detection and fallback support added!"
log_success "=========================================="
echo ""
log_info "Changes made:"
echo "  1. Added IGatewayDetector interface and GatewayDetector implementation"
echo "  2. Added IInternetTargetProvider interface and implementation"
echo "  3. Added INetworkConfigurationService for resolving targets"
echo "  4. Updated MonitorOptions to support 'auto' detection (now the default)"
echo "  5. Updated NetworkMonitorService to use configuration service"
echo "  6. Updated ServiceCollectionExtensions to register new services"
echo "  7. Updated appsettings.json with new defaults"
echo "  8. Added comprehensive unit tests for all new functionality"
echo ""
log_info "How it works:"
echo "  - Router address defaults to 'auto' which detects the default gateway"
echo "  - If detection fails, common addresses are tried (192.168.1.1, etc.)"
echo "  - Internet target defaults to 8.8.8.8 with fallbacks (1.1.1.1, etc.)"
echo "  - All settings can still be manually configured in appsettings.json"
echo ""
log_info "Next steps:"
echo "  1. dotnet build"
echo "  2. dotnet test"
echo "  3. dotnet run --project NetworkMonitor.Console"
echo ""
[INFO] Adding gateway auto-detection and internet target fallback...
[INFO] Working directory: /home/kushal/src/dotnet/network-monitor/src
[INFO] Creating IGatewayDetector interface...
[INFO] Creating GatewayDetector implementation...
[INFO] Creating IInternetTargetProvider interface...
[INFO] Creating InternetTargetProvider implementation...
[INFO] Updating MonitorOptions...
[INFO] Creating NetworkConfigurationService...
[INFO] Creating INetworkConfigurationService interface...
[INFO] Updating NetworkMonitorService...
[INFO] Updating ServiceCollectionExtensions...
[INFO] Updating appsettings.json...
[INFO] Creating unit tests...
[INFO] Updating FakePingService...
[INFO] Updating NullLogger helper...
[SUCCESS] ==========================================
[SUCCESS] Gateway detection and fallback support added!
[SUCCESS] ==========================================

[INFO] Changes made:
  1. Added IGatewayDetector interface and GatewayDetector implementation
  2. Added IInternetTargetProvider interface and implementation
  3. Added INetworkConfigurationService for resolving targets
  4. Updated MonitorOptions to support 'auto' detection (now the default)
  5. Updated NetworkMonitorService to use configuration service
  6. Updated ServiceCollectionExtensions to register new services
  7. Updated appsettings.json with new defaults
  8. Added comprehensive unit tests for all new functionality

[INFO] How it works:
  - Router address defaults to 'auto' which detects the default gateway
  - If detection fails, common addresses are tried (192.168.1.1, etc.)
  - Internet target defaults to 8.8.8.8 with fallbacks (1.1.1.1, etc.)
  - All settings can still be manually configured in appsettings.json

[INFO] Next steps:
  1. dotnet build
  2. dotnet test
  3. dotnet run --project NetworkMonitor.Console


real	0m0.023s
user	0m0.007s
sys	0m0.017s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
#!/bin/bash
# =============================================================================
# Add Gateway Auto-Detection and Internet Target Fallback
# =============================================================================
# This script adds:
# 1. IGatewayDetector interface and cross-platform implementation
# 2. Auto-detection of default gateway (router) IP address
# 3. Fallback internet targets (1.1.1.1 if 8.8.8.8 is unavailable)
# 4. MonitorOptions changes to support "auto" detection
# 5. Comprehensive unit tests for all new functionality
#
# Philosophy: Make things work out of the box for most users while still
# allowing full configurability for those with special network setups.
# =============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in the src directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

log_info "Adding gateway auto-detection and internet target fallback..."
log_info "Working directory: $(pwd)"

# =============================================================================
# 1. Create IGatewayDetector interface
# =============================================================================
log_info "Creating IGatewayDetector interface..."

cat > NetworkMonitor.Core/Services/IGatewayDetector.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Detects the default gateway (router) IP address.
/// </summary>
/// <remarks>
/// The default gateway is advertised by DHCP and can be read from the OS
/// network configuration. This allows the application to work "out of the box"
/// without requiring users to manually configure their router IP.
/// </remarks>
public interface IGatewayDetector
{
    /// <summary>
    /// Attempts to detect the default gateway IP address.
    /// </summary>
    /// <returns>
    /// The IP address of the default gateway, or null if it cannot be detected.
    /// </returns>
    /// <remarks>
    /// On most systems, this returns the router IP (e.g., 192.168.1.1, 192.168.0.1, 10.0.0.1).
    /// Returns null if:
    /// - No network interfaces are available
    /// - No default gateway is configured (e.g., disconnected)
    /// - The system doesn't support gateway detection
    /// </remarks>
    string? DetectDefaultGateway();

    /// <summary>
    /// Gets a list of common gateway addresses to try as fallbacks.
    /// </summary>
    /// <remarks>
    /// If auto-detection fails, these are the most common gateway addresses
    /// used by consumer routers. The list is ordered by popularity.
    /// </remarks>
    IReadOnlyList<string> GetCommonGatewayAddresses();
}
EOF

# =============================================================================
# 2. Create GatewayDetector implementation
# =============================================================================
log_info "Creating GatewayDetector implementation..."

cat > NetworkMonitor.Core/Services/GatewayDetector.cs << 'EOF'
using System.Net.NetworkInformation;
using System.Net.Sockets;
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform default gateway detector using System.Net.NetworkInformation.
/// </summary>
/// <remarks>
/// This implementation reads the default gateway from the OS routing table,
/// which is populated by DHCP or static configuration. Works on Windows,
/// macOS, and Linux without external dependencies.
/// </remarks>
public sealed class GatewayDetector : IGatewayDetector
{
    private readonly ILogger<GatewayDetector> _logger;

    /// <summary>
    /// Common gateway addresses used by consumer routers, ordered by popularity.
    /// These are used as fallbacks if auto-detection fails.
    /// </summary>
    private static readonly string[] CommonGateways =
    [
        "192.168.1.1",   // Most common (Linksys, TP-Link, many ISP routers)
        "192.168.0.1",   // Second most common (D-Link, Netgear, some ISPs)
        "10.0.0.1",      // Apple AirPort, some enterprise networks
        "192.168.2.1",   // Belkin, SMC
        "192.168.1.254", // Some ISP-provided routers (BT, etc.)
        "192.168.0.254", // Some ISP-provided routers
        "10.0.1.1",      // Apple AirPort alternate
        "192.168.10.1",  // Some business routers
        "192.168.100.1", // Some cable modems
        "172.16.0.1",    // Private network range (less common for home)
    ];

    public GatewayDetector(ILogger<GatewayDetector> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public string? DetectDefaultGateway()
    {
        try
        {
            _logger.LogDebug("Attempting to detect default gateway...");

            // Get all network interfaces that are up and have IPv4 connectivity
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(nic => nic.OperationalStatus == OperationalStatus.Up)
                .Where(nic => nic.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                .Where(nic => nic.Supports(NetworkInterfaceComponent.IPv4))
                .ToList();

            _logger.LogDebug("Found {Count} active network interfaces", interfaces.Count);

            foreach (var nic in interfaces)
            {
                var ipProps = nic.GetIPProperties();
                var gateways = ipProps.GatewayAddresses;

                foreach (var gateway in gateways)
                {
                    // Skip IPv6 gateways and 0.0.0.0 (no gateway)
                    if (gateway.Address.AddressFamily != AddressFamily.InterNetwork)
                        continue;

                    var address = gateway.Address.ToString();
                    if (address == "0.0.0.0")
                        continue;

                    _logger.LogInformation(
                        "Detected default gateway: {Gateway} on interface {Interface}",
                        address, nic.Name);

                    return address;
                }
            }

            _logger.LogWarning("No default gateway found on any network interface");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to detect default gateway");
            return null;
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetCommonGatewayAddresses() => CommonGateways;
}
EOF

# =============================================================================
# 3. Create IInternetTargetProvider interface and implementation
# =============================================================================
log_info "Creating IInternetTargetProvider interface..."

cat > NetworkMonitor.Core/Services/IInternetTargetProvider.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with fallback support.
/// </summary>
/// <remarks>
/// Not all networks can reach all DNS providers. For example:
/// - Some countries block Google DNS (8.8.8.8)
/// - Some corporate networks only allow specific DNS servers
/// - Some ISPs intercept DNS traffic
/// 
/// This provider allows testing multiple targets and using the first
/// one that responds, ensuring the application works in various
/// network environments.
/// </remarks>
public interface IInternetTargetProvider
{
    /// <summary>
    /// Gets the ordered list of internet targets to try.
    /// </summary>
    /// <remarks>
    /// The first reachable target will be used for monitoring.
    /// Targets are ordered by reliability and global availability.
    /// </remarks>
    IReadOnlyList<string> GetTargets();

    /// <summary>
    /// Gets the primary (preferred) target.
    /// </summary>
    string PrimaryTarget { get; }
}
EOF

log_info "Creating InternetTargetProvider implementation..."

cat > NetworkMonitor.Core/Services/InternetTargetProvider.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with automatic fallback.
/// </summary>
public sealed class InternetTargetProvider : IInternetTargetProvider
{
    private readonly ILogger<InternetTargetProvider> _logger;
    private readonly MonitorOptions _options;

    /// <summary>
    /// Well-known, highly available DNS servers that can be used for
    /// connectivity testing. Ordered by global reliability.
    /// </summary>
    private static readonly string[] DefaultTargets =
    [
        "8.8.8.8",       // Google Public DNS (primary)
        "1.1.1.1",       // Cloudflare DNS (very fast, privacy-focused)
        "8.8.4.4",       // Google Public DNS (secondary)
        "1.0.0.1",       // Cloudflare DNS (secondary)
        "9.9.9.9",       // Quad9 DNS (security-focused)
        "208.67.222.222", // OpenDNS (Cisco)
        "208.67.220.220", // OpenDNS (secondary)
    ];

    public InternetTargetProvider(
        IOptions<MonitorOptions> options,
        ILogger<InternetTargetProvider> logger)
    {
        _options = options.Value;
        _logger = logger;

        _logger.LogDebug(
            "Internet target provider initialized with primary target: {Target}",
            PrimaryTarget);
    }

    /// <inheritdoc />
    public string PrimaryTarget => _options.InternetTarget;

    /// <inheritdoc />
    public IReadOnlyList<string> GetTargets()
    {
        // If user specified a custom target, put it first
        if (!string.IsNullOrWhiteSpace(_options.InternetTarget) &&
            !DefaultTargets.Contains(_options.InternetTarget, StringComparer.OrdinalIgnoreCase))
        {
            var customList = new List<string> { _options.InternetTarget };
            customList.AddRange(DefaultTargets);
            return customList;
        }

        // Reorder default list to put configured target first
        var targets = new List<string>(DefaultTargets);
        var configuredIndex = targets.FindIndex(
            t => t.Equals(_options.InternetTarget, StringComparison.OrdinalIgnoreCase));

        if (configuredIndex > 0)
        {
            var configured = targets[configuredIndex];
            targets.RemoveAt(configuredIndex);
            targets.Insert(0, configured);
        }

        return targets;
    }
}
EOF

# =============================================================================
# 4. Update MonitorOptions to support "auto" detection
# =============================================================================
log_info "Updating MonitorOptions..."

cat > NetworkMonitor.Core/Models/MonitorOptions.cs << 'EOF'
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration options for the network monitor.
/// Bound from appsettings.json or environment variables.
/// </summary>
public sealed class MonitorOptions
{
    /// <summary>
    /// Configuration section name in appsettings.json
    /// </summary>
    public const string SectionName = "NetworkMonitor";

    /// <summary>
    /// Special value indicating auto-detection should be used.
    /// </summary>
    public const string AutoDetect = "auto";

    /// <summary>
    /// Router/gateway IP address to ping for local network health.
    /// </summary>
    /// <remarks>
    /// Set to "auto" (default) to automatically detect the default gateway.
    /// The gateway is advertised by DHCP and can be read from the OS.
    /// 
    /// If auto-detection fails, common gateway addresses will be tried:
    /// 192.168.1.1, 192.168.0.1, 10.0.0.1, etc.
    /// 
    /// Set to a specific IP address to override auto-detection.
    /// </remarks>
    public string RouterAddress { get; set; } = AutoDetect;

    /// <summary>
    /// Internet target to ping for WAN connectivity.
    /// </summary>
    /// <remarks>
    /// Default: 8.8.8.8 (Google DNS - highly reliable)
    /// 
    /// If this target is unreachable, fallback targets will be tried:
    /// 1.1.1.1 (Cloudflare), 9.9.9.9 (Quad9), etc.
    /// 
    /// This is useful for networks that block specific DNS providers.
    /// </remarks>
    public string InternetTarget { get; set; } = "8.8.8.8";

    /// <summary>
    /// Timeout for each ping in milliseconds.
    /// Default: 3000ms (3 seconds)
    /// </summary>
    public int TimeoutMs { get; set; } = 3000;

    /// <summary>
    /// Interval between monitoring cycles in milliseconds.
    /// Default: 5000ms (5 seconds)
    /// </summary>
    public int IntervalMs { get; set; } = 5000;

    /// <summary>
    /// Number of pings per target per cycle.
    /// Default: 3 (for statistical significance)
    /// </summary>
    public int PingsPerCycle { get; set; } = 3;

    /// <summary>
    /// Latency threshold (ms) below which is considered "excellent".
    /// Default: 20ms
    /// </summary>
    public int ExcellentLatencyMs { get; set; } = 20;

    /// <summary>
    /// Latency threshold (ms) below which is considered "good".
    /// Default: 100ms
    /// </summary>
    public int GoodLatencyMs { get; set; } = 100;

    /// <summary>
    /// Packet loss percentage above which network is "degraded".
    /// Default: 10%
    /// </summary>
    public int DegradedPacketLossPercent { get; set; } = 10;

    /// <summary>
    /// Whether to use fallback targets if primary fails.
    /// Default: true
    /// </summary>
    public bool EnableFallbackTargets { get; set; } = true;

    /// <summary>
    /// Checks if router address should be auto-detected.
    /// </summary>
    public bool IsRouterAutoDetect =>
        string.IsNullOrWhiteSpace(RouterAddress) ||
        RouterAddress.Equals(AutoDetect, StringComparison.OrdinalIgnoreCase);
}
EOF

# =============================================================================
# 5. Create NetworkConfigurationService to handle detection and fallbacks
# =============================================================================
log_info "Creating NetworkConfigurationService..."

cat > NetworkMonitor.Core/Services/NetworkConfigurationService.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    /// <inheritdoc />
    public async Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized)
                return;

            _logger.LogInformation("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);
            if (_resolvedRouterAddress != null)
            {
                _logger.LogInformation("Router address resolved to: {Address}", _resolvedRouterAddress);
            }
            else
            {
                _logger.LogWarning("Could not resolve router address - router monitoring will be skipped");
            }

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);
            _logger.LogInformation("Internet target resolved to: {Target}", _resolvedInternetTarget);

            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (!_initialized)
        {
            await InitializeAsync(cancellationToken);
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address, use it directly
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        // Try auto-detection first
        _logger.LogDebug("Attempting router auto-detection...");
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (detected != null)
        {
            // Verify it's reachable
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogDebug("Auto-detected gateway {Address} is reachable", detected);
                return detected;
            }
            _logger.LogWarning("Auto-detected gateway {Address} is not reachable", detected);
        }

        // Fall back to common addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var address in _gatewayDetector.GetCommonGatewayAddresses())
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(address, cancellationToken))
            {
                _logger.LogInformation("Found reachable gateway at common address: {Address}", address);
                return address;
            }
        }

        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        // If fallback is disabled, just use the primary
        if (!_options.EnableFallbackTargets)
        {
            _logger.LogDebug("Fallback targets disabled, using primary: {Target}", targets[0]);
            return targets[0];
        }

        // Try each target until one responds
        foreach (var target in targets)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(target, cancellationToken))
            {
                if (target != targets[0])
                {
                    _logger.LogInformation(
                        "Primary target {Primary} unreachable, using fallback: {Fallback}",
                        targets[0], target);
                }
                return target;
            }

            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // If nothing is reachable, use the primary anyway (might come back online)
        _logger.LogWarning(
            "No internet targets are reachable, defaulting to: {Target}",
            targets[0]);
        return targets[0];
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(
                target,
                _options.TimeoutMs,
                cancellationToken);
            return result.Success;
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Ping to {Target} failed", target);
            return false;
        }
    }
}
EOF

# =============================================================================
# 6. Create INetworkConfigurationService interface
# =============================================================================
log_info "Creating INetworkConfigurationService interface..."

cat > NetworkMonitor.Core/Services/INetworkConfigurationService.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides resolved network configuration for monitoring.
/// </summary>
/// <remarks>
/// This service handles the complexity of:
/// - Auto-detecting the default gateway
/// - Falling back to common gateway addresses
/// - Finding a reachable internet target
/// - Caching resolved addresses
/// </remarks>
public interface INetworkConfigurationService
{
    /// <summary>
    /// Gets the resolved router/gateway address to monitor.
    /// </summary>
    /// <returns>
    /// The router IP address, or null if no router could be found.
    /// When null, router monitoring should be skipped.
    /// </returns>
    Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the resolved internet target to monitor.
    /// </summary>
    /// <returns>
    /// The internet target IP address. Always returns a value,
    /// falling back to the configured default if nothing is reachable.
    /// </returns>
    Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Initializes the service by detecting and verifying targets.
    /// </summary>
    /// <remarks>
    /// This is called automatically on first access, but can be called
    /// explicitly during startup for eager initialization.
    /// </remarks>
    Task InitializeAsync(CancellationToken cancellationToken = default);
}
EOF

# =============================================================================
# 7. Update NetworkMonitorService to use configuration service
# =============================================================================
log_info "Updating NetworkMonitorService..."

cat > NetworkMonitor.Core/Services/NetworkMonitorService.cs << 'EOF'
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (routerAddress != null)
        {
            var routerResults = await _pingService.PingMultipleAsync(
                routerAddress,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            routerResult = AggregateResults(routerResults);

            if (routerResult.Success && routerResult.RoundtripTimeMs.HasValue)
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }

            activity?.SetTag("router.success", routerResult.Success);
            activity?.SetTag("router.latency_ms", routerResult.RoundtripTimeMs);
        }
        else
        {
            _logger.LogDebug("No router address configured, skipping router ping");
        }

        // Ping internet
        var internetResults = await _pingService.PingMultipleAsync(
            internetTarget,
            _options.PingsPerCycle,
            _options.TimeoutMs,
            cancellationToken);

        var internetResult = AggregateResults(internetResults);

        if (internetResult.Success && internetResult.RoundtripTimeMs.HasValue)
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        activity?.SetTag("internet.success", internetResult.Success);
        activity?.SetTag("internet.latency_ms", internetResult.RoundtripTimeMs);

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());

        // Fire event if status changed
        if (_lastStatus == null || _lastStatus.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return average latency of successful pings
        var avgLatency = (long)successful.Average(r => r.RoundtripTimeMs ?? 0);
        return PingResult.Succeeded(target, avgLatency);
    }

    private (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        return internetLatency switch
        {
            <= 50 when routerLatency <= 10 => (NetworkHealth.Excellent, "Network is excellent"),
            <= 100 => (NetworkHealth.Good, "Network is good"),
            <= 200 => (NetworkHealth.Degraded, "Network is degraded (high latency)"),
            _ => (NetworkHealth.Poor, "Network is poor (very high latency)")
        };
    }
}
EOF

# =============================================================================
# 8. Update ServiceCollectionExtensions to register new services
# =============================================================================
log_info "Updating ServiceCollectionExtensions..."

cat > NetworkMonitor.Core/ServiceCollectionExtensions.cs << 'EOF'
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NetworkMonitor.Core.Exporters;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Core.Storage;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NetworkMonitor.Core;

/// <summary>
/// Extension methods for registering Network Monitor services.
/// Encapsulates all the DI wiring in one place.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers all Network Monitor services with the DI container.
    /// </summary>
    public static IServiceCollection AddNetworkMonitor(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Bind options from configuration
        services.Configure<MonitorOptions>(
            configuration.GetSection(MonitorOptions.SectionName));
        services.Configure<StorageOptions>(
            configuration.GetSection(StorageOptions.SectionName));

        // Register core services
        services.AddSingleton<IPingService, PingService>();
        services.AddSingleton<IGatewayDetector, GatewayDetector>();
        services.AddSingleton<IInternetTargetProvider, InternetTargetProvider>();
        services.AddSingleton<INetworkConfigurationService, NetworkConfigurationService>();
        services.AddSingleton<INetworkMonitorService, NetworkMonitorService>();
        services.AddSingleton<IStatusDisplay, ConsoleStatusDisplay>();
        services.AddSingleton<IStorageService, SqliteStorageService>();

        // Register background service
        services.AddHostedService<MonitorBackgroundService>();

        return services;
    }

    /// <summary>
    /// Adds OpenTelemetry metrics with file and console export.
    /// </summary>
    public static IServiceCollection AddNetworkMonitorTelemetry(
        this IServiceCollection services,
        FileExporterOptions? fileOptions = null)
    {
        fileOptions ??= FileExporterOptions.Default;

        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource
                .AddService(
                    serviceName: "NetworkMonitor",
                    serviceVersion: "1.0.0"))
            .WithMetrics(metrics =>
            {
                metrics
                    .AddMeter("NetworkMonitor.Core")
                    .AddRuntimeInstrumentation()
                    .AddConsoleExporter()
                    .AddFileExporter(fileOptions);
            });

        return services;
    }
}
EOF

# =============================================================================
# 9. Update appsettings.json to use auto-detection by default
# =============================================================================
log_info "Updating appsettings.json..."

cat > NetworkMonitor.Console/appsettings.json << 'EOF'
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "NetworkMonitor": "Information"
    }
  },
  "NetworkMonitor": {
    "RouterAddress": "auto",
    "InternetTarget": "8.8.8.8",
    "TimeoutMs": 3000,
    "IntervalMs": 5000,
    "PingsPerCycle": 3,
    "ExcellentLatencyMs": 20,
    "GoodLatencyMs": 100,
    "DegradedPacketLossPercent": 10,
    "EnableFallbackTargets": true
  },
  "Storage": {
    "RetentionDays": 30,
    "DatabasePath": ""
  }
}
EOF

# =============================================================================
# 10. Create unit tests for gateway detection
# =============================================================================
log_info "Creating unit tests..."

mkdir -p NetworkMonitor.Tests/Services

# Create fake gateway detector for tests
cat > NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake gateway detector for testing.
/// </summary>
public sealed class FakeGatewayDetector : IGatewayDetector
{
    private string? _gatewayToReturn;
    private readonly List<string> _commonGateways = ["192.168.1.1", "192.168.0.1", "10.0.0.1"];

    /// <summary>
    /// Configures the detector to return a specific gateway.
    /// </summary>
    public FakeGatewayDetector WithGateway(string? gateway)
    {
        _gatewayToReturn = gateway;
        return this;
    }

    /// <summary>
    /// Configures the detector to return null (no gateway found).
    /// </summary>
    public FakeGatewayDetector WithNoGateway()
    {
        _gatewayToReturn = null;
        return this;
    }

    /// <summary>
    /// Configures the common gateways list.
    /// </summary>
    public FakeGatewayDetector WithCommonGateways(params string[] gateways)
    {
        _commonGateways.Clear();
        _commonGateways.AddRange(gateways);
        return this;
    }

    public string? DetectDefaultGateway() => _gatewayToReturn;

    public IReadOnlyList<string> GetCommonGatewayAddresses() => _commonGateways;
}
EOF

# Create fake internet target provider
cat > NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private readonly List<string> _targets = ["8.8.8.8", "1.1.1.1"];

    public string PrimaryTarget => _targets[0];

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets.Clear();
        _targets.AddRange(targets);
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}
EOF

# Create fake network configuration service
cat > NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public Task InitializeAsync(CancellationToken cancellationToken = default)
        => Task.CompletedTask;
}
EOF

# Create GatewayDetector tests
cat > NetworkMonitor.Tests/Services/GatewayDetectorTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for GatewayDetector.
/// Note: These tests run against the real network stack, so results
/// depend on the test environment. We test the interface contract.
/// </summary>
public sealed class GatewayDetectorTests
{
    private readonly GatewayDetector _detector;

    public GatewayDetectorTests()
    {
        _detector = new GatewayDetector(NullLogger<GatewayDetector>.Instance);
    }

    [Fact]
    public void DetectDefaultGateway_ReturnsValidIpOrNull()
    {
        // Act
        var result = _detector.DetectDefaultGateway();

        // Assert - should be null or a valid IP
        if (result != null)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", result);
        }
    }

    [Fact]
    public void GetCommonGatewayAddresses_ReturnsNonEmptyList()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        Assert.NotEmpty(addresses);
        Assert.Contains("192.168.1.1", addresses);
        Assert.Contains("192.168.0.1", addresses);
        Assert.Contains("10.0.0.1", addresses);
    }

    [Fact]
    public void GetCommonGatewayAddresses_AllAreValidIpAddresses()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        foreach (var address in addresses)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", address);
        }
    }
}
EOF

# Create InternetTargetProvider tests
cat > NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for InternetTargetProvider.
/// </summary>
public sealed class InternetTargetProviderTests
{
    [Fact]
    public void PrimaryTarget_ReturnsConfiguredTarget()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act & Assert
        Assert.Equal("1.1.1.1", provider.PrimaryTarget);
    }

    [Fact]
    public void GetTargets_ReturnsConfiguredTargetFirst()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("1.1.1.1", targets[0]);
    }

    [Fact]
    public void GetTargets_IncludesMultipleFallbacks()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions());
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.True(targets.Count >= 3, "Should have multiple fallback targets");
        Assert.Contains("8.8.8.8", targets);
        Assert.Contains("1.1.1.1", targets);
    }

    [Fact]
    public void GetTargets_CustomTargetAddedToFront()
    {
        // Arrange - use a target not in the default list
        var options = Options.Create(new MonitorOptions { InternetTarget = "4.4.4.4" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("4.4.4.4", targets[0]);
        Assert.Contains("8.8.8.8", targets); // Default fallbacks still present
    }
}
EOF

# Create NetworkConfigurationService tests
cat > NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        return new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_ReturnsDetectedGateway()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254");
        _pingService.AlwaysSucceed(5);
        var service = CreateService(new MonitorOptions { RouterAddress = "auto" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.254", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254"); // Should be ignored
        var service = CreateService(new MonitorOptions { RouterAddress = "10.0.0.1" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenDetectionFails_TriesCommonAddresses()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1", "192.168.0.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("192.168.0.1", 5));
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenNothingReachable_ReturnsNull()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryReachable_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(10);
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryUnreachable_ReturnsFallback()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("1.1.1.1", 10));
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenFallbackDisabled_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService(new MonitorOptions { EnableFallbackTargets = false });

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result); // Returns primary even if unreachable
    }

    [Fact]
    public async Task InitializeAsync_CachesResults()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var service = CreateService();

        // Act
        await service.InitializeAsync(TestContext.Current.CancellationToken);
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Change the detector (shouldn't affect cached result)
        _gatewayDetector.WithGateway("10.0.0.1");
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - both should return cached value
        Assert.Equal("192.168.1.1", result1);
        Assert.Equal("192.168.1.1", result2);
    }
}
EOF

# Update NetworkMonitorServiceTests to use new configuration service
cat > NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            _configService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellent()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Excellent, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsDegradedOrPoor()
    {
        // Arrange - router fails, internet succeeds
        _configService.WithRouterAddress("192.168.1.1");
        _pingService
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Degraded, status.Health);
        Assert.False(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoor()
    {
        // Arrange - router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.False(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("Network unreachable");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouterConfigured_SkipsRouterPing()
    {
        // Arrange
        _configService.WithRouterAddress(null);
        _pingService.AlwaysSucceed(20);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(status.RouterResult);
        Assert.NotNull(status.InternetResult);
        Assert.True(status.InternetResult.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegraded()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatus? receivedStatus = null;
        _service.StatusChanged += (_, e) => receivedStatus = e.CurrentStatus;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedStatus);
        Assert.Equal(NetworkHealth.Excellent, receivedStatus.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }
}
EOF

# Create MonitorOptions tests
cat > NetworkMonitor.Tests/Models/MonitorOptionsTests.cs << 'EOF'
using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for MonitorOptions.
/// </summary>
public sealed class MonitorOptionsTests
{
    [Fact]
    public void IsRouterAutoDetect_WhenAuto_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "auto" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenAutoUppercase_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "AUTO" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenEmpty_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenNull_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = null! };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenIpAddress_ReturnsFalse()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "192.168.1.1" };

        // Act & Assert
        Assert.False(options.IsRouterAutoDetect);
    }

    [Fact]
    public void DefaultRouterAddress_IsAuto()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.Equal("auto", options.RouterAddress);
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void EnableFallbackTargets_DefaultsToTrue()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.True(options.EnableFallbackTargets);
    }
}
EOF

# Create Models directory in tests if needed
mkdir -p NetworkMonitor.Tests/Models

# =============================================================================
# 11. Update FakePingService with additional helper methods
# =============================================================================
log_info "Updating FakePingService..."

cat > NetworkMonitor.Tests/Fakes/FakePingService.cs << 'EOF'
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake ping service for testing.
/// Allows controlled responses without actual network calls.
/// </summary>
public sealed class FakePingService : IPingService
{
    private readonly Queue<PingResult> _queuedResults = new();
    private Func<string, PingResult>? _resultFactory;

    /// <summary>
    /// Queues a specific result to be returned.
    /// Results are dequeued in FIFO order.
    /// </summary>
    public FakePingService QueueResult(PingResult result)
    {
        _queuedResults.Enqueue(result);
        return this;
    }

    /// <summary>
    /// Configures the service to always succeed with the given latency.
    /// </summary>
    public FakePingService AlwaysSucceed(long latencyMs = 10)
    {
        _resultFactory = target => PingResult.Succeeded(target, latencyMs);
        return this;
    }

    /// <summary>
    /// Configures the service to always fail with the given error.
    /// </summary>
    public FakePingService AlwaysFail(string error = "Timeout")
    {
        _resultFactory = target => PingResult.Failed(target, error);
        return this;
    }

    /// <summary>
    /// Configures a custom factory for generating results.
    /// </summary>
    public FakePingService WithFactory(Func<string, PingResult> factory)
    {
        _resultFactory = factory;
        return this;
    }

    /// <summary>
    /// Clears all queued results and resets the factory.
    /// </summary>
    public FakePingService Reset()
    {
        _queuedResults.Clear();
        _resultFactory = null;
        return this;
    }

    public Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (_queuedResults.Count > 0)
        {
            return Task.FromResult(_queuedResults.Dequeue());
        }

        if (_resultFactory != null)
        {
            return Task.FromResult(_resultFactory(target));
        }

        // Default: succeed with 10ms latency
        return Task.FromResult(PingResult.Succeeded(target, 10));
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            results.Add(await PingAsync(target, timeoutMs, cancellationToken));
        }

        return results;
    }
}
EOF

# =============================================================================
# 12. Update NullLogger helper
# =============================================================================
log_info "Updating NullLogger helper..."

cat > NetworkMonitor.Tests/Fakes/NullLogger.cs << 'EOF'
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Null logger implementation for tests.
/// </summary>
public sealed class NullLogger<T> : ILogger<T>
{
    public static readonly NullLogger<T> Instance = new();

    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => null;

    public bool IsEnabled(LogLevel logLevel) => false;

    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        // Intentionally empty
    }
}
EOF

# =============================================================================
# Completion
# =============================================================================
log_success "=========================================="
log_success "Gateway detection and fallback support added!"
log_success "=========================================="
echo ""
log_info "Changes made:"
echo "  1. Added IGatewayDetector interface and GatewayDetector implementation"
echo "  2. Added IInternetTargetProvider interface and implementation"
echo "  3. Added INetworkConfigurationService for resolving targets"
echo "  4. Updated MonitorOptions to support 'auto' detection (now the default)"
echo "  5. Updated NetworkMonitorService to use configuration service"
echo "  6. Updated ServiceCollectionExtensions to register new services"
echo "  7. Updated appsettings.json with new defaults"
echo "  8. Added comprehensive unit tests for all new functionality"
echo ""
log_info "How it works:"
echo "  - Router address defaults to 'auto' which detects the default gateway"
echo "  - If detection fails, common addresses are tried (192.168.1.1, etc.)"
echo "  - Internet target defaults to 8.8.8.8 with fallbacks (1.1.1.1, etc.)"
echo "  - All settings can still be manually configured in appsettings.json"
echo ""
log_info "Next steps:"
echo "  1. dotnet build"
echo "  2. dotnet test"
echo "  3. dotnet run --project NetworkMonitor.Console"
echo ""
[INFO] Adding gateway auto-detection and internet target fallback...
[INFO] Working directory: /home/kushal/src/dotnet/network-monitor/src
[INFO] Creating IGatewayDetector interface...
[INFO] Creating GatewayDetector implementation...
[INFO] Creating IInternetTargetProvider interface...
[INFO] Creating InternetTargetProvider implementation...
[INFO] Updating MonitorOptions...
[INFO] Creating NetworkConfigurationService...
[INFO] Creating INetworkConfigurationService interface...
[INFO] Updating NetworkMonitorService...
[INFO] Updating ServiceCollectionExtensions...
[INFO] Updating appsettings.json...
[INFO] Creating unit tests...
[INFO] Updating FakePingService...
[INFO] Updating NullLogger helper...
[SUCCESS] ==========================================
[SUCCESS] Gateway detection and fallback support added!
[SUCCESS] ==========================================

[INFO] Changes made:
  1. Added IGatewayDetector interface and GatewayDetector implementation
  2. Added IInternetTargetProvider interface and implementation
  3. Added INetworkConfigurationService for resolving targets
  4. Updated MonitorOptions to support 'auto' detection (now the default)
  5. Updated NetworkMonitorService to use configuration service
  6. Updated ServiceCollectionExtensions to register new services
  7. Updated appsettings.json with new defaults
  8. Added comprehensive unit tests for all new functionality

[INFO] How it works:
  - Router address defaults to 'auto' which detects the default gateway
  - If detection fails, common addresses are tried (192.168.1.1, etc.)
  - Internet target defaults to 8.8.8.8 with fallbacks (1.1.1.1, etc.)
  - All settings can still be manually configured in appsettings.json

[INFO] Next steps:
  1. dotnet build
  2. dotnet test
  3. dotnet run --project NetworkMonitor.Console


real	0m0.021s
user	0m0.006s
sys	0m0.015s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/; time bash export.sh; cd ~/src/dotnet/network-monitor/src; time dotnet --info; time dotnet format; time dotnet restore; time dotnet clean; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 49 files to export
Processing (1/49): .github/workflows/build-and-test.yml
Processing (2/49): .github/workflows/release.yml
Processing (3/49): src/Directory.Build.props
Processing (4/49): src/Directory.Packages.props
Processing (5/49): src/NetworkMonitor.Console/appsettings.json
Processing (6/49): src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
Processing (7/49): src/NetworkMonitor.Console/Program.cs
Processing (8/49): src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
Processing (9/49): src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
Processing (10/49): src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
Processing (11/49): src/NetworkMonitor.Core/Models/HistoricalData.cs
Processing (12/49): src/NetworkMonitor.Core/Models/MonitorOptions.cs
Processing (13/49): src/NetworkMonitor.Core/Models/NetworkStatus.cs
Processing (14/49): src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
Processing (15/49): src/NetworkMonitor.Core/Models/PingResult.cs
Processing (16/49): src/NetworkMonitor.Core/Models/StorageOptions.cs
Processing (17/49): src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
Processing (18/49): src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
Processing (19/49): src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
Processing (20/49): src/NetworkMonitor.Core/Services/GatewayDetector.cs
Processing (21/49): src/NetworkMonitor.Core/Services/IGatewayDetector.cs
Processing (22/49): src/NetworkMonitor.Core/Services/IInternetTargetProvider.cs
Processing (23/49): src/NetworkMonitor.Core/Services/INetworkConfigurationService.cs
Processing (24/49): src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
Processing (25/49): src/NetworkMonitor.Core/Services/InternetTargetProvider.cs
Processing (26/49): src/NetworkMonitor.Core/Services/IPingService.cs
Processing (27/49): src/NetworkMonitor.Core/Services/IStatusDisplay.cs
Processing (28/49): src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
Processing (29/49): src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs
Processing (30/49): src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
Processing (31/49): src/NetworkMonitor.Core/Services/PingService.cs
Processing (32/49): src/NetworkMonitor.Core/Storage/IStorageService.cs
Processing (33/49): src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
Processing (34/49): src/NetworkMonitor.slnx
Processing (35/49): src/NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs
Processing (36/49): src/NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs
Processing (37/49): src/NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs
Processing (38/49): src/NetworkMonitor.Tests/Fakes/FakePingService.cs
Processing (39/49): src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
Processing (40/49): src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
Processing (41/49): src/NetworkMonitor.Tests/Fakes/NullLogger.cs
Processing (42/49): src/NetworkMonitor.Tests/Models/MonitorOptionsTests.cs
Processing (43/49): src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
Processing (44/49): src/NetworkMonitor.Tests/NetworkStatusTests.cs
Processing (45/49): src/NetworkMonitor.Tests/PingResultTests.cs
Processing (46/49): src/NetworkMonitor.Tests/Services/GatewayDetectorTests.cs
Processing (47/49): src/NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs
Processing (48/49): src/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs
Processing (49/49): src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 49
Output file size: 0.13 MB

real	0m0.443s
user	0m0.243s
sys	0m0.274s
.NET SDK:
 Version:           10.0.101
 Commit:            fad253f51b
 Workload version:  10.0.101.1
 MSBuild version:   18.0.6+fad253f51

Runtime Environment:
 OS Name:     fedora
 OS Version:  43
 OS Platform: Linux
 RID:         fedora.43-x64
 Base Path:   /usr/lib64/dotnet/sdk/10.0.101/

.NET workloads installed:
 [android]
   Installation Source: SDK 10.0.100
   Manifest Version:    36.1.2/10.0.100
   Manifest Path:       /home/kushal/.dotnet/sdk-manifests/10.0.100/microsoft.net.sdk.android/36.1.2/WorkloadManifest.json
   Install Type:        FileBased

Configured to use workload sets when installing new manifests.

Host:
  Version:      10.0.1
  Architecture: x64
  Commit:       fad253f51b

.NET SDKs installed:
  10.0.101 [/usr/lib64/dotnet/sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]

Other architectures found:
  None

Environment variables:
  DOTNET_BUNDLE_EXTRACT_BASE_DIR           [/home/kushal/.cache/dotnet_bundle_extract]
  DOTNET_ROOT                              [/usr/lib64/dotnet]

global.json file:
  Not found

Learn more:
  https://aka.ms/dotnet/info

Download .NET:
  https://aka.ms/dotnet/download

real	0m0.142s
user	0m0.118s
sys	0m0.023s

real	0m5.275s
user	0m7.310s
sys	0m0.695s
Restore complete (0.4s)

Build succeeded in 0.5s

real	0m0.667s
user	0m0.706s
sys	0m0.112s

Build succeeded in 0.4s

real	0m0.575s
user	0m0.578s
sys	0m0.116s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 failed with 3 error(s) (2.4s)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(147,45): error CS1729: 'NetworkStatusEventArgs' does not contain a constructor that takes 2 arguments
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs(17,21): error CA1001: Type 'NetworkConfigurationService' owns disposable field(s) '_initLock' but is not disposable (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(174,52): error CA1822: Member 'ComputeHealth' does not access instance data and can be marked as static (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822)

Build failed with 3 error(s) in 2.9s

real	0m3.072s
user	0m1.108s
sys	0m0.165s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 failed with 3 error(s) (0.1s)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(147,45): error CS1729: 'NetworkStatusEventArgs' does not contain a constructor that takes 2 arguments
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs(17,21): error CA1001: Type 'NetworkConfigurationService' owns disposable field(s) '_initLock' but is not disposable (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(174,52): error CA1822: Member 'ComputeHealth' does not access instance data and can be marked as static (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822)

Build failed with 3 error(s) in 0.7s

real	0m0.853s
user	0m0.853s
sys	0m0.165s
Restore complete (0.4s)

Build succeeded in 0.5s
Project 'NetworkMonitor.Console' has the following package references
   [net10.0]: 
   Top-level Package                            Requested   Resolved
   > Microsoft.Extensions.Hosting               10.0.1      10.0.1  
   > OpenTelemetry.Exporter.Console             1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting           1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime      1.14.0      1.14.0  

Project 'NetworkMonitor.Core' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Data.Sqlite                          10.0.1      10.0.1  
   > Microsoft.Extensions.Hosting                   10.0.1      10.0.1  
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.Extensions.Options                   10.0.1      10.0.1  
   > OpenTelemetry                                  1.14.0      1.14.0  
   > OpenTelemetry.Exporter.Console                 1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting               1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime          1.14.0      1.14.0  

Project 'NetworkMonitor.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.NET.Test.Sdk                         18.0.1      18.0.1  
   > xunit.runner.visualstudio                      3.1.5       3.1.5   
   > xunit.v3                                       3.2.1       3.2.1   


real	0m1.335s
user	0m1.314s
sys	0m0.252s
Restore complete (0.4s)

Build succeeded in 0.5s

The following sources were used:
   https://api.nuget.org/v3/index.json

The given project `NetworkMonitor.Console` has no updates given the current sources.
The given project `NetworkMonitor.Core` has no updates given the current sources.
The given project `NetworkMonitor.Tests` has no updates given the current sources.

real	0m1.498s
user	0m1.483s
sys	0m0.253s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/; time bash export.sh; cd ~/src/dotnet/network-monitor/src; time dotnet --info; time dotnet format; time dotnet restore; time dotnet clean; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 49 files to export
Processing (1/49): .github/workflows/build-and-test.yml
Processing (2/49): .github/workflows/release.yml
Processing (3/49): src/Directory.Build.props
Processing (4/49): src/Directory.Packages.props
Processing (5/49): src/NetworkMonitor.Console/appsettings.json
Processing (6/49): src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
Processing (7/49): src/NetworkMonitor.Console/Program.cs
Processing (8/49): src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
Processing (9/49): src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
Processing (10/49): src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
Processing (11/49): src/NetworkMonitor.Core/Models/HistoricalData.cs
Processing (12/49): src/NetworkMonitor.Core/Models/MonitorOptions.cs
Processing (13/49): src/NetworkMonitor.Core/Models/NetworkStatus.cs
Processing (14/49): src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
Processing (15/49): src/NetworkMonitor.Core/Models/PingResult.cs
Processing (16/49): src/NetworkMonitor.Core/Models/StorageOptions.cs
Processing (17/49): src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
Processing (18/49): src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
Processing (19/49): src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
Processing (20/49): src/NetworkMonitor.Core/Services/GatewayDetector.cs
Processing (21/49): src/NetworkMonitor.Core/Services/IGatewayDetector.cs
Processing (22/49): src/NetworkMonitor.Core/Services/IInternetTargetProvider.cs
Processing (23/49): src/NetworkMonitor.Core/Services/INetworkConfigurationService.cs
Processing (24/49): src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
Processing (25/49): src/NetworkMonitor.Core/Services/InternetTargetProvider.cs
Processing (26/49): src/NetworkMonitor.Core/Services/IPingService.cs
Processing (27/49): src/NetworkMonitor.Core/Services/IStatusDisplay.cs
Processing (28/49): src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
Processing (29/49): src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs
Processing (30/49): src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
Processing (31/49): src/NetworkMonitor.Core/Services/PingService.cs
Processing (32/49): src/NetworkMonitor.Core/Storage/IStorageService.cs
Processing (33/49): src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
Processing (34/49): src/NetworkMonitor.slnx
Processing (35/49): src/NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs
Processing (36/49): src/NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs
Processing (37/49): src/NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs
Processing (38/49): src/NetworkMonitor.Tests/Fakes/FakePingService.cs
Processing (39/49): src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
Processing (40/49): src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
Processing (41/49): src/NetworkMonitor.Tests/Fakes/NullLogger.cs
Processing (42/49): src/NetworkMonitor.Tests/Models/MonitorOptionsTests.cs
Processing (43/49): src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
Processing (44/49): src/NetworkMonitor.Tests/NetworkStatusTests.cs
Processing (45/49): src/NetworkMonitor.Tests/PingResultTests.cs
Processing (46/49): src/NetworkMonitor.Tests/Services/GatewayDetectorTests.cs
Processing (47/49): src/NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs
Processing (48/49): src/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs
Processing (49/49): src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 49
Output file size: 0.13 MB

real	0m0.441s
user	0m0.249s
sys	0m0.285s
.NET SDK:
 Version:           10.0.101
 Commit:            fad253f51b
 Workload version:  10.0.101.1
 MSBuild version:   18.0.6+fad253f51

Runtime Environment:
 OS Name:     fedora
 OS Version:  43
 OS Platform: Linux
 RID:         fedora.43-x64
 Base Path:   /usr/lib64/dotnet/sdk/10.0.101/

.NET workloads installed:
 [android]
   Installation Source: SDK 10.0.100
   Manifest Version:    36.1.2/10.0.100
   Manifest Path:       /home/kushal/.dotnet/sdk-manifests/10.0.100/microsoft.net.sdk.android/36.1.2/WorkloadManifest.json
   Install Type:        FileBased

Configured to use workload sets when installing new manifests.

Host:
  Version:      10.0.1
  Architecture: x64
  Commit:       fad253f51b

.NET SDKs installed:
  10.0.101 [/usr/lib64/dotnet/sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]

Other architectures found:
  None

Environment variables:
  DOTNET_BUNDLE_EXTRACT_BASE_DIR           [/home/kushal/.cache/dotnet_bundle_extract]
  DOTNET_ROOT                              [/usr/lib64/dotnet]

global.json file:
  Not found

Learn more:
  https://aka.ms/dotnet/info

Download .NET:
  https://aka.ms/dotnet/download

real	0m0.152s
user	0m0.124s
sys	0m0.027s

real	0m5.592s
user	0m7.806s
sys	0m0.744s
Restore complete (0.4s)

Build succeeded in 0.5s

real	0m0.673s
user	0m0.714s
sys	0m0.111s

Build succeeded in 0.4s

real	0m0.554s
user	0m0.566s
sys	0m0.100s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 failed with 3 error(s) (0.1s)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(147,45): error CS1729: 'NetworkStatusEventArgs' does not contain a constructor that takes 2 arguments
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs(17,21): error CA1001: Type 'NetworkConfigurationService' owns disposable field(s) '_initLock' but is not disposable (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(174,52): error CA1822: Member 'ComputeHealth' does not access instance data and can be marked as static (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822)

Build failed with 3 error(s) in 0.7s

real	0m0.824s
user	0m0.929s
sys	0m0.145s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 failed with 3 error(s) (0.1s)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(147,45): error CS1729: 'NetworkStatusEventArgs' does not contain a constructor that takes 2 arguments
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs(17,21): error CA1001: Type 'NetworkConfigurationService' owns disposable field(s) '_initLock' but is not disposable (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkMonitorService.cs(174,52): error CA1822: Member 'ComputeHealth' does not access instance data and can be marked as static (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822)

Build failed with 3 error(s) in 0.7s

real	0m0.826s
user	0m0.860s
sys	0m0.160s
Restore complete (0.5s)

Build succeeded in 0.6s
Project 'NetworkMonitor.Console' has the following package references
   [net10.0]: 
   Top-level Package                            Requested   Resolved
   > Microsoft.Extensions.Hosting               10.0.1      10.0.1  
   > OpenTelemetry.Exporter.Console             1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting           1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime      1.14.0      1.14.0  

Project 'NetworkMonitor.Core' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Data.Sqlite                          10.0.1      10.0.1  
   > Microsoft.Extensions.Hosting                   10.0.1      10.0.1  
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.Extensions.Options                   10.0.1      10.0.1  
   > OpenTelemetry                                  1.14.0      1.14.0  
   > OpenTelemetry.Exporter.Console                 1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting               1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime          1.14.0      1.14.0  

Project 'NetworkMonitor.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.NET.Test.Sdk                         18.0.1      18.0.1  
   > xunit.runner.visualstudio                      3.1.5       3.1.5   
   > xunit.v3                                       3.2.1       3.2.1   


real	0m1.360s
user	0m1.329s
sys	0m0.262s
Restore complete (0.4s)

Build succeeded in 0.5s

The following sources were used:
   https://api.nuget.org/v3/index.json

The given project `NetworkMonitor.Console` has no updates given the current sources.
The given project `NetworkMonitor.Core` has no updates given the current sources.
The given project `NetworkMonitor.Tests` has no updates given the current sources.

real	0m1.526s
user	0m1.508s
sys	0m0.253s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
#!/bin/bash
# =============================================================================
# fix-build-errors.sh
# Fixes build errors and improves test coverage for NetworkMonitor
# =============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log_info() { echo -e "${CYAN}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in the right directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Detect if we're in src/ or project root
if [[ -d "NetworkMonitor.Core" ]]; then
    SRC_DIR="."
elif [[ -d "src/NetworkMonitor.Core" ]]; then
    SRC_DIR="src"
else
    log_error "Cannot find NetworkMonitor.Core directory. Run this script from the project root or src directory."
    exit 1
fi

log_info "Working directory: $(pwd)"
log_info "Source directory: $SRC_DIR"

# =============================================================================
# FIX 1: NetworkStatusEventArgs - Add PreviousStatus property
# Error: CS1729: 'NetworkStatusEventArgs' does not contain a constructor that takes 2 arguments
# =============================================================================
log_info "Fix 1: Updating NetworkStatusEventArgs to support 2-argument constructor..."

cat > "$SRC_DIR/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs" << 'EOF'
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Event arguments for network status change events.
/// Required for CA1003 compliance (EventHandler should use EventArgs).
/// </summary>
public sealed class NetworkStatusEventArgs : EventArgs
{
    /// <summary>
    /// The current network status.
    /// </summary>
    public NetworkStatus CurrentStatus { get; }

    /// <summary>
    /// The previous network status (null if this is the first check).
    /// </summary>
    public NetworkStatus? PreviousStatus { get; }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs with current status only.
    /// </summary>
    /// <param name="currentStatus">The current network status.</param>
    public NetworkStatusEventArgs(NetworkStatus currentStatus)
        : this(currentStatus, null)
    {
    }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs with current and previous status.
    /// </summary>
    /// <param name="currentStatus">The current network status.</param>
    /// <param name="previousStatus">The previous network status.</param>
    public NetworkStatusEventArgs(NetworkStatus currentStatus, NetworkStatus? previousStatus)
    {
        CurrentStatus = currentStatus;
        PreviousStatus = previousStatus;
    }

    /// <summary>
    /// Alias for CurrentStatus to maintain backward compatibility.
    /// </summary>
    public NetworkStatus Status => CurrentStatus;
}
EOF
log_success "NetworkStatusEventArgs updated with 2-argument constructor"

# =============================================================================
# FIX 2: NetworkConfigurationService - Implement IDisposable for CA1001
# Error: CA1001: Type 'NetworkConfigurationService' owns disposable field(s) '_initLock' but is not disposable
# =============================================================================
log_info "Fix 2: Updating NetworkConfigurationService to implement IDisposable..."

cat > "$SRC_DIR/NetworkMonitor.Core/Services/NetworkConfigurationService.cs" << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService, IDisposable
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;
    private bool _disposed;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (_initialized) return;

        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized) return;

            _logger.LogDebug("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);

            _initialized = true;

            _logger.LogInformation(
                "Network configuration initialized. Router: {Router}, Internet: {Internet}",
                _resolvedRouterAddress ?? "(none)",
                _resolvedInternetTarget);
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address (not "auto"), use it
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        _logger.LogDebug("Auto-detecting gateway...");

        // Try OS-level detection first
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (!string.IsNullOrEmpty(detected))
        {
            _logger.LogDebug("OS detected gateway: {Gateway}", detected);
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogInformation("Using detected gateway: {Gateway}", detected);
                return detected;
            }
            _logger.LogDebug("Detected gateway {Gateway} is not reachable", detected);
        }

        // Fall back to common gateway addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var gateway in _gatewayDetector.GetCommonGatewayAddresses())
        {
            if (await IsReachableAsync(gateway, cancellationToken))
            {
                _logger.LogInformation("Using fallback gateway: {Gateway}", gateway);
                return gateway;
            }
        }

        _logger.LogWarning("No reachable gateway found. Router monitoring will be disabled.");
        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        foreach (var target in targets)
        {
            if (await IsReachableAsync(target, cancellationToken))
            {
                _logger.LogDebug("Using internet target: {Target}", target);
                return target;
            }
            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // Return primary target even if not reachable - we'll report the failure
        _logger.LogWarning("No reachable internet targets found. Using primary: {Target}",
            _internetTargetProvider.PrimaryTarget);
        return _internetTargetProvider.PrimaryTarget;
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(target, 2000, cancellationToken);
            return result.Success;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to ping {Target}", target);
            return false;
        }
    }

    /// <summary>
    /// Disposes the service and releases resources.
    /// </summary>
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        _initLock.Dispose();
    }
}
EOF
log_success "NetworkConfigurationService now implements IDisposable"

# =============================================================================
# FIX 3: NetworkMonitorService - Make ComputeHealth static
# Error: CA1822: Member 'ComputeHealth' does not access instance data and can be marked as static
# =============================================================================
log_info "Fix 3: Updating NetworkMonitorService - making ComputeHealth static..."

cat > "$SRC_DIR/NetworkMonitor.Core/Services/NetworkMonitorService.cs" << 'EOF'
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (!string.IsNullOrEmpty(routerAddress))
        {
            routerResult = await PingWithAggregationAsync(routerAddress, cancellationToken);
            if (routerResult is { Success: true, RoundtripTimeMs: not null })
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }
        }

        // Ping internet target
        var internetResult = await PingWithAggregationAsync(internetTarget, cancellationToken);
        if (internetResult is { Success: true, RoundtripTimeMs: not null })
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult, _options);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());
        activity?.SetTag("router.success", routerResult?.Success ?? false);
        activity?.SetTag("internet.success", internetResult.Success);

        // Fire event if status changed
        if (_lastStatus?.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private async Task<PingResult> PingWithAggregationAsync(
        string target,
        CancellationToken cancellationToken)
    {
        try
        {
            var results = await _pingService.PingMultipleAsync(
                target,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            return AggregateResults(results);
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error pinging {Target}", target);
            return PingResult.Failed(target, ex.Message);
        }
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return median latency of successful pings for stability
        var sortedLatencies = successful
            .Where(r => r.RoundtripTimeMs.HasValue)
            .Select(r => r.RoundtripTimeMs!.Value)
            .OrderBy(l => l)
            .ToList();

        var medianLatency = sortedLatencies.Count > 0
            ? sortedLatencies[sortedLatencies.Count / 2]
            : 0;

        return PingResult.Succeeded(target, medianLatency);
    }

    /// <summary>
    /// Computes network health based on ping results.
    /// </summary>
    /// <remarks>
    /// This method is static as it does not access instance data (CA1822).
    /// </remarks>
    private static (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult,
        MonitorOptions options)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        if (internetLatency <= options.ExcellentLatencyMs &&
            routerLatency <= options.ExcellentLatencyMs)
        {
            return (NetworkHealth.Excellent,
                $"Excellent - Router: {routerLatency}ms, Internet: {internetLatency}ms");
        }

        if (internetLatency <= options.GoodLatencyMs &&
            routerLatency <= options.GoodLatencyMs)
        {
            return (NetworkHealth.Good,
                $"Good - Router: {routerLatency}ms, Internet: {internetLatency}ms");
        }

        // High latency somewhere
        if (routerLatency > options.GoodLatencyMs && routerResult != null)
        {
            return (NetworkHealth.Degraded,
                $"High local latency: Router {routerLatency}ms - possible WiFi interference");
        }

        return (NetworkHealth.Poor,
            $"High internet latency: {internetLatency}ms - possible ISP issues");
    }
}
EOF
log_success "NetworkMonitorService.ComputeHealth is now static"

# =============================================================================
# Update FakeNetworkConfigurationService for tests
# =============================================================================
log_info "Updating FakeNetworkConfigurationService..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs" << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService, IDisposable
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public void Dispose()
    {
        // Nothing to dispose in fake
    }
}
EOF
log_success "FakeNetworkConfigurationService updated"

# =============================================================================
# Update NetworkMonitorServiceTests to use new EventArgs signature
# =============================================================================
log_info "Updating NetworkMonitorServiceTests..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs" << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            _configService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellentOrGood()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Excellent or NetworkHealth.Good);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsOfflineOrDegraded()
    {
        // Arrange - router fails, internet succeeds
        _pingService
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Offline or NetworkHealth.Degraded);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoorOrOffline()
    {
        // Arrange - router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Poor or NetworkHealth.Offline);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("Connection refused");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouterConfigured_SkipsRouterPing()
    {
        // Arrange
        _configService.WithRouterAddress(null);
        _pingService.AlwaysSucceed(20);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(status.RouterResult);
        Assert.NotNull(status.InternetResult);
        Assert.True(status.InternetResult.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegradedOrPoor()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Degraded or NetworkHealth.Poor);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? receivedArgs = null;
        _service.StatusChanged += (_, e) => receivedArgs = e;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedArgs);
        Assert.NotNull(receivedArgs.CurrentStatus);
        Assert.Null(receivedArgs.PreviousStatus); // First check has no previous
    }

    [Fact]
    public async Task CheckNetworkAsync_SecondCall_HasPreviousStatus()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? lastArgs = null;
        _service.StatusChanged += (_, e) => lastArgs = e;

        // Act - First call
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Change health to trigger event
        _pingService.AlwaysFail("Network down");
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(lastArgs);
        Assert.NotNull(lastArgs.PreviousStatus);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }

    [Fact]
    public async Task CheckNetworkAsync_StatusPropertyEqualsCurrentStatus()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? receivedArgs = null;
        _service.StatusChanged += (_, e) => receivedArgs = e;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert - Status should equal CurrentStatus (backward compatibility)
        Assert.NotNull(receivedArgs);
        Assert.Same(receivedArgs.CurrentStatus, receivedArgs.Status);
    }
}
EOF
log_success "NetworkMonitorServiceTests updated"

# =============================================================================
# Add NetworkStatusEventArgsTests
# =============================================================================
log_info "Adding NetworkStatusEventArgsTests..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Models/NetworkStatusEventArgsTests.cs" << 'EOF'
using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for NetworkStatusEventArgs.
/// </summary>
public sealed class NetworkStatusEventArgsTests
{
    private static NetworkStatus CreateTestStatus(NetworkHealth health) =>
        new(health, null, null, DateTimeOffset.UtcNow, "Test");

    [Fact]
    public void Constructor_SingleArg_SetsCurrentStatus()
    {
        // Arrange
        var status = CreateTestStatus(NetworkHealth.Excellent);

        // Act
        var args = new NetworkStatusEventArgs(status);

        // Assert
        Assert.Equal(status, args.CurrentStatus);
        Assert.Null(args.PreviousStatus);
    }

    [Fact]
    public void Constructor_TwoArgs_SetsBothStatuses()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Excellent);
        var previous = CreateTestStatus(NetworkHealth.Poor);

        // Act
        var args = new NetworkStatusEventArgs(current, previous);

        // Assert
        Assert.Equal(current, args.CurrentStatus);
        Assert.Equal(previous, args.PreviousStatus);
    }

    [Fact]
    public void Status_ReturnsCurrentStatus()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Good);
        var previous = CreateTestStatus(NetworkHealth.Degraded);
        var args = new NetworkStatusEventArgs(current, previous);

        // Act & Assert
        Assert.Same(args.CurrentStatus, args.Status);
    }

    [Fact]
    public void Constructor_WithNullPrevious_Succeeds()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Excellent);

        // Act
        var args = new NetworkStatusEventArgs(current, null);

        // Assert
        Assert.Equal(current, args.CurrentStatus);
        Assert.Null(args.PreviousStatus);
    }
}
EOF
log_success "NetworkStatusEventArgsTests added"

# =============================================================================
# Add NetworkConfigurationServiceTests
# =============================================================================
log_info "Adding/Updating NetworkConfigurationServiceTests..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs" << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests : IDisposable
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;
    private NetworkConfigurationService? _service;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        _service = new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
        return _service;
    }

    public void Dispose()
    {
        _service?.Dispose();
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenExplicitlyConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "10.0.0.1" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_UsesDetectedGateway()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenDetectionFails_FallsBackToCommonGateways()
    {
        // Arrange
        _gatewayDetector.WithNoGateway();
        _gatewayDetector.WithCommonGateways("192.168.0.1", "10.0.0.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenNoGatewayReachable_ReturnsNull()
    {
        // Arrange
        _gatewayDetector.WithNoGateway();
        _gatewayDetector.WithCommonGateways("192.168.0.1");
        _pingService.AlwaysFail("Unreachable");
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_ReturnsFirstReachableTarget()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(10);
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_FallsBackWhenFirstUnreachable()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService
            .QueueResult(PingResult.Failed("8.8.8.8", "Unreachable"))
            .QueueResult(PingResult.Succeeded("1.1.1.1", 20));
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_ReturnsPrimaryWhenNoneReachable()
    {
        // Arrange
        _internetTargetProvider.WithPrimaryTarget("8.8.8.8");
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysFail("All unreachable");
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task ResultsAreCached_MultipleCallsReturnSameValue()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);
        _gatewayDetector.WithGateway("10.0.0.1"); // Change gateway
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - Should return cached value
        Assert.Equal(result1, result2);
        Assert.Equal("192.168.1.1", result2);
    }

    [Fact]
    public void Dispose_CanBeCalledMultipleTimes()
    {
        // Arrange
        var service = CreateService();

        // Act & Assert - Should not throw
        service.Dispose();
        service.Dispose();
    }

    [Fact]
    public async Task GetRouterAddressAsync_AfterDispose_ThrowsObjectDisposedException()
    {
        // Arrange
        var service = CreateService();
        service.Dispose();

        // Act & Assert
        await Assert.ThrowsAsync<ObjectDisposedException>(
            () => service.GetRouterAddressAsync(TestContext.Current.CancellationToken));
    }
}
EOF
log_success "NetworkConfigurationServiceTests added"

# =============================================================================
# Update FakeInternetTargetProvider for tests
# =============================================================================
log_info "Updating FakeInternetTargetProvider..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs" << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private string _primaryTarget = "8.8.8.8";
    private readonly List<string> _targets = ["8.8.8.8", "1.1.1.1"];

    public string PrimaryTarget => _primaryTarget;

    public FakeInternetTargetProvider WithPrimaryTarget(string target)
    {
        _primaryTarget = target;
        return this;
    }

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets.Clear();
        _targets.AddRange(targets);
        if (!string.IsNullOrEmpty(_primaryTarget) && !_targets.Contains(_primaryTarget))
        {
            _primaryTarget = _targets.FirstOrDefault() ?? "8.8.8.8";
        }
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}
EOF
log_success "FakeInternetTargetProvider updated"

# =============================================================================
# Build and Test
# =============================================================================
log_info "Building solution..."
cd "$SRC_DIR"
if dotnet build --nologo -v q; then
    log_success "Build succeeded!"
else
    log_error "Build failed!"
    exit 1
fi

log_info "Running tests..."
if dotnet test --nologo -v q; then
    log_success "All tests passed!"
else
    log_warn "Some tests failed. Please review the output above."
fi

# =============================================================================
# Summary
# =============================================================================
echo ""
echo "============================================================================="
echo -e "${GREEN}Fix Summary${NC}"
echo "============================================================================="
echo ""
echo "Fixed 3 build errors:"
echo ""
echo "1. CS1729: NetworkStatusEventArgs constructor"
echo "   - Added 2-argument constructor (currentStatus, previousStatus)"
echo "   - Added backward-compatible 'Status' property alias"
echo ""
echo "2. CA1001: NetworkConfigurationService not disposable"
echo "   - Implemented IDisposable interface"
echo "   - Added Dispose() method to clean up _initLock SemaphoreSlim"
echo "   - Added ObjectDisposedException checks"
echo ""
echo "3. CA1822: ComputeHealth can be static"
echo "   - Made ComputeHealth method static"
echo "   - Passed MonitorOptions as parameter instead of using instance field"
echo ""
echo "Added/Updated tests:"
echo "   - NetworkStatusEventArgsTests (new)"
echo "   - NetworkMonitorServiceTests (updated for new EventArgs)"
echo "   - NetworkConfigurationServiceTests (updated with dispose tests)"
echo "   - FakeNetworkConfigurationService (implements IDisposable)"
echo "   - FakeInternetTargetProvider (enhanced for testing)"
echo ""
echo "============================================================================="
EOF
[INFO] Working directory: /home/kushal/src/dotnet/network-monitor/src
[INFO] Source directory: .
[INFO] Fix 1: Updating NetworkStatusEventArgs to support 2-argument constructor...
[SUCCESS] NetworkStatusEventArgs updated with 2-argument constructor
[INFO] Fix 2: Updating NetworkConfigurationService to implement IDisposable...
[SUCCESS] NetworkConfigurationService now implements IDisposable
[INFO] Fix 3: Updating NetworkMonitorService - making ComputeHealth static...
[SUCCESS] NetworkMonitorService.ComputeHealth is now static
[INFO] Updating FakeNetworkConfigurationService...
[SUCCESS] FakeNetworkConfigurationService updated
[INFO] Updating NetworkMonitorServiceTests...
[SUCCESS] NetworkMonitorServiceTests updated
[INFO] Adding NetworkStatusEventArgsTests...
[SUCCESS] NetworkStatusEventArgsTests added
[INFO] Adding/Updating NetworkConfigurationServiceTests...
[SUCCESS] NetworkConfigurationServiceTests added
[INFO] Updating FakeInternetTargetProvider...
[SUCCESS] FakeInternetTargetProvider updated
[INFO] Building solution...
/home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs(17,51): error CS0535: 'NetworkConfigurationService' does not implement interface member 'INetworkConfigurationService.InitializeAsync(CancellationToken)'
[ERROR] Build failed!

real	0m2.586s
user	0m1.055s
sys	0m0.172s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
#!/bin/bash
# =============================================================================
# fix-build-errors.sh
# Fixes build errors and improves test coverage for NetworkMonitor
# =============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log_info() { echo -e "${CYAN}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in the right directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Detect if we're in src/ or project root
if [[ -d "NetworkMonitor.Core" ]]; then
    SRC_DIR="."
elif [[ -d "src/NetworkMonitor.Core" ]]; then
    SRC_DIR="src"
else
    log_error "Cannot find NetworkMonitor.Core directory. Run this script from the project root or src directory."
    exit 1
fi

log_info "Working directory: $(pwd)"
log_info "Source directory: $SRC_DIR"

# =============================================================================
# FIX 1: NetworkStatusEventArgs - Add PreviousStatus property
# Error: CS1729: 'NetworkStatusEventArgs' does not contain a constructor that takes 2 arguments
# =============================================================================
log_info "Fix 1: Updating NetworkStatusEventArgs to support 2-argument constructor..."

cat > "$SRC_DIR/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs" << 'EOF'
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Event arguments for network status change events.
/// Required for CA1003 compliance (EventHandler should use EventArgs).
/// </summary>
public sealed class NetworkStatusEventArgs : EventArgs
{
    /// <summary>
    /// The current network status.
    /// </summary>
    public NetworkStatus CurrentStatus { get; }

    /// <summary>
    /// The previous network status (null if this is the first check).
    /// </summary>
    public NetworkStatus? PreviousStatus { get; }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs with current status only.
    /// </summary>
    /// <param name="currentStatus">The current network status.</param>
    public NetworkStatusEventArgs(NetworkStatus currentStatus)
        : this(currentStatus, null)
    {
    }

    /// <summary>
    /// Creates a new instance of NetworkStatusEventArgs with current and previous status.
    /// </summary>
    /// <param name="currentStatus">The current network status.</param>
    /// <param name="previousStatus">The previous network status.</param>
    public NetworkStatusEventArgs(NetworkStatus currentStatus, NetworkStatus? previousStatus)
    {
        CurrentStatus = currentStatus;
        PreviousStatus = previousStatus;
    }

    /// <summary>
    /// Alias for CurrentStatus to maintain backward compatibility.
    /// </summary>
    public NetworkStatus Status => CurrentStatus;
}
EOF
log_success "NetworkStatusEventArgs updated with 2-argument constructor"

# =============================================================================
# FIX 2: NetworkConfigurationService - Implement IDisposable for CA1001
# Error: CA1001: Type 'NetworkConfigurationService' owns disposable field(s) '_initLock' but is not disposable
# =============================================================================
log_info "Fix 2: Updating NetworkConfigurationService to implement IDisposable..."

cat > "$SRC_DIR/NetworkMonitor.Core/Services/NetworkConfigurationService.cs" << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService, IDisposable
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;
    private bool _disposed;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (_initialized) return;

        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized) return;

            _logger.LogDebug("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);

            _initialized = true;

            _logger.LogInformation(
                "Network configuration initialized. Router: {Router}, Internet: {Internet}",
                _resolvedRouterAddress ?? "(none)",
                _resolvedInternetTarget);
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address (not "auto"), use it
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        _logger.LogDebug("Auto-detecting gateway...");

        // Try OS-level detection first
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (!string.IsNullOrEmpty(detected))
        {
            _logger.LogDebug("OS detected gateway: {Gateway}", detected);
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogInformation("Using detected gateway: {Gateway}", detected);
                return detected;
            }
            _logger.LogDebug("Detected gateway {Gateway} is not reachable", detected);
        }

        // Fall back to common gateway addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var gateway in _gatewayDetector.GetCommonGatewayAddresses())
        {
            if (await IsReachableAsync(gateway, cancellationToken))
            {
                _logger.LogInformation("Using fallback gateway: {Gateway}", gateway);
                return gateway;
            }
        }

        _logger.LogWarning("No reachable gateway found. Router monitoring will be disabled.");
        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        foreach (var target in targets)
        {
            if (await IsReachableAsync(target, cancellationToken))
            {
                _logger.LogDebug("Using internet target: {Target}", target);
                return target;
            }
            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // Return primary target even if not reachable - we'll report the failure
        _logger.LogWarning("No reachable internet targets found. Using primary: {Target}",
            _internetTargetProvider.PrimaryTarget);
        return _internetTargetProvider.PrimaryTarget;
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(target, 2000, cancellationToken);
            return result.Success;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to ping {Target}", target);
            return false;
        }
    }

    /// <summary>
    /// Disposes the service and releases resources.
    /// </summary>
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        _initLock.Dispose();
    }
}
EOF
log_success "NetworkConfigurationService now implements IDisposable"

# =============================================================================
# FIX 3: NetworkMonitorService - Make ComputeHealth static
# Error: CA1822: Member 'ComputeHealth' does not access instance data and can be marked as static
# =============================================================================
log_info "Fix 3: Updating NetworkMonitorService - making ComputeHealth static..."

cat > "$SRC_DIR/NetworkMonitor.Core/Services/NetworkMonitorService.cs" << 'EOF'
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (!string.IsNullOrEmpty(routerAddress))
        {
            routerResult = await PingWithAggregationAsync(routerAddress, cancellationToken);
            if (routerResult is { Success: true, RoundtripTimeMs: not null })
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }
        }

        // Ping internet target
        var internetResult = await PingWithAggregationAsync(internetTarget, cancellationToken);
        if (internetResult is { Success: true, RoundtripTimeMs: not null })
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult, _options);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());
        activity?.SetTag("router.success", routerResult?.Success ?? false);
        activity?.SetTag("internet.success", internetResult.Success);

        // Fire event if status changed
        if (_lastStatus?.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private async Task<PingResult> PingWithAggregationAsync(
        string target,
        CancellationToken cancellationToken)
    {
        try
        {
            var results = await _pingService.PingMultipleAsync(
                target,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            return AggregateResults(results);
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error pinging {Target}", target);
            return PingResult.Failed(target, ex.Message);
        }
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return median latency of successful pings for stability
        var sortedLatencies = successful
            .Where(r => r.RoundtripTimeMs.HasValue)
            .Select(r => r.RoundtripTimeMs!.Value)
            .OrderBy(l => l)
            .ToList();

        var medianLatency = sortedLatencies.Count > 0
            ? sortedLatencies[sortedLatencies.Count / 2]
            : 0;

        return PingResult.Succeeded(target, medianLatency);
    }

    /// <summary>
    /// Computes network health based on ping results.
    /// </summary>
    /// <remarks>
    /// This method is static as it does not access instance data (CA1822).
    /// </remarks>
    private static (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult,
        MonitorOptions options)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        if (internetLatency <= options.ExcellentLatencyMs &&
            routerLatency <= options.ExcellentLatencyMs)
        {
            return (NetworkHealth.Excellent,
                $"Excellent - Router: {routerLatency}ms, Internet: {internetLatency}ms");
        }

        if (internetLatency <= options.GoodLatencyMs &&
            routerLatency <= options.GoodLatencyMs)
        {
            return (NetworkHealth.Good,
                $"Good - Router: {routerLatency}ms, Internet: {internetLatency}ms");
        }

        // High latency somewhere
        if (routerLatency > options.GoodLatencyMs && routerResult != null)
        {
            return (NetworkHealth.Degraded,
                $"High local latency: Router {routerLatency}ms - possible WiFi interference");
        }

        return (NetworkHealth.Poor,
            $"High internet latency: {internetLatency}ms - possible ISP issues");
    }
}
EOF
log_success "NetworkMonitorService.ComputeHealth is now static"

# =============================================================================
# Update FakeNetworkConfigurationService for tests
# =============================================================================
log_info "Updating FakeNetworkConfigurationService..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs" << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService, IDisposable
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public void Dispose()
    {
        // Nothing to dispose in fake
    }
}
EOF
log_success "FakeNetworkConfigurationService updated"

# =============================================================================
# Update NetworkMonitorServiceTests to use new EventArgs signature
# =============================================================================
log_info "Updating NetworkMonitorServiceTests..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs" << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            _configService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellentOrGood()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Excellent or NetworkHealth.Good);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsOfflineOrDegraded()
    {
        // Arrange - router fails, internet succeeds
        _pingService
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Offline or NetworkHealth.Degraded);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoorOrOffline()
    {
        // Arrange - router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Poor or NetworkHealth.Offline);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("Connection refused");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouterConfigured_SkipsRouterPing()
    {
        // Arrange
        _configService.WithRouterAddress(null);
        _pingService.AlwaysSucceed(20);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(status.RouterResult);
        Assert.NotNull(status.InternetResult);
        Assert.True(status.InternetResult.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegradedOrPoor()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.True(status.Health is NetworkHealth.Degraded or NetworkHealth.Poor);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? receivedArgs = null;
        _service.StatusChanged += (_, e) => receivedArgs = e;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedArgs);
        Assert.NotNull(receivedArgs.CurrentStatus);
        Assert.Null(receivedArgs.PreviousStatus); // First check has no previous
    }

    [Fact]
    public async Task CheckNetworkAsync_SecondCall_HasPreviousStatus()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? lastArgs = null;
        _service.StatusChanged += (_, e) => lastArgs = e;

        // Act - First call
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Change health to trigger event
        _pingService.AlwaysFail("Network down");
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(lastArgs);
        Assert.NotNull(lastArgs.PreviousStatus);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }

    [Fact]
    public async Task CheckNetworkAsync_StatusPropertyEqualsCurrentStatus()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatusEventArgs? receivedArgs = null;
        _service.StatusChanged += (_, e) => receivedArgs = e;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert - Status should equal CurrentStatus (backward compatibility)
        Assert.NotNull(receivedArgs);
        Assert.Same(receivedArgs.CurrentStatus, receivedArgs.Status);
    }
}
EOF
log_success "NetworkMonitorServiceTests updated"

# =============================================================================
# Add NetworkStatusEventArgsTests
# =============================================================================
log_info "Adding NetworkStatusEventArgsTests..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Models/NetworkStatusEventArgsTests.cs" << 'EOF'
using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for NetworkStatusEventArgs.
/// </summary>
public sealed class NetworkStatusEventArgsTests
{
    private static NetworkStatus CreateTestStatus(NetworkHealth health) =>
        new(health, null, null, DateTimeOffset.UtcNow, "Test");

    [Fact]
    public void Constructor_SingleArg_SetsCurrentStatus()
    {
        // Arrange
        var status = CreateTestStatus(NetworkHealth.Excellent);

        // Act
        var args = new NetworkStatusEventArgs(status);

        // Assert
        Assert.Equal(status, args.CurrentStatus);
        Assert.Null(args.PreviousStatus);
    }

    [Fact]
    public void Constructor_TwoArgs_SetsBothStatuses()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Excellent);
        var previous = CreateTestStatus(NetworkHealth.Poor);

        // Act
        var args = new NetworkStatusEventArgs(current, previous);

        // Assert
        Assert.Equal(current, args.CurrentStatus);
        Assert.Equal(previous, args.PreviousStatus);
    }

    [Fact]
    public void Status_ReturnsCurrentStatus()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Good);
        var previous = CreateTestStatus(NetworkHealth.Degraded);
        var args = new NetworkStatusEventArgs(current, previous);

        // Act & Assert
        Assert.Same(args.CurrentStatus, args.Status);
    }

    [Fact]
    public void Constructor_WithNullPrevious_Succeeds()
    {
        // Arrange
        var current = CreateTestStatus(NetworkHealth.Excellent);

        // Act
        var args = new NetworkStatusEventArgs(current, null);

        // Assert
        Assert.Equal(current, args.CurrentStatus);
        Assert.Null(args.PreviousStatus);
    }
}
EOF
log_success "NetworkStatusEventArgsTests added"

# =============================================================================
# Add NetworkConfigurationServiceTests
# =============================================================================
log_info "Adding/Updating NetworkConfigurationServiceTests..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs" << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests : IDisposable
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;
    private NetworkConfigurationService? _service;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        _service = new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
        return _service;
    }

    public void Dispose()
    {
        _service?.Dispose();
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenExplicitlyConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "10.0.0.1" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_UsesDetectedGateway()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenDetectionFails_FallsBackToCommonGateways()
    {
        // Arrange
        _gatewayDetector.WithNoGateway();
        _gatewayDetector.WithCommonGateways("192.168.0.1", "10.0.0.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenNoGatewayReachable_ReturnsNull()
    {
        // Arrange
        _gatewayDetector.WithNoGateway();
        _gatewayDetector.WithCommonGateways("192.168.0.1");
        _pingService.AlwaysFail("Unreachable");
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_ReturnsFirstReachableTarget()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(10);
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_FallsBackWhenFirstUnreachable()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService
            .QueueResult(PingResult.Failed("8.8.8.8", "Unreachable"))
            .QueueResult(PingResult.Succeeded("1.1.1.1", 20));
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_ReturnsPrimaryWhenNoneReachable()
    {
        // Arrange
        _internetTargetProvider.WithPrimaryTarget("8.8.8.8");
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysFail("All unreachable");
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task ResultsAreCached_MultipleCallsReturnSameValue()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var options = new MonitorOptions { RouterAddress = "auto" };
        var service = CreateService(options);

        // Act
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);
        _gatewayDetector.WithGateway("10.0.0.1"); // Change gateway
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - Should return cached value
        Assert.Equal(result1, result2);
        Assert.Equal("192.168.1.1", result2);
    }

    [Fact]
    public void Dispose_CanBeCalledMultipleTimes()
    {
        // Arrange
        var service = CreateService();

        // Act & Assert - Should not throw
        service.Dispose();
        service.Dispose();
    }

    [Fact]
    public async Task GetRouterAddressAsync_AfterDispose_ThrowsObjectDisposedException()
    {
        // Arrange
        var service = CreateService();
        service.Dispose();

        // Act & Assert
        await Assert.ThrowsAsync<ObjectDisposedException>(
            () => service.GetRouterAddressAsync(TestContext.Current.CancellationToken));
    }
}
EOF
log_success "NetworkConfigurationServiceTests added"

# =============================================================================
# Update FakeInternetTargetProvider for tests
# =============================================================================
log_info "Updating FakeInternetTargetProvider..."

cat > "$SRC_DIR/NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs" << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private string _primaryTarget = "8.8.8.8";
    private readonly List<string> _targets = ["8.8.8.8", "1.1.1.1"];

    public string PrimaryTarget => _primaryTarget;

    public FakeInternetTargetProvider WithPrimaryTarget(string target)
    {
        _primaryTarget = target;
        return this;
    }

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets.Clear();
        _targets.AddRange(targets);
        if (!string.IsNullOrEmpty(_primaryTarget) && !_targets.Contains(_primaryTarget))
        {
            _primaryTarget = _targets.FirstOrDefault() ?? "8.8.8.8";
        }
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}
EOF
log_success "FakeInternetTargetProvider updated"

# =============================================================================
# Build and Test
# =============================================================================
log_info "Building solution..."
cd "$SRC_DIR"
if dotnet build --nologo -v q; then
    log_success "Build succeeded!"
else
    log_error "Build failed!"
    exit 1
fi

log_info "Running tests..."
if dotnet test --nologo -v q; then
    log_success "All tests passed!"
else
    log_warn "Some tests failed. Please review the output above."
fi

# =============================================================================
# Summary
# =============================================================================
echo ""
echo "============================================================================="
echo -e "${GREEN}Fix Summary${NC}"
echo "============================================================================="
echo ""
echo "Fixed 3 build errors:"
echo ""
echo "1. CS1729: NetworkStatusEventArgs constructor"
echo "   - Added 2-argument constructor (currentStatus, previousStatus)"
echo "   - Added backward-compatible 'Status' property alias"
echo ""
echo "2. CA1001: NetworkConfigurationService not disposable"
echo "   - Implemented IDisposable interface"
echo "   - Added Dispose() method to clean up _initLock SemaphoreSlim"
echo "   - Added ObjectDisposedException checks"
echo ""
echo "3. CA1822: ComputeHealth can be static"
echo "   - Made ComputeHealth method static"
echo "   - Passed MonitorOptions as parameter instead of using instance field"
echo ""
echo "Added/Updated tests:"
echo "   - NetworkStatusEventArgsTests (new)"
echo "   - NetworkMonitorServiceTests (updated for new EventArgs)"
echo "   - NetworkConfigurationServiceTests (updated with dispose tests)"
echo "   - FakeNetworkConfigurationService (implements IDisposable)"
echo "   - FakeInternetTargetProvider (enhanced for testing)"
echo ""
echo "============================================================================="
EOF
[INFO] Working directory: /home/kushal/src/dotnet/network-monitor/src
[INFO] Source directory: .
[INFO] Fix 1: Updating NetworkStatusEventArgs to support 2-argument constructor...
[SUCCESS] NetworkStatusEventArgs updated with 2-argument constructor
[INFO] Fix 2: Updating NetworkConfigurationService to implement IDisposable...
[SUCCESS] NetworkConfigurationService now implements IDisposable
[INFO] Fix 3: Updating NetworkMonitorService - making ComputeHealth static...
[SUCCESS] NetworkMonitorService.ComputeHealth is now static
[INFO] Updating FakeNetworkConfigurationService...
[SUCCESS] FakeNetworkConfigurationService updated
[INFO] Updating NetworkMonitorServiceTests...
[SUCCESS] NetworkMonitorServiceTests updated
[INFO] Adding NetworkStatusEventArgsTests...
[SUCCESS] NetworkStatusEventArgsTests added
[INFO] Adding/Updating NetworkConfigurationServiceTests...
[SUCCESS] NetworkConfigurationServiceTests added
[INFO] Updating FakeInternetTargetProvider...
[SUCCESS] FakeInternetTargetProvider updated
[INFO] Building solution...
/home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs(17,51): error CS0535: 'NetworkConfigurationService' does not implement interface member 'INetworkConfigurationService.InitializeAsync(CancellationToken)'
[ERROR] Build failed!

real	0m0.800s
user	0m0.885s
sys	0m0.170s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/; time bash export.sh; cd ~/src/dotnet/network-monitor/src; time dotnet --info; time dotnet format; time dotnet restore; time dotnet clean; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 50 files to export
Processing (1/50): .github/workflows/build-and-test.yml
Processing (2/50): .github/workflows/release.yml
Processing (3/50): src/Directory.Build.props
Processing (4/50): src/Directory.Packages.props
Processing (5/50): src/NetworkMonitor.Console/appsettings.json
Processing (6/50): src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
Processing (7/50): src/NetworkMonitor.Console/Program.cs
Processing (8/50): src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
Processing (9/50): src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
Processing (10/50): src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
Processing (11/50): src/NetworkMonitor.Core/Models/HistoricalData.cs
Processing (12/50): src/NetworkMonitor.Core/Models/MonitorOptions.cs
Processing (13/50): src/NetworkMonitor.Core/Models/NetworkStatus.cs
Processing (14/50): src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
Processing (15/50): src/NetworkMonitor.Core/Models/PingResult.cs
Processing (16/50): src/NetworkMonitor.Core/Models/StorageOptions.cs
Processing (17/50): src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
Processing (18/50): src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
Processing (19/50): src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
Processing (20/50): src/NetworkMonitor.Core/Services/GatewayDetector.cs
Processing (21/50): src/NetworkMonitor.Core/Services/IGatewayDetector.cs
Processing (22/50): src/NetworkMonitor.Core/Services/IInternetTargetProvider.cs
Processing (23/50): src/NetworkMonitor.Core/Services/INetworkConfigurationService.cs
Processing (24/50): src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
Processing (25/50): src/NetworkMonitor.Core/Services/InternetTargetProvider.cs
Processing (26/50): src/NetworkMonitor.Core/Services/IPingService.cs
Processing (27/50): src/NetworkMonitor.Core/Services/IStatusDisplay.cs
Processing (28/50): src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
Processing (29/50): src/NetworkMonitor.Core/Services/NetworkConfigurationService.cs
Processing (30/50): src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
Processing (31/50): src/NetworkMonitor.Core/Services/PingService.cs
Processing (32/50): src/NetworkMonitor.Core/Storage/IStorageService.cs
Processing (33/50): src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
Processing (34/50): src/NetworkMonitor.slnx
Processing (35/50): src/NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs
Processing (36/50): src/NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs
Processing (37/50): src/NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs
Processing (38/50): src/NetworkMonitor.Tests/Fakes/FakePingService.cs
Processing (39/50): src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
Processing (40/50): src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
Processing (41/50): src/NetworkMonitor.Tests/Fakes/NullLogger.cs
Processing (42/50): src/NetworkMonitor.Tests/Models/MonitorOptionsTests.cs
Processing (43/50): src/NetworkMonitor.Tests/Models/NetworkStatusEventArgsTests.cs
Processing (44/50): src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
Processing (45/50): src/NetworkMonitor.Tests/NetworkStatusTests.cs
Processing (46/50): src/NetworkMonitor.Tests/PingResultTests.cs
Processing (47/50): src/NetworkMonitor.Tests/Services/GatewayDetectorTests.cs
Processing (48/50): src/NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs
Processing (49/50): src/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs
Processing (50/50): src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 50
Output file size: 0.14 MB

real	0m0.461s
user	0m0.245s
sys	0m0.297s
.NET SDK:
 Version:           10.0.101
 Commit:            fad253f51b
 Workload version:  10.0.101.1
 MSBuild version:   18.0.6+fad253f51

Runtime Environment:
 OS Name:     fedora
 OS Version:  43
 OS Platform: Linux
 RID:         fedora.43-x64
 Base Path:   /usr/lib64/dotnet/sdk/10.0.101/

.NET workloads installed:
 [android]
   Installation Source: SDK 10.0.100
   Manifest Version:    36.1.2/10.0.100
   Manifest Path:       /home/kushal/.dotnet/sdk-manifests/10.0.100/microsoft.net.sdk.android/36.1.2/WorkloadManifest.json
   Install Type:        FileBased

Configured to use workload sets when installing new manifests.

Host:
  Version:      10.0.1
  Architecture: x64
  Commit:       fad253f51b

.NET SDKs installed:
  10.0.101 [/usr/lib64/dotnet/sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]

Other architectures found:
  None

Environment variables:
  DOTNET_BUNDLE_EXTRACT_BASE_DIR           [/home/kushal/.cache/dotnet_bundle_extract]
  DOTNET_ROOT                              [/usr/lib64/dotnet]

global.json file:
  Not found

Learn more:
  https://aka.ms/dotnet/info

Download .NET:
  https://aka.ms/dotnet/download

real	0m0.149s
user	0m0.126s
sys	0m0.022s

real	0m6.009s
user	0m8.405s
sys	0m0.701s
Restore complete (0.4s)

Build succeeded in 0.5s

real	0m0.670s
user	0m0.691s
sys	0m0.130s

Build succeeded in 0.4s

real	0m0.560s
user	0m0.582s
sys	0m0.092s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 succeeded (2.5s) → NetworkMonitor.Core/bin/Debug/net10.0/NetworkMonitor.Core.dll
  NetworkMonitor.Tests net10.0 failed with 3 error(s) (0.2s)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs(34,13): error CS0104: 'NullLogger<>' is an ambiguous reference between 'NetworkMonitor.Tests.Fakes.NullLogger<T>' and 'Microsoft.Extensions.Logging.Abstractions.NullLogger<T>'
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs(29,13): error CS0104: 'NullLogger<>' is an ambiguous reference between 'NetworkMonitor.Tests.Fakes.NullLogger<T>' and 'Microsoft.Extensions.Logging.Abstractions.NullLogger<T>'
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs(14,21): error CA1001: Type 'NetworkMonitorServiceTests' owns disposable field(s) '_configService' but is not disposable (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001)
  NetworkMonitor.Console net10.0 succeeded (0.3s) → NetworkMonitor.Console/bin/Debug/net10.0/NetworkMonitor.Console.dll

Build failed with 3 error(s) in 3.4s

real	0m3.505s
user	0m1.382s
sys	0m0.204s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 succeeded (0.0s) → NetworkMonitor.Core/bin/Debug/net10.0/NetworkMonitor.Core.dll
  NetworkMonitor.Tests net10.0 failed with 3 error(s) (0.1s)
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs(34,13): error CS0104: 'NullLogger<>' is an ambiguous reference between 'NetworkMonitor.Tests.Fakes.NullLogger<T>' and 'Microsoft.Extensions.Logging.Abstractions.NullLogger<T>'
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs(29,13): error CS0104: 'NullLogger<>' is an ambiguous reference between 'NetworkMonitor.Tests.Fakes.NullLogger<T>' and 'Microsoft.Extensions.Logging.Abstractions.NullLogger<T>'
    /home/kushal/src/dotnet/network-monitor/src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs(14,21): error CA1001: Type 'NetworkMonitorServiceTests' owns disposable field(s) '_configService' but is not disposable (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1001)

Build failed with 3 error(s) in 0.7s

real	0m0.876s
user	0m0.896s
sys	0m0.181s
Restore complete (0.4s)

Build succeeded in 0.5s
Project 'NetworkMonitor.Console' has the following package references
   [net10.0]: 
   Top-level Package                            Requested   Resolved
   > Microsoft.Extensions.Hosting               10.0.1      10.0.1  
   > OpenTelemetry.Exporter.Console             1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting           1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime      1.14.0      1.14.0  

Project 'NetworkMonitor.Core' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Data.Sqlite                          10.0.1      10.0.1  
   > Microsoft.Extensions.Hosting                   10.0.1      10.0.1  
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.Extensions.Options                   10.0.1      10.0.1  
   > OpenTelemetry                                  1.14.0      1.14.0  
   > OpenTelemetry.Exporter.Console                 1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting               1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime          1.14.0      1.14.0  

Project 'NetworkMonitor.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.NET.Test.Sdk                         18.0.1      18.0.1  
   > xunit.runner.visualstudio                      3.1.5       3.1.5   
   > xunit.v3                                       3.2.1       3.2.1   


real	0m1.323s
user	0m1.287s
sys	0m0.254s
Restore complete (0.4s)

Build succeeded in 0.5s

The following sources were used:
   https://api.nuget.org/v3/index.json

The given project `NetworkMonitor.Console` has no updates given the current sources.
The given project `NetworkMonitor.Core` has no updates given the current sources.
The given project `NetworkMonitor.Tests` has no updates given the current sources.

real	0m3.179s
user	0m2.010s
sys	0m0.293s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ 
