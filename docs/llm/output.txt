kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/MyImapDownloader$ mkdir -p ~/src/dotnet/network-monitor
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/MyImapDownloader$ cd ~/src/dotnet/network-monitor
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ pwd
/home/kushal/src/dotnet/network-monitor
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ git init
hint: Using 'master' as the name for the initial branch. This default branch name
hint: will change to "main" in Git 3.0. To configure the initial branch name
hint: to use in all of your new repositories, which will suppress this warning,
hint: call:
hint:
hint: 	git config --global init.defaultBranch <name>
hint:
hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
hint: 'development'. The just-created branch can be renamed via this command:
hint:
hint: 	git branch -m <name>
hint:
hint: Disable this message with "git config set advice.defaultBranchName false"
Initialized empty Git repository in /home/kushal/src/dotnet/network-monitor/.git/
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ touch export.sh
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ touch docs/llm/dump.txt
touch: cannot touch 'docs/llm/dump.txt': No such file or directory
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ cd ~/src/dotnet/network-monitor; cat export.sh; time bash export.sh 
#!/bin/sh
# Export Project Files to Single Text File
# POSIX-compliant script for any *nix system

set -e

# Default values
PROJECT_PATH="${1:-.}"
OUTPUT_FILE="${2:-docs/llm/dump.txt}"

# File extensions to include (space-separated)
INCLUDE_EXTENSIONS="cs json xml csproj sln slnx props config cshtml razor js css scss html yml yaml sql"

# Directories to exclude (space-separated)
EXCLUDE_DIRS="bin obj .vs .git node_modules packages .vscode .idea docs"

# File patterns to exclude (space-separated)
EXCLUDE_FILES="*.exe *.dll *.pdb *.cache *.log *.md *.txt LICENSE* LICENCE*"

# Colors (will be disabled if not a terminal)
if [ -t 1 ]; then
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    CYAN='\033[0;36m'
    WHITE='\033[0;37m'
    NC='\033[0m'
else
    GREEN='' YELLOW='' CYAN='' WHITE='' NC=''
fi

log_green() { printf "${GREEN}%s${NC}\n" "$1"; }
log_yellow() { printf "${YELLOW}%s${NC}\n" "$1"; }
log_cyan() { printf "${CYAN}%s${NC}\n" "$1"; }
log_white() { printf "${WHITE}%s${NC}\n" "$1"; }

# Resolve to absolute path
PROJECT_PATH=$(cd "$PROJECT_PATH" && pwd)

log_green "Starting project export..."
log_yellow "Project Path: $PROJECT_PATH"
log_yellow "Output File: $OUTPUT_FILE"

# Create output directory if needed
OUTPUT_PATH="$PROJECT_PATH/$OUTPUT_FILE"
OUTPUT_DIR=$(dirname "$OUTPUT_PATH")
mkdir -p "$OUTPUT_DIR"

# Build find exclude pattern for directories
build_exclude_pattern() {
    first=1
    for dir in $EXCLUDE_DIRS; do
        if [ $first -eq 1 ]; then
            printf "%s" "-name $dir"
            first=0
        else
            printf "%s" " -o -name $dir"
        fi
    done
}

# Check if file matches exclude patterns
is_excluded_file() {
    filename=$(basename "$1")
    for pattern in $EXCLUDE_FILES; do
        case "$filename" in
            $pattern) return 0 ;;
        esac
    done
    return 1
}

# Check if file has included extension
has_included_extension() {
    filename=$(basename "$1")
    ext="${filename##*.}"
    [ "$ext" != "$filename" ] || return 1
    for inc_ext in $INCLUDE_EXTENSIONS; do
        [ "$ext" = "$inc_ext" ] && return 0
    done
    return 1
}

# Write header
cat > "$OUTPUT_PATH" << EOF
===============================================================================
PROJECT EXPORT
Generated: $(date)
Project Path: $PROJECT_PATH
===============================================================================

EOF

# Generate directory structure
log_cyan "Generating directory structure..."

cat >> "$OUTPUT_PATH" << EOF
DIRECTORY STRUCTURE:
===================

EOF

# Try tree command first, fall back to find-based tree
if command -v tree >/dev/null 2>&1; then
    # Build tree ignore pattern
    TREE_IGNORE=$(echo "$EXCLUDE_DIRS" | tr ' ' '|')
    tree "$PROJECT_PATH" -a -I "$TREE_IGNORE" --noreport >> "$OUTPUT_PATH" 2>/dev/null || {
        # macOS tree might have different options
        tree "$PROJECT_PATH" -a -I "$TREE_IGNORE" >> "$OUTPUT_PATH" 2>/dev/null || true
    }
else
    log_yellow "tree command not available, using find alternative..."
    
    # Simple find-based directory listing
    (
        cd "$PROJECT_PATH"
        echo "$(basename "$PROJECT_PATH")/"
        
        # Build prune expression
        PRUNE_EXPR=""
        for dir in $EXCLUDE_DIRS; do
            PRUNE_EXPR="$PRUNE_EXPR -name $dir -prune -o"
        done
        
        eval "find . $PRUNE_EXPR -print" 2>/dev/null | \
            grep -v '^\.$' | \
            sort | \
            while read -r path; do
                # Calculate depth for indentation
                depth=$(echo "$path" | tr -cd '/' | wc -c)
                indent=""
                i=0
                while [ $i -lt "$depth" ]; do
                    indent="$indent    "
                    i=$((i + 1))
                done
                name=$(basename "$path")
                if [ -d "$path" ]; then
                    echo "${indent}+-- ${name}/"
                else
                    echo "${indent}+-- ${name}"
                fi
            done
    ) >> "$OUTPUT_PATH"
fi

printf "\n\n" >> "$OUTPUT_PATH"

# Collect and process files
log_cyan "Collecting files..."

# Create temp file for file list
TEMP_FILE=$(mktemp)
trap 'rm -f "$TEMP_FILE"' EXIT

# Find all matching files
(
    cd "$PROJECT_PATH"
    
    # Build prune expression for excluded directories
    PRUNE_EXPR=""
    for dir in $EXCLUDE_DIRS; do
        PRUNE_EXPR="$PRUNE_EXPR -name $dir -prune -o"
    done
    
    # Find files, excluding directories
    eval "find . $PRUNE_EXPR -type f -print" 2>/dev/null
) | while read -r file; do
    # Check extension
    if has_included_extension "$file"; then
        # Check exclusion patterns
        if ! is_excluded_file "$file"; then
            echo "$file"
        fi
    fi
done | sort -u > "$TEMP_FILE"

FILE_COUNT=$(wc -l < "$TEMP_FILE" | tr -d ' ')
log_green "Found $FILE_COUNT files to export"

# Export each file
cat >> "$OUTPUT_PATH" << EOF
FILE CONTENTS:
==============

EOF

CURRENT=0
while IFS= read -r file; do
    CURRENT=$((CURRENT + 1))
    
    # Remove leading ./
    REL_PATH="${file#./}"
    FULL_PATH="$PROJECT_PATH/$REL_PATH"
    
    log_white "Processing ($CURRENT/$FILE_COUNT): $REL_PATH"
    
    # Get file info (portable way)
    if [ -f "$FULL_PATH" ]; then
        FILE_SIZE=$(wc -c < "$FULL_PATH" | tr -d ' ')
        FILE_SIZE_KB=$(awk "BEGIN {printf \"%.2f\", $FILE_SIZE / 1024}")
        
        # Get modification time (different on Linux vs BSD/macOS)
        if stat --version >/dev/null 2>&1; then
            # GNU stat (Linux)
            MOD_TIME=$(stat -c '%y' "$FULL_PATH" 2>/dev/null | cut -d'.' -f1)
        else
            # BSD stat (macOS)
            MOD_TIME=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$FULL_PATH" 2>/dev/null)
        fi
        
        cat >> "$OUTPUT_PATH" << EOF
================================================================================
FILE: $REL_PATH
SIZE: ${FILE_SIZE_KB} KB
MODIFIED: $MOD_TIME
================================================================================

EOF
        
        # Read and append file content
        if [ -s "$FULL_PATH" ]; then
            cat "$FULL_PATH" >> "$OUTPUT_PATH" 2>/dev/null || \
                echo "[ERROR READING FILE]" >> "$OUTPUT_PATH"
        else
            echo "[EMPTY FILE]" >> "$OUTPUT_PATH"
        fi
        
        printf "\n\n" >> "$OUTPUT_PATH"
    fi
done < "$TEMP_FILE"

# Add footer
cat >> "$OUTPUT_PATH" << EOF
===============================================================================
EXPORT COMPLETED: $(date)
Total Files Exported: $FILE_COUNT
Output File: $OUTPUT_PATH
===============================================================================
EOF

log_green ""
log_green "Export completed successfully!"
log_yellow "Output file: $OUTPUT_PATH"
log_green "Total files exported: $FILE_COUNT"

# Display file size
if [ -f "$OUTPUT_PATH" ]; then
    OUTPUT_SIZE=$(wc -c < "$OUTPUT_PATH" | tr -d ' ')
    OUTPUT_SIZE_MB=$(awk "BEGIN {printf \"%.2f\", $OUTPUT_SIZE / 1048576}")
    log_cyan "Output file size: ${OUTPUT_SIZE_MB} MB"
fi
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 0 files to export

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 0
Output file size: 0.00 MB

real	0m0.025s
user	0m0.011s
sys	0m0.016s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ dotnet --info
.NET SDK:
 Version:           10.0.101
 Commit:            fad253f51b
 Workload version:  10.0.101.1
 MSBuild version:   18.0.6+fad253f51

Runtime Environment:
 OS Name:     fedora
 OS Version:  43
 OS Platform: Linux
 RID:         fedora.43-x64
 Base Path:   /usr/lib64/dotnet/sdk/10.0.101/

.NET workloads installed:
 [android]
   Installation Source: SDK 10.0.100
   Manifest Version:    36.1.2/10.0.100
   Manifest Path:       /home/kushal/.dotnet/sdk-manifests/10.0.100/microsoft.net.sdk.android/36.1.2/WorkloadManifest.json
   Install Type:        FileBased

Configured to use workload sets when installing new manifests.

Host:
  Version:      10.0.1
  Architecture: x64
  Commit:       fad253f51b

.NET SDKs installed:
  10.0.101 [/usr/lib64/dotnet/sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]

Other architectures found:
  None

Environment variables:
  DOTNET_BUNDLE_EXTRACT_BASE_DIR           [/home/kushal/.cache/dotnet_bundle_extract]
  DOTNET_ROOT                              [/usr/lib64/dotnet]

global.json file:
  Not found

Learn more:
  https://aka.ms/dotnet/info

Download .NET:
  https://aka.ms/dotnet/download
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ mkdir src
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ cd src/
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ dotnet new gitignore
The template "dotnet gitignore file" was created successfully.

kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor; cat export.sh; time bash export.sh 
#!/bin/sh
# Export Project Files to Single Text File
# POSIX-compliant script for any *nix system

set -e

# Default values
PROJECT_PATH="${1:-.}"
OUTPUT_FILE="${2:-docs/llm/dump.txt}"

# File extensions to include (space-separated)
INCLUDE_EXTENSIONS="cs json xml csproj sln slnx props config cshtml razor js css scss html yml yaml sql"

# Directories to exclude (space-separated)
EXCLUDE_DIRS="bin obj .vs .git node_modules packages .vscode .idea docs"

# File patterns to exclude (space-separated)
EXCLUDE_FILES="*.exe *.dll *.pdb *.cache *.log *.md *.txt LICENSE* LICENCE*"

# Colors (will be disabled if not a terminal)
if [ -t 1 ]; then
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    CYAN='\033[0;36m'
    WHITE='\033[0;37m'
    NC='\033[0m'
else
    GREEN='' YELLOW='' CYAN='' WHITE='' NC=''
fi

log_green() { printf "${GREEN}%s${NC}\n" "$1"; }
log_yellow() { printf "${YELLOW}%s${NC}\n" "$1"; }
log_cyan() { printf "${CYAN}%s${NC}\n" "$1"; }
log_white() { printf "${WHITE}%s${NC}\n" "$1"; }

# Resolve to absolute path
PROJECT_PATH=$(cd "$PROJECT_PATH" && pwd)

log_green "Starting project export..."
log_yellow "Project Path: $PROJECT_PATH"
log_yellow "Output File: $OUTPUT_FILE"

# Create output directory if needed
OUTPUT_PATH="$PROJECT_PATH/$OUTPUT_FILE"
OUTPUT_DIR=$(dirname "$OUTPUT_PATH")
mkdir -p "$OUTPUT_DIR"

# Build find exclude pattern for directories
build_exclude_pattern() {
    first=1
    for dir in $EXCLUDE_DIRS; do
        if [ $first -eq 1 ]; then
            printf "%s" "-name $dir"
            first=0
        else
            printf "%s" " -o -name $dir"
        fi
    done
}

# Check if file matches exclude patterns
is_excluded_file() {
    filename=$(basename "$1")
    for pattern in $EXCLUDE_FILES; do
        case "$filename" in
            $pattern) return 0 ;;
        esac
    done
    return 1
}

# Check if file has included extension
has_included_extension() {
    filename=$(basename "$1")
    ext="${filename##*.}"
    [ "$ext" != "$filename" ] || return 1
    for inc_ext in $INCLUDE_EXTENSIONS; do
        [ "$ext" = "$inc_ext" ] && return 0
    done
    return 1
}

# Write header
cat > "$OUTPUT_PATH" << EOF
===============================================================================
PROJECT EXPORT
Generated: $(date)
Project Path: $PROJECT_PATH
===============================================================================

EOF

# Generate directory structure
log_cyan "Generating directory structure..."

cat >> "$OUTPUT_PATH" << EOF
DIRECTORY STRUCTURE:
===================

EOF

# Try tree command first, fall back to find-based tree
if command -v tree >/dev/null 2>&1; then
    # Build tree ignore pattern
    TREE_IGNORE=$(echo "$EXCLUDE_DIRS" | tr ' ' '|')
    tree "$PROJECT_PATH" -a -I "$TREE_IGNORE" --noreport >> "$OUTPUT_PATH" 2>/dev/null || {
        # macOS tree might have different options
        tree "$PROJECT_PATH" -a -I "$TREE_IGNORE" >> "$OUTPUT_PATH" 2>/dev/null || true
    }
else
    log_yellow "tree command not available, using find alternative..."
    
    # Simple find-based directory listing
    (
        cd "$PROJECT_PATH"
        echo "$(basename "$PROJECT_PATH")/"
        
        # Build prune expression
        PRUNE_EXPR=""
        for dir in $EXCLUDE_DIRS; do
            PRUNE_EXPR="$PRUNE_EXPR -name $dir -prune -o"
        done
        
        eval "find . $PRUNE_EXPR -print" 2>/dev/null | \
            grep -v '^\.$' | \
            sort | \
            while read -r path; do
                # Calculate depth for indentation
                depth=$(echo "$path" | tr -cd '/' | wc -c)
                indent=""
                i=0
                while [ $i -lt "$depth" ]; do
                    indent="$indent    "
                    i=$((i + 1))
                done
                name=$(basename "$path")
                if [ -d "$path" ]; then
                    echo "${indent}+-- ${name}/"
                else
                    echo "${indent}+-- ${name}"
                fi
            done
    ) >> "$OUTPUT_PATH"
fi

printf "\n\n" >> "$OUTPUT_PATH"

# Collect and process files
log_cyan "Collecting files..."

# Create temp file for file list
TEMP_FILE=$(mktemp)
trap 'rm -f "$TEMP_FILE"' EXIT

# Find all matching files
(
    cd "$PROJECT_PATH"
    
    # Build prune expression for excluded directories
    PRUNE_EXPR=""
    for dir in $EXCLUDE_DIRS; do
        PRUNE_EXPR="$PRUNE_EXPR -name $dir -prune -o"
    done
    
    # Find files, excluding directories
    eval "find . $PRUNE_EXPR -type f -print" 2>/dev/null
) | while read -r file; do
    # Check extension
    if has_included_extension "$file"; then
        # Check exclusion patterns
        if ! is_excluded_file "$file"; then
            echo "$file"
        fi
    fi
done | sort -u > "$TEMP_FILE"

FILE_COUNT=$(wc -l < "$TEMP_FILE" | tr -d ' ')
log_green "Found $FILE_COUNT files to export"

# Export each file
cat >> "$OUTPUT_PATH" << EOF
FILE CONTENTS:
==============

EOF

CURRENT=0
while IFS= read -r file; do
    CURRENT=$((CURRENT + 1))
    
    # Remove leading ./
    REL_PATH="${file#./}"
    FULL_PATH="$PROJECT_PATH/$REL_PATH"
    
    log_white "Processing ($CURRENT/$FILE_COUNT): $REL_PATH"
    
    # Get file info (portable way)
    if [ -f "$FULL_PATH" ]; then
        FILE_SIZE=$(wc -c < "$FULL_PATH" | tr -d ' ')
        FILE_SIZE_KB=$(awk "BEGIN {printf \"%.2f\", $FILE_SIZE / 1024}")
        
        # Get modification time (different on Linux vs BSD/macOS)
        if stat --version >/dev/null 2>&1; then
            # GNU stat (Linux)
            MOD_TIME=$(stat -c '%y' "$FULL_PATH" 2>/dev/null | cut -d'.' -f1)
        else
            # BSD stat (macOS)
            MOD_TIME=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$FULL_PATH" 2>/dev/null)
        fi
        
        cat >> "$OUTPUT_PATH" << EOF
================================================================================
FILE: $REL_PATH
SIZE: ${FILE_SIZE_KB} KB
MODIFIED: $MOD_TIME
================================================================================

EOF
        
        # Read and append file content
        if [ -s "$FULL_PATH" ]; then
            cat "$FULL_PATH" >> "$OUTPUT_PATH" 2>/dev/null || \
                echo "[ERROR READING FILE]" >> "$OUTPUT_PATH"
        else
            echo "[EMPTY FILE]" >> "$OUTPUT_PATH"
        fi
        
        printf "\n\n" >> "$OUTPUT_PATH"
    fi
done < "$TEMP_FILE"

# Add footer
cat >> "$OUTPUT_PATH" << EOF
===============================================================================
EXPORT COMPLETED: $(date)
Total Files Exported: $FILE_COUNT
Output File: $OUTPUT_PATH
===============================================================================
EOF

log_green ""
log_green "Export completed successfully!"
log_yellow "Output file: $OUTPUT_PATH"
log_green "Total files exported: $FILE_COUNT"

# Display file size
if [ -f "$OUTPUT_PATH" ]; then
    OUTPUT_SIZE=$(wc -c < "$OUTPUT_PATH" | tr -d ' ')
    OUTPUT_SIZE_MB=$(awk "BEGIN {printf \"%.2f\", $OUTPUT_SIZE / 1048576}")
    log_cyan "Output file size: ${OUTPUT_SIZE_MB} MB"
fi
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 0 files to export

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 0
Output file size: 0.00 MB

real	0m0.021s
user	0m0.011s
sys	0m0.015s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor$ 
