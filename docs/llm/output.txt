kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/; time bash export.sh; cd ~/src/dotnet/network-monitor/src; time dotnet --info; time dotnet format; time dotnet restore; time dotnet clean; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;
Starting project export...
Project Path: /home/kushal/src/dotnet/network-monitor
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 36 files to export
Processing (1/36): .github/workflows/build-and-test.yml
Processing (2/36): .github/workflows/release.yml
Processing (3/36): src/Directory.Build.props
Processing (4/36): src/Directory.Packages.props
Processing (5/36): src/NetworkMonitor.Console/appsettings.json
Processing (6/36): src/NetworkMonitor.Console/NetworkMonitor.Console.csproj
Processing (7/36): src/NetworkMonitor.Console/Program.cs
Processing (8/36): src/NetworkMonitor.Core/Exporters/FileExporterExtensions.cs
Processing (9/36): src/NetworkMonitor.Core/Exporters/FileExporterOptions.cs
Processing (10/36): src/NetworkMonitor.Core/Exporters/FileMetricExporter.cs
Processing (11/36): src/NetworkMonitor.Core/Models/HistoricalData.cs
Processing (12/36): src/NetworkMonitor.Core/Models/MonitorOptions.cs
Processing (13/36): src/NetworkMonitor.Core/Models/NetworkStatus.cs
Processing (14/36): src/NetworkMonitor.Core/Models/NetworkStatusEventArgs.cs
Processing (15/36): src/NetworkMonitor.Core/Models/PingResult.cs
Processing (16/36): src/NetworkMonitor.Core/Models/StorageOptions.cs
Processing (17/36): src/NetworkMonitor.Core/NetworkMonitor.Core.csproj
Processing (18/36): src/NetworkMonitor.Core/ServiceCollectionExtensions.cs
Processing (19/36): src/NetworkMonitor.Core/Services/ConsoleStatusDisplay.cs
Processing (20/36): src/NetworkMonitor.Core/Services/INetworkMonitorService.cs
Processing (21/36): src/NetworkMonitor.Core/Services/IPingService.cs
Processing (22/36): src/NetworkMonitor.Core/Services/IStatusDisplay.cs
Processing (23/36): src/NetworkMonitor.Core/Services/MonitorBackgroundService.cs
Processing (24/36): src/NetworkMonitor.Core/Services/NetworkMonitorService.cs
Processing (25/36): src/NetworkMonitor.Core/Services/PingService.cs
Processing (26/36): src/NetworkMonitor.Core/Storage/IStorageService.cs
Processing (27/36): src/NetworkMonitor.Core/Storage/SqliteStorageService.cs
Processing (28/36): src/NetworkMonitor.slnx
Processing (29/36): src/NetworkMonitor.Tests/Fakes/FakePingService.cs
Processing (30/36): src/NetworkMonitor.Tests/Fakes/FakePingServiceTests.cs
Processing (31/36): src/NetworkMonitor.Tests/Fakes/FakeStorageService.cs
Processing (32/36): src/NetworkMonitor.Tests/Fakes/NullLogger.cs
Processing (33/36): src/NetworkMonitor.Tests/NetworkMonitor.Tests.csproj
Processing (34/36): src/NetworkMonitor.Tests/NetworkStatusTests.cs
Processing (35/36): src/NetworkMonitor.Tests/PingResultTests.cs
Processing (36/36): src/NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/network-monitor/docs/llm/dump.txt
Total files exported: 36
Output file size: 0.10 MB

real	0m0.313s
user	0m0.179s
sys	0m0.201s
.NET SDK:
 Version:           10.0.101
 Commit:            fad253f51b
 Workload version:  10.0.101.1
 MSBuild version:   18.0.6+fad253f51

Runtime Environment:
 OS Name:     fedora
 OS Version:  43
 OS Platform: Linux
 RID:         fedora.43-x64
 Base Path:   /usr/lib64/dotnet/sdk/10.0.101/

.NET workloads installed:
 [android]
   Installation Source: SDK 10.0.100
   Manifest Version:    36.1.2/10.0.100
   Manifest Path:       /home/kushal/.dotnet/sdk-manifests/10.0.100/microsoft.net.sdk.android/36.1.2/WorkloadManifest.json
   Install Type:        FileBased

Configured to use workload sets when installing new manifests.

Host:
  Version:      10.0.1
  Architecture: x64
  Commit:       fad253f51b

.NET SDKs installed:
  10.0.101 [/usr/lib64/dotnet/sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 10.0.1 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]

Other architectures found:
  None

Environment variables:
  DOTNET_BUNDLE_EXTRACT_BASE_DIR           [/home/kushal/.cache/dotnet_bundle_extract]
  DOTNET_ROOT                              [/usr/lib64/dotnet]

global.json file:
  Not found

Learn more:
  https://aka.ms/dotnet/info

Download .NET:
  https://aka.ms/dotnet/download

real	0m0.143s
user	0m0.115s
sys	0m0.027s

real	0m5.330s
user	0m6.750s
sys	0m0.636s
Restore complete (0.5s)

Build succeeded in 0.6s

real	0m0.704s
user	0m0.702s
sys	0m0.126s

Build succeeded in 0.4s

real	0m0.569s
user	0m0.587s
sys	0m0.106s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 succeeded (0.3s) → NetworkMonitor.Core/bin/Debug/net10.0/NetworkMonitor.Core.dll
  NetworkMonitor.Console net10.0 succeeded (0.3s) → NetworkMonitor.Console/bin/Debug/net10.0/NetworkMonitor.Console.dll
  NetworkMonitor.Tests net10.0 succeeded (0.4s) → NetworkMonitor.Tests/bin/Debug/net10.0/NetworkMonitor.Tests.dll

Build succeeded in 1.2s

real	0m1.378s
user	0m1.218s
sys	0m0.246s
Restore complete (0.4s)
  NetworkMonitor.Core net10.0 succeeded (0.1s) → NetworkMonitor.Core/bin/Debug/net10.0/NetworkMonitor.Core.dll
  NetworkMonitor.Tests net10.0 succeeded (0.1s) → NetworkMonitor.Tests/bin/Debug/net10.0/NetworkMonitor.Tests.dll
[xUnit.net 00:00:00.00] xUnit.net VSTest Adapter v3.1.5+1b188a7b0a (64-bit .NET 10.0.1)
[xUnit.net 00:00:00.14]   Discovering: NetworkMonitor.Tests
[xUnit.net 00:00:00.31]   Discovered:  NetworkMonitor.Tests
[xUnit.net 00:00:00.46]   Starting:    NetworkMonitor.Tests
[xUnit.net 00:00:00.57]   Finished:    NetworkMonitor.Tests (ID = '2e8f57cd5826539fc7a5cd3a97d27721fcb9a15ff7c496b1112166f6757858fe')
  NetworkMonitor.Tests test net10.0 succeeded (1.1s)

Test summary: total: 17, failed: 0, succeeded: 17, skipped: 0, duration: 1.1s
Build succeeded in 1.9s

real	0m2.026s
user	0m1.002s
sys	0m0.236s
Restore complete (0.4s)

Build succeeded in 0.5s
Project 'NetworkMonitor.Console' has the following package references
   [net10.0]: 
   Top-level Package                            Requested   Resolved
   > Microsoft.Extensions.Hosting               10.0.1      10.0.1  
   > OpenTelemetry.Exporter.Console             1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting           1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime      1.14.0      1.14.0  

Project 'NetworkMonitor.Core' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Data.Sqlite                          10.0.1      10.0.1  
   > Microsoft.Extensions.Hosting                   10.0.1      10.0.1  
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.Extensions.Options                   10.0.1      10.0.1  
   > OpenTelemetry                                  1.14.0      1.14.0  
   > OpenTelemetry.Exporter.Console                 1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting               1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime          1.14.0      1.14.0  

Project 'NetworkMonitor.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > Microsoft.Extensions.Logging.Abstractions      10.0.1      10.0.1  
   > Microsoft.NET.Test.Sdk                         18.0.1      18.0.1  
   > xunit.runner.visualstudio                      3.1.5       3.1.5   
   > xunit.v3                                       3.2.1       3.2.1   


real	0m1.342s
user	0m1.342s
sys	0m0.245s
Restore complete (0.4s)

Build succeeded in 0.5s

The following sources were used:
   https://api.nuget.org/v3/index.json

The given project `NetworkMonitor.Console` has no updates given the current sources.
The given project `NetworkMonitor.Core` has no updates given the current sources.
The given project `NetworkMonitor.Tests` has no updates given the current sources.

real	0m1.564s
user	0m1.560s
sys	0m0.245s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
#!/bin/bash
# =============================================================================
# Add Gateway Auto-Detection and Internet Target Fallback
# =============================================================================
# This script adds:
# 1. IGatewayDetector interface and cross-platform implementation
# 2. Auto-detection of default gateway (router) IP address
# 3. Fallback internet targets (1.1.1.1 if 8.8.8.8 is unavailable)
# 4. MonitorOptions changes to support "auto" detection
# 5. Comprehensive unit tests for all new functionality
#
# Philosophy: Make things work out of the box for most users while still
# allowing full configurability for those with special network setups.
# =============================================================================

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ensure we're in the src directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

log_info "Adding gateway auto-detection and internet target fallback..."
log_info "Working directory: $(pwd)"

# =============================================================================
# 1. Create IGatewayDetector interface
# =============================================================================
log_info "Creating IGatewayDetector interface..."

cat > NetworkMonitor.Core/Services/IGatewayDetector.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Detects the default gateway (router) IP address.
/// </summary>
/// <remarks>
/// The default gateway is advertised by DHCP and can be read from the OS
/// network configuration. This allows the application to work "out of the box"
/// without requiring users to manually configure their router IP.
/// </remarks>
public interface IGatewayDetector
{
    /// <summary>
    /// Attempts to detect the default gateway IP address.
    /// </summary>
    /// <returns>
    /// The IP address of the default gateway, or null if it cannot be detected.
    /// </returns>
    /// <remarks>
    /// On most systems, this returns the router IP (e.g., 192.168.1.1, 192.168.0.1, 10.0.0.1).
    /// Returns null if:
    /// - No network interfaces are available
    /// - No default gateway is configured (e.g., disconnected)
    /// - The system doesn't support gateway detection
    /// </remarks>
    string? DetectDefaultGateway();

    /// <summary>
    /// Gets a list of common gateway addresses to try as fallbacks.
    /// </summary>
    /// <remarks>
    /// If auto-detection fails, these are the most common gateway addresses
    /// used by consumer routers. The list is ordered by popularity.
    /// </remarks>
    IReadOnlyList<string> GetCommonGatewayAddresses();
}
EOF

# =============================================================================
# 2. Create GatewayDetector implementation
# =============================================================================
log_info "Creating GatewayDetector implementation..."

cat > NetworkMonitor.Core/Services/GatewayDetector.cs << 'EOF'
using System.Net.NetworkInformation;
using System.Net.Sockets;
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Cross-platform default gateway detector using System.Net.NetworkInformation.
/// </summary>
/// <remarks>
/// This implementation reads the default gateway from the OS routing table,
/// which is populated by DHCP or static configuration. Works on Windows,
/// macOS, and Linux without external dependencies.
/// </remarks>
public sealed class GatewayDetector : IGatewayDetector
{
    private readonly ILogger<GatewayDetector> _logger;

    /// <summary>
    /// Common gateway addresses used by consumer routers, ordered by popularity.
    /// These are used as fallbacks if auto-detection fails.
    /// </summary>
    private static readonly string[] CommonGateways =
    [
        "192.168.1.1",   // Most common (Linksys, TP-Link, many ISP routers)
        "192.168.0.1",   // Second most common (D-Link, Netgear, some ISPs)
        "10.0.0.1",      // Apple AirPort, some enterprise networks
        "192.168.2.1",   // Belkin, SMC
        "192.168.1.254", // Some ISP-provided routers (BT, etc.)
        "192.168.0.254", // Some ISP-provided routers
        "10.0.1.1",      // Apple AirPort alternate
        "192.168.10.1",  // Some business routers
        "192.168.100.1", // Some cable modems
        "172.16.0.1",    // Private network range (less common for home)
    ];

    public GatewayDetector(ILogger<GatewayDetector> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public string? DetectDefaultGateway()
    {
        try
        {
            _logger.LogDebug("Attempting to detect default gateway...");

            // Get all network interfaces that are up and have IPv4 connectivity
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(nic => nic.OperationalStatus == OperationalStatus.Up)
                .Where(nic => nic.NetworkInterfaceType != NetworkInterfaceType.Loopback)
                .Where(nic => nic.Supports(NetworkInterfaceComponent.IPv4))
                .ToList();

            _logger.LogDebug("Found {Count} active network interfaces", interfaces.Count);

            foreach (var nic in interfaces)
            {
                var ipProps = nic.GetIPProperties();
                var gateways = ipProps.GatewayAddresses;

                foreach (var gateway in gateways)
                {
                    // Skip IPv6 gateways and 0.0.0.0 (no gateway)
                    if (gateway.Address.AddressFamily != AddressFamily.InterNetwork)
                        continue;

                    var address = gateway.Address.ToString();
                    if (address == "0.0.0.0")
                        continue;

                    _logger.LogInformation(
                        "Detected default gateway: {Gateway} on interface {Interface}",
                        address, nic.Name);

                    return address;
                }
            }

            _logger.LogWarning("No default gateway found on any network interface");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to detect default gateway");
            return null;
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetCommonGatewayAddresses() => CommonGateways;
}
EOF

# =============================================================================
# 3. Create IInternetTargetProvider interface and implementation
# =============================================================================
log_info "Creating IInternetTargetProvider interface..."

cat > NetworkMonitor.Core/Services/IInternetTargetProvider.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with fallback support.
/// </summary>
/// <remarks>
/// Not all networks can reach all DNS providers. For example:
/// - Some countries block Google DNS (8.8.8.8)
/// - Some corporate networks only allow specific DNS servers
/// - Some ISPs intercept DNS traffic
/// 
/// This provider allows testing multiple targets and using the first
/// one that responds, ensuring the application works in various
/// network environments.
/// </remarks>
public interface IInternetTargetProvider
{
    /// <summary>
    /// Gets the ordered list of internet targets to try.
    /// </summary>
    /// <remarks>
    /// The first reachable target will be used for monitoring.
    /// Targets are ordered by reliability and global availability.
    /// </remarks>
    IReadOnlyList<string> GetTargets();

    /// <summary>
    /// Gets the primary (preferred) target.
    /// </summary>
    string PrimaryTarget { get; }
}
EOF

log_info "Creating InternetTargetProvider implementation..."

cat > NetworkMonitor.Core/Services/InternetTargetProvider.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides internet connectivity test targets with automatic fallback.
/// </summary>
public sealed class InternetTargetProvider : IInternetTargetProvider
{
    private readonly ILogger<InternetTargetProvider> _logger;
    private readonly MonitorOptions _options;

    /// <summary>
    /// Well-known, highly available DNS servers that can be used for
    /// connectivity testing. Ordered by global reliability.
    /// </summary>
    private static readonly string[] DefaultTargets =
    [
        "8.8.8.8",       // Google Public DNS (primary)
        "1.1.1.1",       // Cloudflare DNS (very fast, privacy-focused)
        "8.8.4.4",       // Google Public DNS (secondary)
        "1.0.0.1",       // Cloudflare DNS (secondary)
        "9.9.9.9",       // Quad9 DNS (security-focused)
        "208.67.222.222", // OpenDNS (Cisco)
        "208.67.220.220", // OpenDNS (secondary)
    ];

    public InternetTargetProvider(
        IOptions<MonitorOptions> options,
        ILogger<InternetTargetProvider> logger)
    {
        _options = options.Value;
        _logger = logger;

        _logger.LogDebug(
            "Internet target provider initialized with primary target: {Target}",
            PrimaryTarget);
    }

    /// <inheritdoc />
    public string PrimaryTarget => _options.InternetTarget;

    /// <inheritdoc />
    public IReadOnlyList<string> GetTargets()
    {
        // If user specified a custom target, put it first
        if (!string.IsNullOrWhiteSpace(_options.InternetTarget) &&
            !DefaultTargets.Contains(_options.InternetTarget, StringComparer.OrdinalIgnoreCase))
        {
            var customList = new List<string> { _options.InternetTarget };
            customList.AddRange(DefaultTargets);
            return customList;
        }

        // Reorder default list to put configured target first
        var targets = new List<string>(DefaultTargets);
        var configuredIndex = targets.FindIndex(
            t => t.Equals(_options.InternetTarget, StringComparison.OrdinalIgnoreCase));

        if (configuredIndex > 0)
        {
            var configured = targets[configuredIndex];
            targets.RemoveAt(configuredIndex);
            targets.Insert(0, configured);
        }

        return targets;
    }
}
EOF

# =============================================================================
# 4. Update MonitorOptions to support "auto" detection
# =============================================================================
log_info "Updating MonitorOptions..."

cat > NetworkMonitor.Core/Models/MonitorOptions.cs << 'EOF'
namespace NetworkMonitor.Core.Models;

/// <summary>
/// Configuration options for the network monitor.
/// Bound from appsettings.json or environment variables.
/// </summary>
public sealed class MonitorOptions
{
    /// <summary>
    /// Configuration section name in appsettings.json
    /// </summary>
    public const string SectionName = "NetworkMonitor";

    /// <summary>
    /// Special value indicating auto-detection should be used.
    /// </summary>
    public const string AutoDetect = "auto";

    /// <summary>
    /// Router/gateway IP address to ping for local network health.
    /// </summary>
    /// <remarks>
    /// Set to "auto" (default) to automatically detect the default gateway.
    /// The gateway is advertised by DHCP and can be read from the OS.
    /// 
    /// If auto-detection fails, common gateway addresses will be tried:
    /// 192.168.1.1, 192.168.0.1, 10.0.0.1, etc.
    /// 
    /// Set to a specific IP address to override auto-detection.
    /// </remarks>
    public string RouterAddress { get; set; } = AutoDetect;

    /// <summary>
    /// Internet target to ping for WAN connectivity.
    /// </summary>
    /// <remarks>
    /// Default: 8.8.8.8 (Google DNS - highly reliable)
    /// 
    /// If this target is unreachable, fallback targets will be tried:
    /// 1.1.1.1 (Cloudflare), 9.9.9.9 (Quad9), etc.
    /// 
    /// This is useful for networks that block specific DNS providers.
    /// </remarks>
    public string InternetTarget { get; set; } = "8.8.8.8";

    /// <summary>
    /// Timeout for each ping in milliseconds.
    /// Default: 3000ms (3 seconds)
    /// </summary>
    public int TimeoutMs { get; set; } = 3000;

    /// <summary>
    /// Interval between monitoring cycles in milliseconds.
    /// Default: 5000ms (5 seconds)
    /// </summary>
    public int IntervalMs { get; set; } = 5000;

    /// <summary>
    /// Number of pings per target per cycle.
    /// Default: 3 (for statistical significance)
    /// </summary>
    public int PingsPerCycle { get; set; } = 3;

    /// <summary>
    /// Latency threshold (ms) below which is considered "excellent".
    /// Default: 20ms
    /// </summary>
    public int ExcellentLatencyMs { get; set; } = 20;

    /// <summary>
    /// Latency threshold (ms) below which is considered "good".
    /// Default: 100ms
    /// </summary>
    public int GoodLatencyMs { get; set; } = 100;

    /// <summary>
    /// Packet loss percentage above which network is "degraded".
    /// Default: 10%
    /// </summary>
    public int DegradedPacketLossPercent { get; set; } = 10;

    /// <summary>
    /// Whether to use fallback targets if primary fails.
    /// Default: true
    /// </summary>
    public bool EnableFallbackTargets { get; set; } = true;

    /// <summary>
    /// Checks if router address should be auto-detected.
    /// </summary>
    public bool IsRouterAutoDetect =>
        string.IsNullOrWhiteSpace(RouterAddress) ||
        RouterAddress.Equals(AutoDetect, StringComparison.OrdinalIgnoreCase);
}
EOF

# =============================================================================
# 5. Create NetworkConfigurationService to handle detection and fallbacks
# =============================================================================
log_info "Creating NetworkConfigurationService..."

cat > NetworkMonitor.Core/Services/NetworkConfigurationService.cs << 'EOF'
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Resolves network configuration by combining user settings with auto-detection.
/// </summary>
/// <remarks>
/// This service implements the "just works" philosophy:
/// 1. Try to auto-detect the gateway if configured to do so
/// 2. Fall back to common gateway addresses if detection fails
/// 3. Verify targets are reachable before using them
/// 4. Cache resolved addresses to avoid repeated detection
/// </remarks>
public sealed class NetworkConfigurationService : INetworkConfigurationService
{
    private readonly IGatewayDetector _gatewayDetector;
    private readonly IInternetTargetProvider _internetTargetProvider;
    private readonly IPingService _pingService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkConfigurationService> _logger;

    private string? _resolvedRouterAddress;
    private string? _resolvedInternetTarget;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private bool _initialized;

    public NetworkConfigurationService(
        IGatewayDetector gatewayDetector,
        IInternetTargetProvider internetTargetProvider,
        IPingService pingService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkConfigurationService> logger)
    {
        _gatewayDetector = gatewayDetector;
        _internetTargetProvider = internetTargetProvider;
        _pingService = pingService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedRouterAddress;
    }

    /// <inheritdoc />
    public async Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
    {
        await EnsureInitializedAsync(cancellationToken);
        return _resolvedInternetTarget ?? _internetTargetProvider.PrimaryTarget;
    }

    /// <inheritdoc />
    public async Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        await _initLock.WaitAsync(cancellationToken);
        try
        {
            if (_initialized)
                return;

            _logger.LogInformation("Initializing network configuration...");

            // Resolve router address
            _resolvedRouterAddress = await ResolveRouterAddressAsync(cancellationToken);
            if (_resolvedRouterAddress != null)
            {
                _logger.LogInformation("Router address resolved to: {Address}", _resolvedRouterAddress);
            }
            else
            {
                _logger.LogWarning("Could not resolve router address - router monitoring will be skipped");
            }

            // Resolve internet target
            _resolvedInternetTarget = await ResolveInternetTargetAsync(cancellationToken);
            _logger.LogInformation("Internet target resolved to: {Target}", _resolvedInternetTarget);

            _initialized = true;
        }
        finally
        {
            _initLock.Release();
        }
    }

    private async Task EnsureInitializedAsync(CancellationToken cancellationToken)
    {
        if (!_initialized)
        {
            await InitializeAsync(cancellationToken);
        }
    }

    private async Task<string?> ResolveRouterAddressAsync(CancellationToken cancellationToken)
    {
        // If user specified a specific address, use it directly
        if (!_options.IsRouterAutoDetect)
        {
            _logger.LogDebug("Using configured router address: {Address}", _options.RouterAddress);
            return _options.RouterAddress;
        }

        // Try auto-detection first
        _logger.LogDebug("Attempting router auto-detection...");
        var detected = _gatewayDetector.DetectDefaultGateway();
        if (detected != null)
        {
            // Verify it's reachable
            if (await IsReachableAsync(detected, cancellationToken))
            {
                _logger.LogDebug("Auto-detected gateway {Address} is reachable", detected);
                return detected;
            }
            _logger.LogWarning("Auto-detected gateway {Address} is not reachable", detected);
        }

        // Fall back to common addresses
        _logger.LogDebug("Trying common gateway addresses...");
        foreach (var address in _gatewayDetector.GetCommonGatewayAddresses())
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(address, cancellationToken))
            {
                _logger.LogInformation("Found reachable gateway at common address: {Address}", address);
                return address;
            }
        }

        return null;
    }

    private async Task<string> ResolveInternetTargetAsync(CancellationToken cancellationToken)
    {
        var targets = _internetTargetProvider.GetTargets();

        // If fallback is disabled, just use the primary
        if (!_options.EnableFallbackTargets)
        {
            _logger.LogDebug("Fallback targets disabled, using primary: {Target}", targets[0]);
            return targets[0];
        }

        // Try each target until one responds
        foreach (var target in targets)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (await IsReachableAsync(target, cancellationToken))
            {
                if (target != targets[0])
                {
                    _logger.LogInformation(
                        "Primary target {Primary} unreachable, using fallback: {Fallback}",
                        targets[0], target);
                }
                return target;
            }

            _logger.LogDebug("Internet target {Target} is not reachable", target);
        }

        // If nothing is reachable, use the primary anyway (might come back online)
        _logger.LogWarning(
            "No internet targets are reachable, defaulting to: {Target}",
            targets[0]);
        return targets[0];
    }

    private async Task<bool> IsReachableAsync(string target, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _pingService.PingAsync(
                target,
                _options.TimeoutMs,
                cancellationToken);
            return result.Success;
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Ping to {Target} failed", target);
            return false;
        }
    }
}
EOF

# =============================================================================
# 6. Create INetworkConfigurationService interface
# =============================================================================
log_info "Creating INetworkConfigurationService interface..."

cat > NetworkMonitor.Core/Services/INetworkConfigurationService.cs << 'EOF'
namespace NetworkMonitor.Core.Services;

/// <summary>
/// Provides resolved network configuration for monitoring.
/// </summary>
/// <remarks>
/// This service handles the complexity of:
/// - Auto-detecting the default gateway
/// - Falling back to common gateway addresses
/// - Finding a reachable internet target
/// - Caching resolved addresses
/// </remarks>
public interface INetworkConfigurationService
{
    /// <summary>
    /// Gets the resolved router/gateway address to monitor.
    /// </summary>
    /// <returns>
    /// The router IP address, or null if no router could be found.
    /// When null, router monitoring should be skipped.
    /// </returns>
    Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the resolved internet target to monitor.
    /// </summary>
    /// <returns>
    /// The internet target IP address. Always returns a value,
    /// falling back to the configured default if nothing is reachable.
    /// </returns>
    Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Initializes the service by detecting and verifying targets.
    /// </summary>
    /// <remarks>
    /// This is called automatically on first access, but can be called
    /// explicitly during startup for eager initialization.
    /// </remarks>
    Task InitializeAsync(CancellationToken cancellationToken = default);
}
EOF

# =============================================================================
# 7. Update NetworkMonitorService to use configuration service
# =============================================================================
log_info "Updating NetworkMonitorService..."

cat > NetworkMonitor.Core/Services/NetworkMonitorService.cs << 'EOF'
using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;

namespace NetworkMonitor.Core.Services;

/// <summary>
/// Main network monitoring service.
/// Coordinates ping operations and computes overall network health.
/// Exposes OpenTelemetry metrics for observability.
/// </summary>
public sealed class NetworkMonitorService : INetworkMonitorService
{
    private static readonly ActivitySource ActivitySource = new("NetworkMonitor.Core");
    private static readonly Meter Meter = new("NetworkMonitor.Core");

    // Metrics - use static readonly for performance (CA1859)
    private static readonly Counter<long> CheckCounter = Meter.CreateCounter<long>(
        "network_monitor.checks",
        description: "Number of network health checks performed");

    private static readonly Histogram<double> RouterLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.router_latency_ms",
        unit: "ms",
        description: "Router ping latency distribution");

    private static readonly Histogram<double> InternetLatencyHistogram = Meter.CreateHistogram<double>(
        "network_monitor.internet_latency_ms",
        unit: "ms",
        description: "Internet ping latency distribution");

    private static readonly Counter<long> FailureCounter = Meter.CreateCounter<long>(
        "network_monitor.failures",
        description: "Number of ping failures by target type");

    private readonly IPingService _pingService;
    private readonly INetworkConfigurationService _configService;
    private readonly MonitorOptions _options;
    private readonly ILogger<NetworkMonitorService> _logger;

    private NetworkStatus? _lastStatus;

    /// <inheritdoc />
    public event EventHandler<NetworkStatusEventArgs>? StatusChanged;

    /// <summary>
    /// Creates a new network monitor service.
    /// </summary>
    public NetworkMonitorService(
        IPingService pingService,
        INetworkConfigurationService configService,
        IOptions<MonitorOptions> options,
        ILogger<NetworkMonitorService> logger)
    {
        _pingService = pingService;
        _configService = configService;
        _options = options.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<NetworkStatus> CheckNetworkAsync(CancellationToken cancellationToken = default)
    {
        using var activity = ActivitySource.StartActivity("CheckNetwork");

        cancellationToken.ThrowIfCancellationRequested();

        CheckCounter.Add(1);

        // Get resolved targets
        var routerAddress = await _configService.GetRouterAddressAsync(cancellationToken);
        var internetTarget = await _configService.GetInternetTargetAsync(cancellationToken);

        // Ping router (if we have one)
        PingResult? routerResult = null;
        if (routerAddress != null)
        {
            var routerResults = await _pingService.PingMultipleAsync(
                routerAddress,
                _options.PingsPerCycle,
                _options.TimeoutMs,
                cancellationToken);

            routerResult = AggregateResults(routerResults);

            if (routerResult.Success && routerResult.RoundtripTimeMs.HasValue)
            {
                RouterLatencyHistogram.Record(routerResult.RoundtripTimeMs.Value);
            }
            else
            {
                FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "router"));
            }

            activity?.SetTag("router.success", routerResult.Success);
            activity?.SetTag("router.latency_ms", routerResult.RoundtripTimeMs);
        }
        else
        {
            _logger.LogDebug("No router address configured, skipping router ping");
        }

        // Ping internet
        var internetResults = await _pingService.PingMultipleAsync(
            internetTarget,
            _options.PingsPerCycle,
            _options.TimeoutMs,
            cancellationToken);

        var internetResult = AggregateResults(internetResults);

        if (internetResult.Success && internetResult.RoundtripTimeMs.HasValue)
        {
            InternetLatencyHistogram.Record(internetResult.RoundtripTimeMs.Value);
        }
        else
        {
            FailureCounter.Add(1, new KeyValuePair<string, object?>("target_type", "internet"));
        }

        activity?.SetTag("internet.success", internetResult.Success);
        activity?.SetTag("internet.latency_ms", internetResult.RoundtripTimeMs);

        // Compute overall health
        var (health, message) = ComputeHealth(routerResult, internetResult);

        var status = new NetworkStatus(
            health,
            routerResult,
            internetResult,
            DateTimeOffset.UtcNow,
            message);

        activity?.SetTag("health", health.ToString());

        // Fire event if status changed
        if (_lastStatus == null || _lastStatus.Health != status.Health)
        {
            _logger.LogInformation(
                "Network status changed: {OldHealth} -> {NewHealth}: {Message}",
                _lastStatus?.Health.ToString() ?? "Unknown",
                status.Health,
                status.Message);

            StatusChanged?.Invoke(this, new NetworkStatusEventArgs(status, _lastStatus));
        }

        _lastStatus = status;
        return status;
    }

    private static PingResult AggregateResults(IReadOnlyList<PingResult> results)
    {
        if (results.Count == 0)
        {
            return PingResult.Failed("unknown", "No ping results");
        }

        var successful = results.Where(r => r.Success).ToList();
        var target = results[0].Target;

        if (successful.Count == 0)
        {
            return PingResult.Failed(target, results[0].ErrorMessage ?? "All pings failed");
        }

        // Return average latency of successful pings
        var avgLatency = (long)successful.Average(r => r.RoundtripTimeMs ?? 0);
        return PingResult.Succeeded(target, avgLatency);
    }

    private (NetworkHealth Health, string Message) ComputeHealth(
        PingResult? routerResult,
        PingResult internetResult)
    {
        // If we have a router configured and it's not responding, that's significant
        if (routerResult != null && !routerResult.Success)
        {
            return !internetResult.Success
                ? (NetworkHealth.Offline, "Cannot reach router or internet")
                : (NetworkHealth.Degraded, "Cannot reach router but internet works");
        }

        // If internet is down
        if (!internetResult.Success)
        {
            return routerResult?.Success == true
                ? (NetworkHealth.Poor, "Router OK but cannot reach internet")
                : (NetworkHealth.Offline, "Cannot reach internet");
        }

        // Both are up - check latency
        var internetLatency = internetResult.RoundtripTimeMs ?? 0;
        var routerLatency = routerResult?.RoundtripTimeMs ?? 0;

        return internetLatency switch
        {
            <= 50 when routerLatency <= 10 => (NetworkHealth.Excellent, "Network is excellent"),
            <= 100 => (NetworkHealth.Good, "Network is good"),
            <= 200 => (NetworkHealth.Degraded, "Network is degraded (high latency)"),
            _ => (NetworkHealth.Poor, "Network is poor (very high latency)")
        };
    }
}
EOF

# =============================================================================
# 8. Update ServiceCollectionExtensions to register new services
# =============================================================================
log_info "Updating ServiceCollectionExtensions..."

cat > NetworkMonitor.Core/ServiceCollectionExtensions.cs << 'EOF'
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NetworkMonitor.Core.Exporters;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Core.Storage;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

namespace NetworkMonitor.Core;

/// <summary>
/// Extension methods for registering Network Monitor services.
/// Encapsulates all the DI wiring in one place.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers all Network Monitor services with the DI container.
    /// </summary>
    public static IServiceCollection AddNetworkMonitor(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Bind options from configuration
        services.Configure<MonitorOptions>(
            configuration.GetSection(MonitorOptions.SectionName));
        services.Configure<StorageOptions>(
            configuration.GetSection(StorageOptions.SectionName));

        // Register core services
        services.AddSingleton<IPingService, PingService>();
        services.AddSingleton<IGatewayDetector, GatewayDetector>();
        services.AddSingleton<IInternetTargetProvider, InternetTargetProvider>();
        services.AddSingleton<INetworkConfigurationService, NetworkConfigurationService>();
        services.AddSingleton<INetworkMonitorService, NetworkMonitorService>();
        services.AddSingleton<IStatusDisplay, ConsoleStatusDisplay>();
        services.AddSingleton<IStorageService, SqliteStorageService>();

        // Register background service
        services.AddHostedService<MonitorBackgroundService>();

        return services;
    }

    /// <summary>
    /// Adds OpenTelemetry metrics with file and console export.
    /// </summary>
    public static IServiceCollection AddNetworkMonitorTelemetry(
        this IServiceCollection services,
        FileExporterOptions? fileOptions = null)
    {
        fileOptions ??= FileExporterOptions.Default;

        services.AddOpenTelemetry()
            .ConfigureResource(resource => resource
                .AddService(
                    serviceName: "NetworkMonitor",
                    serviceVersion: "1.0.0"))
            .WithMetrics(metrics =>
            {
                metrics
                    .AddMeter("NetworkMonitor.Core")
                    .AddRuntimeInstrumentation()
                    .AddConsoleExporter()
                    .AddFileExporter(fileOptions);
            });

        return services;
    }
}
EOF

# =============================================================================
# 9. Update appsettings.json to use auto-detection by default
# =============================================================================
log_info "Updating appsettings.json..."

cat > NetworkMonitor.Console/appsettings.json << 'EOF'
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "NetworkMonitor": "Information"
    }
  },
  "NetworkMonitor": {
    "RouterAddress": "auto",
    "InternetTarget": "8.8.8.8",
    "TimeoutMs": 3000,
    "IntervalMs": 5000,
    "PingsPerCycle": 3,
    "ExcellentLatencyMs": 20,
    "GoodLatencyMs": 100,
    "DegradedPacketLossPercent": 10,
    "EnableFallbackTargets": true
  },
  "Storage": {
    "RetentionDays": 30,
    "DatabasePath": ""
  }
}
EOF

# =============================================================================
# 10. Create unit tests for gateway detection
# =============================================================================
log_info "Creating unit tests..."

mkdir -p NetworkMonitor.Tests/Services

# Create fake gateway detector for tests
cat > NetworkMonitor.Tests/Fakes/FakeGatewayDetector.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake gateway detector for testing.
/// </summary>
public sealed class FakeGatewayDetector : IGatewayDetector
{
    private string? _gatewayToReturn;
    private readonly List<string> _commonGateways = ["192.168.1.1", "192.168.0.1", "10.0.0.1"];

    /// <summary>
    /// Configures the detector to return a specific gateway.
    /// </summary>
    public FakeGatewayDetector WithGateway(string? gateway)
    {
        _gatewayToReturn = gateway;
        return this;
    }

    /// <summary>
    /// Configures the detector to return null (no gateway found).
    /// </summary>
    public FakeGatewayDetector WithNoGateway()
    {
        _gatewayToReturn = null;
        return this;
    }

    /// <summary>
    /// Configures the common gateways list.
    /// </summary>
    public FakeGatewayDetector WithCommonGateways(params string[] gateways)
    {
        _commonGateways.Clear();
        _commonGateways.AddRange(gateways);
        return this;
    }

    public string? DetectDefaultGateway() => _gatewayToReturn;

    public IReadOnlyList<string> GetCommonGatewayAddresses() => _commonGateways;
}
EOF

# Create fake internet target provider
cat > NetworkMonitor.Tests/Fakes/FakeInternetTargetProvider.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake internet target provider for testing.
/// </summary>
public sealed class FakeInternetTargetProvider : IInternetTargetProvider
{
    private readonly List<string> _targets = ["8.8.8.8", "1.1.1.1"];

    public string PrimaryTarget => _targets[0];

    public FakeInternetTargetProvider WithTargets(params string[] targets)
    {
        _targets.Clear();
        _targets.AddRange(targets);
        return this;
    }

    public IReadOnlyList<string> GetTargets() => _targets;
}
EOF

# Create fake network configuration service
cat > NetworkMonitor.Tests/Fakes/FakeNetworkConfigurationService.cs << 'EOF'
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake network configuration service for testing.
/// </summary>
public sealed class FakeNetworkConfigurationService : INetworkConfigurationService
{
    private string? _routerAddress = "192.168.1.1";
    private string _internetTarget = "8.8.8.8";

    public FakeNetworkConfigurationService WithRouterAddress(string? address)
    {
        _routerAddress = address;
        return this;
    }

    public FakeNetworkConfigurationService WithInternetTarget(string target)
    {
        _internetTarget = target;
        return this;
    }

    public Task<string?> GetRouterAddressAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_routerAddress);

    public Task<string> GetInternetTargetAsync(CancellationToken cancellationToken = default)
        => Task.FromResult(_internetTarget);

    public Task InitializeAsync(CancellationToken cancellationToken = default)
        => Task.CompletedTask;
}
EOF

# Create GatewayDetector tests
cat > NetworkMonitor.Tests/Services/GatewayDetectorTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for GatewayDetector.
/// Note: These tests run against the real network stack, so results
/// depend on the test environment. We test the interface contract.
/// </summary>
public sealed class GatewayDetectorTests
{
    private readonly GatewayDetector _detector;

    public GatewayDetectorTests()
    {
        _detector = new GatewayDetector(NullLogger<GatewayDetector>.Instance);
    }

    [Fact]
    public void DetectDefaultGateway_ReturnsValidIpOrNull()
    {
        // Act
        var result = _detector.DetectDefaultGateway();

        // Assert - should be null or a valid IP
        if (result != null)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", result);
        }
    }

    [Fact]
    public void GetCommonGatewayAddresses_ReturnsNonEmptyList()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        Assert.NotEmpty(addresses);
        Assert.Contains("192.168.1.1", addresses);
        Assert.Contains("192.168.0.1", addresses);
        Assert.Contains("10.0.0.1", addresses);
    }

    [Fact]
    public void GetCommonGatewayAddresses_AllAreValidIpAddresses()
    {
        // Act
        var addresses = _detector.GetCommonGatewayAddresses();

        // Assert
        foreach (var address in addresses)
        {
            Assert.Matches(@"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", address);
        }
    }
}
EOF

# Create InternetTargetProvider tests
cat > NetworkMonitor.Tests/Services/InternetTargetProviderTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for InternetTargetProvider.
/// </summary>
public sealed class InternetTargetProviderTests
{
    [Fact]
    public void PrimaryTarget_ReturnsConfiguredTarget()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act & Assert
        Assert.Equal("1.1.1.1", provider.PrimaryTarget);
    }

    [Fact]
    public void GetTargets_ReturnsConfiguredTargetFirst()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions { InternetTarget = "1.1.1.1" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("1.1.1.1", targets[0]);
    }

    [Fact]
    public void GetTargets_IncludesMultipleFallbacks()
    {
        // Arrange
        var options = Options.Create(new MonitorOptions());
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.True(targets.Count >= 3, "Should have multiple fallback targets");
        Assert.Contains("8.8.8.8", targets);
        Assert.Contains("1.1.1.1", targets);
    }

    [Fact]
    public void GetTargets_CustomTargetAddedToFront()
    {
        // Arrange - use a target not in the default list
        var options = Options.Create(new MonitorOptions { InternetTarget = "4.4.4.4" });
        var provider = new InternetTargetProvider(options, NullLogger<InternetTargetProvider>.Instance);

        // Act
        var targets = provider.GetTargets();

        // Assert
        Assert.Equal("4.4.4.4", targets[0]);
        Assert.Contains("8.8.8.8", targets); // Default fallbacks still present
    }
}
EOF

# Create NetworkConfigurationService tests
cat > NetworkMonitor.Tests/Services/NetworkConfigurationServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkConfigurationService.
/// </summary>
public sealed class NetworkConfigurationServiceTests
{
    private readonly FakeGatewayDetector _gatewayDetector;
    private readonly FakeInternetTargetProvider _internetTargetProvider;
    private readonly FakePingService _pingService;

    public NetworkConfigurationServiceTests()
    {
        _gatewayDetector = new FakeGatewayDetector();
        _internetTargetProvider = new FakeInternetTargetProvider();
        _pingService = new FakePingService();
    }

    private NetworkConfigurationService CreateService(MonitorOptions? options = null)
    {
        return new NetworkConfigurationService(
            _gatewayDetector,
            _internetTargetProvider,
            _pingService,
            Options.Create(options ?? new MonitorOptions()),
            NullLogger<NetworkConfigurationService>.Instance);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenAutoDetect_ReturnsDetectedGateway()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254");
        _pingService.AlwaysSucceed(5);
        var service = CreateService(new MonitorOptions { RouterAddress = "auto" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.1.254", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenConfigured_ReturnsConfiguredAddress()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.254"); // Should be ignored
        var service = CreateService(new MonitorOptions { RouterAddress = "10.0.0.1" });

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("10.0.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenDetectionFails_TriesCommonAddresses()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1", "192.168.0.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("192.168.0.1", 5));
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("192.168.0.1", result);
    }

    [Fact]
    public async Task GetRouterAddressAsync_WhenNothingReachable_ReturnsNull()
    {
        // Arrange
        _gatewayDetector
            .WithNoGateway()
            .WithCommonGateways("192.168.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService();

        // Act
        var result = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryReachable_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysSucceed(10);
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenPrimaryUnreachable_ReturnsFallback()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService
            .QueueResult(Core.Models.PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(Core.Models.PingResult.Succeeded("1.1.1.1", 10));
        var service = CreateService();

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("1.1.1.1", result);
    }

    [Fact]
    public async Task GetInternetTargetAsync_WhenFallbackDisabled_ReturnsPrimary()
    {
        // Arrange
        _internetTargetProvider.WithTargets("8.8.8.8", "1.1.1.1");
        _pingService.AlwaysFail("Timeout");
        var service = CreateService(new MonitorOptions { EnableFallbackTargets = false });

        // Act
        var result = await service.GetInternetTargetAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal("8.8.8.8", result); // Returns primary even if unreachable
    }

    [Fact]
    public async Task InitializeAsync_CachesResults()
    {
        // Arrange
        _gatewayDetector.WithGateway("192.168.1.1");
        _pingService.AlwaysSucceed(5);
        var service = CreateService();

        // Act
        await service.InitializeAsync(TestContext.Current.CancellationToken);
        var result1 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Change the detector (shouldn't affect cached result)
        _gatewayDetector.WithGateway("10.0.0.1");
        var result2 = await service.GetRouterAddressAsync(TestContext.Current.CancellationToken);

        // Assert - both should return cached value
        Assert.Equal("192.168.1.1", result1);
        Assert.Equal("192.168.1.1", result2);
    }
}
EOF

# Update NetworkMonitorServiceTests to use new configuration service
cat > NetworkMonitor.Tests/Services/NetworkMonitorServiceTests.cs << 'EOF'
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;
using NetworkMonitor.Tests.Fakes;
using Xunit;

namespace NetworkMonitor.Tests.Services;

/// <summary>
/// Tests for NetworkMonitorService.
/// Uses fake implementations for isolation.
/// </summary>
public sealed class NetworkMonitorServiceTests
{
    private readonly FakePingService _pingService;
    private readonly FakeNetworkConfigurationService _configService;
    private readonly NetworkMonitorService _service;

    public NetworkMonitorServiceTests()
    {
        _pingService = new FakePingService();
        _configService = new FakeNetworkConfigurationService();
        var options = Options.Create(new MonitorOptions());
        _service = new NetworkMonitorService(
            _pingService,
            _configService,
            options,
            NullLogger<NetworkMonitorService>.Instance);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothSucceed_ReturnsExcellent()
    {
        // Arrange
        _pingService.AlwaysSucceed(latencyMs: 5);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Excellent, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenRouterFails_ReturnsDegradedOrPoor()
    {
        // Arrange - router fails, internet succeeds
        _configService.WithRouterAddress("192.168.1.1");
        _pingService
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Failed("192.168.1.1", "Timeout"))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 20));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Degraded, status.Health);
        Assert.False(status.RouterResult?.Success);
        Assert.True(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenInternetFails_ReturnsPoor()
    {
        // Arrange - router succeeds, internet fails
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 5))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"))
            .QueueResult(PingResult.Failed("8.8.8.8", "Timeout"));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
        Assert.True(status.RouterResult?.Success);
        Assert.False(status.InternetResult?.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenBothFail_ReturnsOffline()
    {
        // Arrange
        _pingService.AlwaysFail("Network unreachable");

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Offline, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_WhenNoRouterConfigured_SkipsRouterPing()
    {
        // Arrange
        _configService.WithRouterAddress(null);
        _pingService.AlwaysSucceed(20);

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Null(status.RouterResult);
        Assert.NotNull(status.InternetResult);
        Assert.True(status.InternetResult.Success);
    }

    [Fact]
    public async Task CheckNetworkAsync_HighLatency_ReturnsDegraded()
    {
        // Arrange - High latency on internet
        _pingService
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("192.168.1.1", 10))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500))
            .QueueResult(PingResult.Succeeded("8.8.8.8", 500));

        // Act
        var status = await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(NetworkHealth.Poor, status.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_FiresStatusChangedEvent()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        NetworkStatus? receivedStatus = null;
        _service.StatusChanged += (_, e) => receivedStatus = e.CurrentStatus;

        // Act
        await _service.CheckNetworkAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(receivedStatus);
        Assert.Equal(NetworkHealth.Excellent, receivedStatus.Health);
    }

    [Fact]
    public async Task CheckNetworkAsync_RespectsCancellation()
    {
        // Arrange
        _pingService.AlwaysSucceed(5);
        using var cts = new CancellationTokenSource();
        await cts.CancelAsync();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => _service.CheckNetworkAsync(cts.Token));
    }
}
EOF

# Create MonitorOptions tests
cat > NetworkMonitor.Tests/Models/MonitorOptionsTests.cs << 'EOF'
using NetworkMonitor.Core.Models;
using Xunit;

namespace NetworkMonitor.Tests.Models;

/// <summary>
/// Tests for MonitorOptions.
/// </summary>
public sealed class MonitorOptionsTests
{
    [Fact]
    public void IsRouterAutoDetect_WhenAuto_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "auto" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenAutoUppercase_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "AUTO" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenEmpty_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "" };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenNull_ReturnsTrue()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = null! };

        // Act & Assert
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void IsRouterAutoDetect_WhenIpAddress_ReturnsFalse()
    {
        // Arrange
        var options = new MonitorOptions { RouterAddress = "192.168.1.1" };

        // Act & Assert
        Assert.False(options.IsRouterAutoDetect);
    }

    [Fact]
    public void DefaultRouterAddress_IsAuto()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.Equal("auto", options.RouterAddress);
        Assert.True(options.IsRouterAutoDetect);
    }

    [Fact]
    public void EnableFallbackTargets_DefaultsToTrue()
    {
        // Arrange & Act
        var options = new MonitorOptions();

        // Assert
        Assert.True(options.EnableFallbackTargets);
    }
}
EOF

# Create Models directory in tests if needed
mkdir -p NetworkMonitor.Tests/Models

# =============================================================================
# 11. Update FakePingService with additional helper methods
# =============================================================================
log_info "Updating FakePingService..."

cat > NetworkMonitor.Tests/Fakes/FakePingService.cs << 'EOF'
using NetworkMonitor.Core.Models;
using NetworkMonitor.Core.Services;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Fake ping service for testing.
/// Allows controlled responses without actual network calls.
/// </summary>
public sealed class FakePingService : IPingService
{
    private readonly Queue<PingResult> _queuedResults = new();
    private Func<string, PingResult>? _resultFactory;

    /// <summary>
    /// Queues a specific result to be returned.
    /// Results are dequeued in FIFO order.
    /// </summary>
    public FakePingService QueueResult(PingResult result)
    {
        _queuedResults.Enqueue(result);
        return this;
    }

    /// <summary>
    /// Configures the service to always succeed with the given latency.
    /// </summary>
    public FakePingService AlwaysSucceed(long latencyMs = 10)
    {
        _resultFactory = target => PingResult.Succeeded(target, latencyMs);
        return this;
    }

    /// <summary>
    /// Configures the service to always fail with the given error.
    /// </summary>
    public FakePingService AlwaysFail(string error = "Timeout")
    {
        _resultFactory = target => PingResult.Failed(target, error);
        return this;
    }

    /// <summary>
    /// Configures a custom factory for generating results.
    /// </summary>
    public FakePingService WithFactory(Func<string, PingResult> factory)
    {
        _resultFactory = factory;
        return this;
    }

    /// <summary>
    /// Clears all queued results and resets the factory.
    /// </summary>
    public FakePingService Reset()
    {
        _queuedResults.Clear();
        _resultFactory = null;
        return this;
    }

    public Task<PingResult> PingAsync(
        string target,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (_queuedResults.Count > 0)
        {
            return Task.FromResult(_queuedResults.Dequeue());
        }

        if (_resultFactory != null)
        {
            return Task.FromResult(_resultFactory(target));
        }

        // Default: succeed with 10ms latency
        return Task.FromResult(PingResult.Succeeded(target, 10));
    }

    public async Task<IReadOnlyList<PingResult>> PingMultipleAsync(
        string target,
        int count,
        int timeoutMs,
        CancellationToken cancellationToken = default)
    {
        var results = new List<PingResult>(count);

        for (var i = 0; i < count; i++)
        {
            results.Add(await PingAsync(target, timeoutMs, cancellationToken));
        }

        return results;
    }
}
EOF

# =============================================================================
# 12. Update NullLogger helper
# =============================================================================
log_info "Updating NullLogger helper..."

cat > NetworkMonitor.Tests/Fakes/NullLogger.cs << 'EOF'
using Microsoft.Extensions.Logging;

namespace NetworkMonitor.Tests.Fakes;

/// <summary>
/// Null logger implementation for tests.
/// </summary>
public sealed class NullLogger<T> : ILogger<T>
{
    public static readonly NullLogger<T> Instance = new();

    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => null;

    public bool IsEnabled(LogLevel logLevel) => false;

    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        // Intentionally empty
    }
}
EOF

# =============================================================================
# Completion
# =============================================================================
log_success "=========================================="
log_success "Gateway detection and fallback support added!"
log_success "=========================================="
echo ""
log_info "Changes made:"
echo "  1. Added IGatewayDetector interface and GatewayDetector implementation"
echo "  2. Added IInternetTargetProvider interface and implementation"
echo "  3. Added INetworkConfigurationService for resolving targets"
echo "  4. Updated MonitorOptions to support 'auto' detection (now the default)"
echo "  5. Updated NetworkMonitorService to use configuration service"
echo "  6. Updated ServiceCollectionExtensions to register new services"
echo "  7. Updated appsettings.json with new defaults"
echo "  8. Added comprehensive unit tests for all new functionality"
echo ""
log_info "How it works:"
echo "  - Router address defaults to 'auto' which detects the default gateway"
echo "  - If detection fails, common addresses are tried (192.168.1.1, etc.)"
echo "  - Internet target defaults to 8.8.8.8 with fallbacks (1.1.1.1, etc.)"
echo "  - All settings can still be manually configured in appsettings.json"
echo ""
log_info "Next steps:"
echo "  1. dotnet build"
echo "  2. dotnet test"
echo "  3. dotnet run --project NetworkMonitor.Console"
echo ""
[INFO] Adding gateway auto-detection and internet target fallback...
[INFO] Working directory: /home/kushal/src/dotnet/network-monitor/src
[INFO] Creating IGatewayDetector interface...
[INFO] Creating GatewayDetector implementation...
[INFO] Creating IInternetTargetProvider interface...
[INFO] Creating InternetTargetProvider implementation...
[INFO] Updating MonitorOptions...
[INFO] Creating NetworkConfigurationService...
[INFO] Creating INetworkConfigurationService interface...
[INFO] Updating NetworkMonitorService...
[INFO] Updating ServiceCollectionExtensions...
[INFO] Updating appsettings.json...
[INFO] Creating unit tests...
generate-network-monitor.sh: line 1574: NetworkMonitor.Tests/Models/MonitorOptionsTests.cs: No such file or directory

real	0m0.025s
user	0m0.009s
sys	0m0.009s
kushal@syn-2600-6c56-9840-001d-0000-0000-0000-1157:~/src/dotnet/network-monitor/src$ cd ~/src/dotnet/network-monitor/src/; cat generate-network-monitor.sh; time bash generate-network-monitor.sh
